<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>👨🏻‍💻 on 👨🏻‍💻</title>
    <link>https://xtid.github.io/</link>
    <description>Recent content in 👨🏻‍💻 on 👨🏻‍💻</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 10 Jan 2021 23:35:28 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Links</title>
      <link>https://xtid.github.io/links/</link>
      <pubDate>Sun, 10 Jan 2021 23:35:28 +0800</pubDate>
      
      <guid>https://xtid.github.io/links/</guid>
      <description>&lt;p&gt;友情链接&lt;/p&gt;

&lt;blockquote&gt;
&lt;table style=&#34;width: 100%&#34;&gt;
 &lt;thead&gt;
  &lt;th colspan=&#34;3&#34;&gt;友情链接&lt;/th&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
  &lt;tr&gt;
  &lt;td align=&#34;center&#34;&gt;
      &lt;a href=&#34;http://jsshou.cn/&#34; title=&#34;JSShou的博客网站&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JSShou&lt;/a&gt;
    &lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>React调度过程</title>
      <link>https://xtid.github.io/2021/react%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Tue, 05 Jan 2021 23:02:17 +0800</pubDate>
      
      <guid>https://xtid.github.io/2021/react%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B/</guid>
      <description>

&lt;h2 id=&#34;1-forwardref&#34;&gt;1.forwardRef&lt;/h2&gt;

&lt;p&gt;用来解决高阶组件传递&lt;code&gt;ref&lt;/code&gt;的问题。它的用法就像是使用&lt;code&gt;redux&lt;/code&gt;的时候，在外面包裹一层，通过&lt;code&gt;...props&lt;/code&gt;的方式把外部的&lt;code&gt;props&lt;/code&gt;传入到实际组件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;const TargetComponent = React.forwardRef((props, ref) =&amp;gt; (
  &amp;lt;TargetComponent ref={ref} /&amp;gt;
))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-reactelement&#34;&gt;2.ReactElement&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ReactElement&lt;/code&gt;通过&lt;code&gt;createElement&lt;/code&gt;创建，调用该方法需要传入三个参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;type&lt;/li&gt;
&lt;li&gt;config&lt;/li&gt;
&lt;li&gt;children&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;type&lt;/code&gt;指代这个&lt;code&gt;ReactElement&lt;/code&gt;的类型&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;字符串比如&lt;code&gt;div&lt;/code&gt;，&lt;code&gt;p&lt;/code&gt;代表原生DOM，称为&lt;code&gt;HostComponent&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Class类型是我们继承自&lt;code&gt;Component&lt;/code&gt;或者&lt;code&gt;PureComponent&lt;/code&gt;的组件，称为&lt;code&gt;ClassComponent&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;方法就是&lt;code&gt;functional Component&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;原生提供的&lt;code&gt;Fragment&lt;/code&gt;、&lt;code&gt;AsyncMode&lt;/code&gt;等是Symbol，会被特殊处理&lt;/li&gt;
&lt;li&gt;TODO: 是否有其他的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从源码可以看出虽然创建的时候都是通过&lt;code&gt;config&lt;/code&gt;传入的，但是&lt;code&gt;key&lt;/code&gt;和&lt;code&gt;ref&lt;/code&gt;不会跟其他&lt;code&gt;config&lt;/code&gt;中的变量一起被处理，而是单独作为变量出现在&lt;code&gt;ReactElement&lt;/code&gt;上。&lt;/p&gt;

&lt;p&gt;从源码可以看出虽然创建的时候都是通过&lt;code&gt;config&lt;/code&gt;传入的，但是&lt;code&gt;key&lt;/code&gt;和&lt;code&gt;ref&lt;/code&gt;不会跟其他&lt;code&gt;config&lt;/code&gt;中的变量一起被处理，而是单独作为变量出现在&lt;code&gt;ReactElement&lt;/code&gt;上。在最后创建&lt;code&gt;ReactElement&lt;/code&gt;我们看到了这么一个变量&lt;code&gt;$$typeof&lt;/code&gt;，在这里他是一个常量：&lt;code&gt;REACT_ELEMENT_TYPE&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-react-children&#34;&gt;3.React Children&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;React&lt;/code&gt;上面有有一个&lt;code&gt;Children&lt;/code&gt;对象，上面有着&lt;code&gt;Children&lt;/code&gt;定义&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;const React = {
  Children: {
    map,
    forEach,
    count,
    toArray,
    only,
  },
	......
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;找到定义&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function mapChildren(children, func, context) {
  if (children == null) {
    return children
  }
  const result = []
  mapIntoWithKeyPrefixInternal(children, result, null, func, context)
  return result
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  let escapedPrefix = &#39;&#39;
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + &#39;/&#39;
  }
  const traverseContext = getPooledTraverseContext(
    array,
    escapedPrefix,
    func,
    context,
  )
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext)
  releaseTraverseContext(traverseContext)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到后面调用了&lt;code&gt;getPooledTraverseContext&lt;/code&gt;，这是从内容池中找到当前的&lt;code&gt;contex&lt;/code&gt;t对象，操作完了之后&lt;code&gt;releaseTraverseContext&lt;/code&gt;会把当前的&lt;code&gt;context&lt;/code&gt;对象清空然后放回到&lt;code&gt;pool&lt;/code&gt;中。然后调用&lt;code&gt;traverseAllChildren&lt;/code&gt;，这个方法的作用就是递归调用&lt;code&gt;mapChildren&lt;/code&gt;将所有&lt;code&gt;Children&lt;/code&gt;铺平，直到当前元素是一个有效的&lt;code&gt;ReactElement&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  const { result, keyPrefix, func, context } = bookKeeping

  let mappedChild = func.call(context, child, bookKeeping.count++)
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c =&amp;gt; c)
  } else if (mappedChild != null) {
    if (isValidElement(mappedChild)) {
      mappedChild = cloneAndReplaceKey(
        mappedChild,
        keyPrefix +
          (mappedChild.key &amp;amp;&amp;amp; (!child || child.key !== mappedChild.key)
            ? escapeUserProvidedKey(mappedChild.key) + &#39;/&#39;
            : &#39;&#39;) +
          childKey,
      )
    }
    result.push(mappedChild)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;React.Children.map(this.props.children, function (child) {
    return &amp;lt;li&amp;gt;{child}&amp;lt;/li&amp;gt;;
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-react中的数据结构&#34;&gt;4.React中的数据结构&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Update&lt;/code&gt; &amp;amp;&lt;code&gt;UpdateQueue&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;export type Update&amp;lt;State&amp;gt; = {
  // 更新的过期时间
  expirationTime: ExpirationTime,

  // export const UpdateState = 0;
  // export const ReplaceState = 1;
  // export const ForceUpdate = 2;
  // export const CaptureUpdate = 3;
  // 指定更新的类型，值为以上几种
  tag: 0 | 1 | 2 | 3,
  // 更新内容，比如`setState`接收的第一个参数
  payload: any, // 当前DOM元素？
  // 对应的回调，`setState`，`render`都有
  callback: (() =&amp;gt; mixed) | null,

  // 指向下一个更新
  next: Update&amp;lt;State&amp;gt; | null,
  // 指向下一个`side effect`
  nextEffect: Update&amp;lt;State&amp;gt; | null,
};

export type UpdateQueue&amp;lt;State&amp;gt; = {
  // 每次操作完更新之后的`state`
  baseState: State,

  // 队列中的第一个`Update`
  firstUpdate: Update&amp;lt;State&amp;gt; | null,
  // 队列中的最后一个`Update`
  lastUpdate: Update&amp;lt;State&amp;gt; | null,

  // 第一个捕获类型的`Update`
  firstCapturedUpdate: Update&amp;lt;State&amp;gt; | null,
  // 最后一个捕获类型的`Update`
  lastCapturedUpdate: Update&amp;lt;State&amp;gt; | null,

  // 第一个`side effect`
  firstEffect: Update&amp;lt;State&amp;gt; | null,
  // 最后一个`side effect`
  lastEffect: Update&amp;lt;State&amp;gt; | null,

  // 第一个和最后一个捕获产生的`side effect`
  firstCapturedEffect: Update&amp;lt;State&amp;gt; | null,
  lastCapturedEffect: Update&amp;lt;State&amp;gt; | null,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-初次reactdom-reander过程&#34;&gt;5.初次ReactDOM.reander过程&lt;/h2&gt;

&lt;p&gt;首先调用&lt;code&gt;legacyRenderSubtreeIntoContainer&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;ReactDOM = {
  render(
    element: React$Element&amp;lt;any&amp;gt;,
    container: DOMContainer,
    callback: ?Function,
  ) {
    return legacyRenderSubtreeIntoContainer(
      null,
      element,
      container,
      false,
      callback,
    )
  },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function legacyRenderSubtreeIntoContainer(
  parentComponent: ?React$Component&amp;lt;any, any&amp;gt;,
  children: ReactNodeList,
  container: DOMContainer,
  forceHydrate: boolean,
  callback: ?Function,
) {
  let root: Root = (container._reactRootContainer: any)
  if (!root) {
    // 生成root，当前传入的根container的_reactRootContainer指向生成的root
    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
      container,
      forceHydrate,
    )
    if (typeof callback === &#39;function&#39;) {
      const originalCallback = callback
      callback = function() {
        const instance = DOMRenderer.getPublicRootInstance(root._internalRoot)
        originalCallback.call(instance)
      }
    }
    // 首次render不比unbatchedUpdates
    DOMRenderer.unbatchedUpdates(() =&amp;gt; {
      if (parentComponent != null) {
        // 一般不会出现
      } else {
        root.render(children, callback)
      }
    })
  } else {
    // 有root的情况
  }
  return DOMRenderer.getPublicRootInstance(root._internalRoot)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;legacyCreateRootFromDOMContainer&lt;/code&gt;方法生成&lt;code&gt;root&lt;/code&gt;，返回的结果上的&lt;code&gt;_internalRoot&lt;/code&gt;指向这个&lt;code&gt;root&lt;/code&gt;。同时会调用&lt;code&gt;DOMRenderer.createContainer&lt;/code&gt;创建&lt;code&gt;FiberRoot&lt;/code&gt;，然后生成的&lt;code&gt;root&lt;/code&gt;的&lt;code&gt;current&lt;/code&gt;属性指向这个&lt;code&gt;FiberRoot&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function legacyCreateRootFromDOMContainer(
  container: DOMContainer,
  forceHydrate: boolean,
): Root {
  const shouldHydrate =
    forceHydrate || shouldHydrateDueToLegacyHeuristic(container)
  // First clear any existing content.
  if (!shouldHydrate) {
    let warned = false
    let rootSibling
    while ((rootSibling = container.lastChild)) {
      container.removeChild(rootSibling)
    }
  }
  // Legacy roots are not async by default.
  const isConcurrent = false
  return new ReactRoot(container, isConcurrent, shouldHydrate)
}

function ReactRoot(
  container: Container,
  isConcurrent: boolean,
  hydrate: boolean,
) {
  const root = DOMRenderer.createContainer(container, isConcurrent, hydrate)
  this._internalRoot = root
}

ReactRoot.prototype.render = function(
  children: ReactNodeList,
  callback: ?() =&amp;gt; mixed,
): Work {
  const root = this._internalRoot
  const work = new ReactWork()
  callback = callback === undefined ? null : callback
  if (__DEV__) {
    warnOnInvalidCallback(callback, &#39;render&#39;)
  }
  if (callback !== null) {
    work.then(callback)
  }
  DOMRenderer.updateContainer(children, root, null, work._onCommit)
  return work
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到还有个&lt;code&gt;updateContainer&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;export function updateContainer(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component&amp;lt;any, any&amp;gt;,
  callback: ?Function,
): ExpirationTime {
  const current = container.current
  const currentTime = requestCurrentTime()
  const expirationTime = computeExpirationForFiber(currentTime, current)
  return updateContainerAtExpirationTime(
    element,
    container,
    parentComponent,
    expirationTime,
    callback,
  )
}

export function updateContainerAtExpirationTime(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component&amp;lt;any, any&amp;gt;,
  expirationTime: ExpirationTime,
  callback: ?Function,
) {
  // TODO: If this is a nested container, this won&#39;t be the root.
  const current = container.current
  const context = getContextForSubtree(parentComponent)
  if (container.context === null) {
    container.context = context
  } else {
    container.pendingContext = context
  }

  return scheduleRootUpdate(current, element, expirationTime, callback)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到先生成一个时间&lt;code&gt;const expirationTime&lt;/code&gt;，也就是这次更新的超时时间，然后调用&lt;code&gt;updateContainerAtExpirationTime&lt;/code&gt;，然后调用&lt;code&gt;scheduleRootUpdate&lt;/code&gt;进行调度&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function scheduleRootUpdate(
  current: Fiber,
  element: ReactNodeList,
  expirationTime: ExpirationTime,
  callback: ?Function,
) {
  const update = createUpdate(expirationTime)

  update.payload = { element }

  callback = callback === undefined ? null : callback
  if (callback !== null) {
    warningWithoutStack(
      typeof callback === &#39;function&#39;,
      &#39;render(...): Expected the last optional `callback` argument to be a &#39; +
        &#39;function. Instead received: %s.&#39;,
      callback,
    )
    update.callback = callback
  }
  enqueueUpdate(current, update)

  scheduleWork(current, expirationTime)
  return expirationTime
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;scheduleRootUpdate&lt;/code&gt;会调用&lt;code&gt;createUpdate&lt;/code&gt;创建&lt;code&gt;Update&lt;/code&gt;对象，其&lt;code&gt;playload&lt;/code&gt;为&lt;code&gt;container&lt;/code&gt;上面的&lt;code&gt;ReactNodeList&lt;/code&gt;，然后调用&lt;code&gt;enqueueUpdate&lt;/code&gt;生成一个双向列表队列，然后调用&lt;code&gt;scheduleWork&lt;/code&gt;开始调用。上面的过程都是依赖的&lt;code&gt;FiberRoot&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;6-expirationtime&#34;&gt;6.expirationTime&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;import MAX_SIGNED_31_BIT_INT from &#39;./maxSigned31BitInt&#39;;

export type ExpirationTime = number;

export const NoWork = 0;
export const Never = 1;
export const Sync = MAX_SIGNED_31_BIT_INT;

const UNIT_SIZE = 10;
const MAGIC_NUMBER_OFFSET = MAX_SIGNED_31_BIT_INT - 1;

// 1 unit of expiration time represents 10ms.
export function msToExpirationTime(ms: number): ExpirationTime {
  // Always add an offset so that we don&#39;t clash with the magic number for NoWork.
  return MAGIC_NUMBER_OFFSET - ((ms / UNIT_SIZE) | 0);
}

export function expirationTimeToMs(expirationTime: ExpirationTime): number {
  return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;
}

function ceiling(num: number, precision: number): number {
  return (((num / precision) | 0) + 1) * precision;
}

function computeExpirationBucket(
  currentTime,
  expirationInMs,
  bucketSizeMs,
): ExpirationTime {
  return (
    MAGIC_NUMBER_OFFSET -
    ceiling(
      MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE,
      bucketSizeMs / UNIT_SIZE,
    )
  );
}

export const LOW_PRIORITY_EXPIRATION = 5000;
export const LOW_PRIORITY_BATCH_SIZE = 250;

export function computeAsyncExpiration(
  currentTime: ExpirationTime,
): ExpirationTime {
  return computeExpirationBucket(
    currentTime,
    LOW_PRIORITY_EXPIRATION,
    LOW_PRIORITY_BATCH_SIZE,
  );
}

export const HIGH_PRIORITY_EXPIRATION = __DEV__ ? 500 : 150;
export const HIGH_PRIORITY_BATCH_SIZE = 100;

export function computeInteractiveExpiration(currentTime: ExpirationTime) {
  return computeExpirationBucket(
    currentTime,
    HIGH_PRIORITY_EXPIRATION,
    HIGH_PRIORITY_BATCH_SIZE,
  );
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后的计算公式为&lt;code&gt;((((currentTime - 2 + 5000 / 10) / 25) | 0) + 1) * 25&lt;/code&gt;（公式存疑），也就是说最后的结果是以&lt;code&gt;25ms&lt;/code&gt;为单位向上增加的，在&lt;code&gt;25ms&lt;/code&gt;内，&lt;code&gt;react&lt;/code&gt;这样做为的是让两次时间非常想尽的更新得到同样的&lt;code&gt;expirationTime&lt;/code&gt;，然后他们的优先级就会判定一样，就会再一次更新中完成，也就是一个&lt;code&gt;batchedUpdates&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;计算当前&lt;code&gt;currentTime&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function requestCurrentTime() {
  if (isRendering) {
    return currentSchedulerTime
  }
  findHighestPriorityRoot()
  if (
    nextFlushedExpirationTime === NoWork ||
    nextFlushedExpirationTime === Never
  ) {
    recomputeCurrentRendererTime()
    currentSchedulerTime = currentRendererTime
    return currentSchedulerTime
  }
  return currentSchedulerTime
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;react&lt;/code&gt;为了避免每次计算&lt;code&gt;expirationTime&lt;/code&gt;都要&lt;code&gt;Date now&lt;/code&gt;，所以用&lt;code&gt;currentRendererTime&lt;/code&gt;来保存了这个值，上面的&lt;code&gt;currentSchedulerTime&lt;/code&gt;也是记录这个值的&lt;/p&gt;

&lt;p&gt;首先&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;if (isRendering) {
  return currentSchedulerTime
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个&lt;code&gt;isRendering&lt;/code&gt;只有在&lt;code&gt;performWorkOnRoot&lt;/code&gt;的时候才会被设置为&lt;code&gt;true&lt;/code&gt;，而其本身是一个同步的方法，不存在他执行到一半没有设置&lt;code&gt;isRendering&lt;/code&gt;为&lt;code&gt;false&lt;/code&gt;的时候就跳出，那么什么情况下会在这里出现新的&lt;code&gt;requestCurrentTime&lt;/code&gt;呢？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在生命周期方法中调用了&lt;code&gt;setState&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;需要挂起任务的时候&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也就是说 React 要求&lt;strong&gt;在一次&lt;code&gt;rendering&lt;/code&gt;过程中，新产生的&lt;code&gt;update&lt;/code&gt;用于计算过期时间的&lt;code&gt;current&lt;/code&gt;必须跟目前的&lt;code&gt;renderTime&lt;/code&gt;保持一致，同理在这个周期中所有产生的新的更新的过期时间都会保持一致！&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;  findHighestPriorityRoot()
  if (
    nextFlushedExpirationTime === NoWork ||
    nextFlushedExpirationTime === Never
  ) {
    recomputeCurrentRendererTime()
    currentSchedulerTime = currentRendererTime
    return currentSchedulerTime
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;findHighestPriorityRoot&lt;/code&gt;找到优先级最高的节点，同时设置&lt;code&gt;nextFlushedExpirationTime&lt;/code&gt;，然后if判断当前队列中没有更新的任务，就会重新计算当前时间，否则，还是返回最初的&lt;code&gt;currentSchedulerTime&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;7-各种expirationtime&#34;&gt;7.各种expirationTime&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;root.expirationTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;root.nextExpirationTimeToWorkOn&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;root.childExpirationTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;root.earliestPendingTime &amp;amp; root.lastestPendingTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;root.earliestSuspendedTime &amp;amp; root.lastestSuspendedTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;root.lastestPingedTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nextFlushedExpirationTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nextLatestAbsoluteTimeoutMs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;currentRendererTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;currentSchedulerTime&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;React&lt;/code&gt;更新是从&lt;code&gt;FilberRoot&lt;/code&gt;开始的，所以每次更新时都会遍历向上查找&lt;code&gt;FiberRoot&lt;/code&gt;，而这个&lt;code&gt;childExpirationTime&lt;/code&gt;会设置到每个父节点，代表其子节点&lt;code&gt;expirationTime&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pendingTime&lt;/code&gt;，在&lt;code&gt;FiberRoot&lt;/code&gt;上有两个值&lt;code&gt;earliestPendingTime&lt;/code&gt;和&lt;code&gt;lastestPedingTime&lt;/code&gt;，他们是一对值，&lt;strong&gt;用来记录所有子树中需要进行渲染的更新的&lt;code&gt;expirationTime&lt;/code&gt;的区间&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;suspendedTime&lt;/code&gt;，同样的在&lt;code&gt;ReactFiber&lt;/code&gt;上有两个值&lt;code&gt;earliestSuspendedTime&lt;/code&gt;和&lt;code&gt;lastestSuspendedTime&lt;/code&gt;，&lt;strong&gt;这两个值是用来记录被挂起的任务的过期时间的&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先我们定义一下什么情况下任务是被挂起的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;出现可捕获的错误并且还有优先级更低的任务的情况下&lt;/li&gt;
&lt;li&gt;当捕获到&lt;code&gt;thenable&lt;/code&gt;，并且需要设置&lt;code&gt;onTimeout&lt;/code&gt;的时候&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;root.expirationTime&lt;/code&gt;是用来标志当前渲染的过期时间的，请注意他只管本渲染周期，他并不管你现在的渲染目标是哪个，渲染目标是由&lt;code&gt;root.nextExpirationTimeToWorkOn&lt;/code&gt;来决定的。&lt;/p&gt;

&lt;p&gt;那么他们有什么区别呢？主要区别在于发挥作用的阶段&lt;/p&gt;

&lt;p&gt;&lt;code&gt;expirationTime&lt;/code&gt;作用于调度阶段，主要指责是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;决定是异步执行渲染还是同步执行渲染&lt;/li&gt;
&lt;li&gt;作为&lt;code&gt;react-scheduler&lt;/code&gt;的&lt;code&gt;timeout&lt;/code&gt;标准，决定是否要优先渲染&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;nextExpirationTimeToWorkOn&lt;/code&gt;主要作用于渲染阶段：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;决定那些更新要在当前周期中被执行&lt;/li&gt;
&lt;li&gt;通过跟每个节点的&lt;code&gt;expirationTime&lt;/code&gt;比较决定该节点是否可以直接&lt;code&gt;bailout&lt;/code&gt;（跳过）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;他们都是通过&lt;code&gt;pendingTime&lt;/code&gt;、&lt;code&gt;suspenededTime&lt;/code&gt;和&lt;code&gt;pingedTime&lt;/code&gt;中删选出来的，唯一的不同是，&lt;code&gt;nextExpirationTimeToWorkOn&lt;/code&gt;在没有&lt;code&gt;pending&lt;/code&gt;或者&lt;code&gt;pinged&lt;/code&gt;的任务的时候会选择最晚的&lt;code&gt;suspendedTime&lt;/code&gt;，而&lt;code&gt;expirationTime&lt;/code&gt;会选择最早的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;expirationTime&lt;/code&gt;的变化：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;scheduleWork&lt;/code&gt;的时候通过&lt;code&gt;markPendingExpirationTime&lt;/code&gt;设置&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;beginWork&lt;/code&gt;的时候被设置为&lt;code&gt;NoWork&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;onUncaughtError&lt;/code&gt;的时候设置为&lt;code&gt;NoWork&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onSuspend&lt;/code&gt;的时候又会设置回当次更新的&lt;code&gt;expirationTime&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;8-schedulework&#34;&gt;8.scheduleWork&lt;/h2&gt;

&lt;p&gt;上面说的在创建完更新队列后，就会调用&lt;code&gt;scheduleWork&lt;/code&gt;调度了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function scheduleWork(fiber: Fiber, expirationTime: ExpirationTime) {
  const root = scheduleWorkToRoot(fiber, expirationTime);
  if (root === null) {
    if (__DEV__) {
      switch (fiber.tag) {
        case ClassComponent:
          warnAboutUpdateOnUnmounted(fiber, true);
          break;
        case FunctionComponent:
        case ForwardRef:
        case MemoComponent:
        case SimpleMemoComponent:
          warnAboutUpdateOnUnmounted(fiber, false);
          break;
      }
    }
    return;
  }
	
  // 此条件的意思是当前处理空闲阶段，没有render或者commit，并且下一次任务不为空，还有当前过期时间(优先级)高于下次的过期时间
  // 则清空队列
  // 例如上一个任务是异步任务（优先级很低，超时时间是 502ms），并且在上一个时间片（初始是 33ms）任务没有执行完，而且等待下一次requestIdleCallback的时候新的任务进来了，并且超时时间很短（52ms 或者 22ms 甚至是 Sync），那么优先级就变成了先执行当前任务，也就意味着上一个任务被打断了（interrupted）
  if (
    !isWorking &amp;amp;&amp;amp;
    nextRenderExpirationTime !== NoWork &amp;amp;&amp;amp;
    expirationTime &amp;gt; nextRenderExpirationTime
  ) {
    interruptedBy = fiber;
    resetStack();
  }
  // 记录所有子节点的任务时间区间
  markPendingPriorityLevel(root, expirationTime);
  // 要么处于没有 work 的状态，要么只能在 render 阶段，要么有两个不同的root
  if (
    !isWorking ||
    isCommitting ||
    nextRoot !== root
  ) {
    const rootExpirationTime = root.expirationTime;
    requestWork(root, rootExpirationTime);
  }
  if (nestedUpdateCount &amp;gt; NESTED_UPDATE_LIMIT) {
    // Reset this back to zero so subsequent updates don&#39;t throw.
    nestedUpdateCount = 0;
    invariant(
      false,
      &#39;Maximum update depth exceeded. This can happen when a &#39; +
        &#39;component repeatedly calls setState inside &#39; +
        &#39;componentWillUpdate or componentDidUpdate. React limits &#39; +
        &#39;the number of nested updates to prevent infinite loops.&#39;,
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先是调用&lt;code&gt;scheduleWorkToRoot&lt;/code&gt;，这个方法的主要是更新当前任务对应&lt;code&gt;Filber&lt;/code&gt;的到期时间&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function scheduleWorkToRoot(fiber: Fiber, expirationTime): FiberRoot | null {
  recordScheduleUpdate();

  if (__DEV__) {
    if (fiber.tag === ClassComponent) {
      const instance = fiber.stateNode;
      warnAboutInvalidUpdates(instance);
    }
  }

  // 如果filber上的过期时间小于当前的过期时间，更新
  if (fiber.expirationTime &amp;lt; expirationTime) {
    fiber.expirationTime = expirationTime;
  }
  let alternate = fiber.alternate;
  if (alternate !== null &amp;amp;&amp;amp; alternate.expirationTime &amp;lt; expirationTime) {
    alternate.expirationTime = expirationTime;
  }
  // fiber.return 返回当前fiber的父节点
  let node = fiber.return;
  let root = null;
  if (node === null &amp;amp;&amp;amp; fiber.tag === HostRoot) {
    // 如果filber.return的值为null，设置root的值为根节点(fiber.stateNode)
    root = fiber.stateNode;
  } else {
    // 循环向上遍历，更新每个子节点的过期时间
    // 如果子节点的过期时间小于当前过期时间，则更新
    while (node !== null) {
      alternate = node.alternate;
      if (node.childExpirationTime &amp;lt; expirationTime) {
        node.childExpirationTime = expirationTime;
        if (
          alternate !== null &amp;amp;&amp;amp;
          alternate.childExpirationTime &amp;lt; expirationTime
        ) {
          alternate.childExpirationTime = expirationTime;
        }
      } else if (
        alternate !== null &amp;amp;&amp;amp;
        alternate.childExpirationTime &amp;lt; expirationTime
      ) {
        alternate.childExpirationTime = expirationTime;
      }
      if (node.return === null &amp;amp;&amp;amp; node.tag === HostRoot) {
        root = node.stateNode;
        break;
      }
      node = node.return;
    }
  }
  ......
  return root;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;requestWork&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function requestWork(root: FiberRoot, expirationTime: ExpirationTime) {
  // 将root加入调度队列中，不会存在两个相同的 root 前后出现在队列中
  addRootToSchedule(root, expirationTime)
  if (isRendering) {
    return
  }

  if (isBatchingUpdates) {
    if (isUnbatchingUpdates) {
      nextFlushedRoot = root
      nextFlushedExpirationTime = Sync
      performWorkOnRoot(root, Sync, true)
    }
    return
  }

  // 根据expirationTime调用performSyncWork还是scheduleCallbackWithExpirationTime

  if (expirationTime === Sync) {
    performSyncWork()
  } else {
    // 异步调度，并且当前已经有异步任务，如果当前传入的任务优先级高，取消之前的调度，异步调度当前任务
    // 无异步任务，生成一个到期时间，调度
    scheduleCallbackWithExpirationTime(root, expirationTime)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;9-performwork&#34;&gt;9.performWork&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;performAsyncWork&lt;/code&gt; 为异步调用，一开始的&lt;code&gt;shouldYieldToRenderer&lt;/code&gt;代表是否当前调度中有没有时间执行异步任务，若&lt;code&gt;shouldYieldToRenderer&lt;/code&gt;返回&lt;code&gt;false&lt;/code&gt;，则代表有，那么重新计算当前的&lt;code&gt;expirationTime&lt;/code&gt;，更新所有的已过期的&lt;code&gt;root&lt;/code&gt;任务的&lt;code&gt;nextExpirationTimeToWorkOn&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;let didYield: boolean = false;
function shouldYieldToRenderer() {
  if (didYield) {
    return true;
  }
  if (shouldYield()) {
    didYield = true;
    return true;
  }
  return false;
}

function performAsyncWork() {
  try {
    if (!shouldYieldToRenderer()) {
      // 如果当前还有调度的链表
      if (firstScheduledRoot !== null) {
        // 重新计算当前的一个expirationTime
        recomputeCurrentRendererTime();
        let root: FiberRoot = firstScheduledRoot;
        do {
          // 设置所有的已过期的root任务的nextExpirationTimeToWorkOn为当前计算出的expirationTime
          didExpireAtExpirationTime(root, currentRendererTime);
          root = (root.nextScheduledRoot: any);
        } while (root !== firstScheduledRoot);
      }
    }
    performWork(NoWork, true);
  } finally {
    didYield = false;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;performSyncWork&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;同步调度任务，方法很简单，直接调用&lt;code&gt;performWork&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function performSyncWork() {
  performWork(Sync, false);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;performWork&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;此方法为真正的调度方法，首先会调用&lt;code&gt;findHighestPriorityRoot&lt;/code&gt;，找到当前队列优先级最高的&lt;code&gt;root&lt;/code&gt;任务，命名为&lt;code&gt;nextFlushedRoot&lt;/code&gt;，已经其对应的&lt;code&gt;expirationTime&lt;/code&gt;，命名为&lt;code&gt;nextFlushedExpirationTime&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function performWork(minExpirationTime: ExpirationTime, isYieldy: boolean) {
  findHighestPriorityRoot();

  if (isYieldy) {
    recomputeCurrentRendererTime();
    currentSchedulerTime = currentRendererTime;
		
    if (enableUserTimingAPI) {
      const didExpire = nextFlushedExpirationTime &amp;gt; currentRendererTime;
      const timeout = expirationTimeToMs(nextFlushedExpirationTime);
      stopRequestCallbackTimer(didExpire, timeout);
    }

    while (
      nextFlushedRoot !== null &amp;amp;&amp;amp;
      nextFlushedExpirationTime !== NoWork &amp;amp;&amp;amp;
      minExpirationTime &amp;lt;= nextFlushedExpirationTime &amp;amp;&amp;amp;
      !(didYield &amp;amp;&amp;amp; currentRendererTime &amp;gt; nextFlushedExpirationTime)
    ) {
      performWorkOnRoot(
        nextFlushedRoot,
        nextFlushedExpirationTime,
        currentRendererTime &amp;gt; nextFlushedExpirationTime,
      );
      findHighestPriorityRoot();
      recomputeCurrentRendererTime();
      currentSchedulerTime = currentRendererTime;
    }
  } else {
    while (
      nextFlushedRoot !== null &amp;amp;&amp;amp;
      nextFlushedExpirationTime !== NoWork &amp;amp;&amp;amp;
      minExpirationTime &amp;lt;= nextFlushedExpirationTime
    ) {
      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);
      findHighestPriorityRoot();
    }
  }
  if (isYieldy) {
    callbackExpirationTime = NoWork;
    callbackID = null;
  }
  if (nextFlushedExpirationTime !== NoWork) {
    scheduleCallbackWithExpirationTime(
      ((nextFlushedRoot: any): FiberRoot),
      nextFlushedExpirationTime,
    );
  }
  finishRendering();
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，不管同步异步，都有&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;while(
 nextFlushedRoot !== null &amp;amp;&amp;amp;
 nextFlushedExpirationTime !== NoWork &amp;amp;&amp;amp;
 minExpirationTime &amp;lt;= nextFlushedExpirationTime
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个循环调度&lt;code&gt;root&lt;/code&gt;任务的过程，判断条件为调度队列不为空，并且当前传入的任务优先级小于优先级最高的任务。异步调用时还有个额外的条件&lt;code&gt;!(didYield &amp;amp;&amp;amp; currentRendererTime &amp;gt; nextFlushedExpirationTime)&lt;/code&gt;，翻译过来就是当前传入的异步任务没过期，并且当前的渲染时间也没超过优先级最高的任务。然后这个循环就会在每次循环中调用&lt;code&gt;performWorkOnRoot&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;10-performworkonroot&#34;&gt;10.performWorkOnRoot&lt;/h2&gt;

&lt;p&gt;这里是整个调度过程的提交、render过程。不同的是，在异步任务中有个判断&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;if (!shouldYieldToRenderer()) {
  completeRoot(root, finishedWork, expirationTime);
} else {
  root.finishedWork = finishedWork;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;意思就是说如果当前没有时间处理异步任务，直接&lt;code&gt;completeRoot&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function performWorkOnRoot(
  root: FiberRoot,
  expirationTime: ExpirationTime,
  isYieldy: boolean,
) {
  invariant(
    !isRendering,
    &#39;performWorkOnRoot was called recursively. This error is likely caused &#39; +
      &#39;by a bug in React. Please file an issue.&#39;,
  );

  isRendering = true;

  if (!isYieldy) {

    let finishedWork = root.finishedWork;
    if (finishedWork !== null) {
      completeRoot(root, finishedWork, expirationTime);
    } else {
      root.finishedWork = null;
      const timeoutHandle = root.timeoutHandle;
      if (timeoutHandle !== noTimeout) {
        root.timeoutHandle = noTimeout;
        cancelTimeout(timeoutHandle);
      }
      renderRoot(root, isYieldy);
      finishedWork = root.finishedWork;
      if (finishedWork !== null) {
        completeRoot(root, finishedWork, expirationTime);
      }
    }
  } else {
    let finishedWork = root.finishedWork;
    if (finishedWork !== null) {
      completeRoot(root, finishedWork, expirationTime);
    } else {
      root.finishedWork = null;
      const timeoutHandle = root.timeoutHandle;
      if (timeoutHandle !== noTimeout) {
        root.timeoutHandle = noTimeout;
        cancelTimeout(timeoutHandle);
      }
      renderRoot(root, isYieldy);
      finishedWork = root.finishedWork;
      if (finishedWork !== null) {
        if (!shouldYieldToRenderer()) {
          completeRoot(root, finishedWork, expirationTime);
        } else {
          root.finishedWork = finishedWork;
        }
      }
    }
  }
  isRendering = false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;11-renderroot&#34;&gt;11.renderRoot&lt;/h2&gt;

&lt;p&gt;这个判断的意思就是如果当前没有其他的任务，那么就进行一些初始化的工作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;if (
    expirationTime !== nextRenderExpirationTime ||
    root !== nextRoot ||
    nextUnitOfWork === null
  ) {
    resetStack();
    nextRoot = root;
    nextRenderExpirationTime = expirationTime;
    nextUnitOfWork = createWorkInProgress(
      nextRoot.current,
      null,
      nextRenderExpirationTime,
    );
		root.pendingCommitExpirationTime = NoWork;
		......
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后调用&lt;code&gt;workLoop&lt;/code&gt;，对于异步任务，仍要判断是否有剩余时间处理此任务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;  do {
    try {
      workLoop(isYieldy);
    } catch (thrownValue) {
      
    }
    break;
  } while (true);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function workLoop(isYieldy) {
  if (!isYieldy) {
    while (nextUnitOfWork !== null) {
      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    }
  } else {
    while (nextUnitOfWork !== null &amp;amp;&amp;amp; !shouldYieldToRenderer()) {
      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果在这过程中会有报错，则停止调度，会在上面的&lt;code&gt;catch中&lt;/code&gt;处理，并且设置&lt;code&gt;finishedWork&lt;/code&gt;为&lt;code&gt;null&lt;/code&gt;，从而结束这一次的&lt;code&gt;render&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;performUnitOfWork&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function performUnitOfWork(workInProgress: Fiber): Fiber | null {
  const current = workInProgress.alternate;

  startWorkTimer(workInProgress);
  let next;
  ......
  if (enableProfilerTimer) {
    if (workInProgress.mode &amp;amp; ProfileMode) {
      startProfilerTimer(workInProgress);
    }

    next = beginWork(current, workInProgress, nextRenderExpirationTime);
    workInProgress.memoizedProps = workInProgress.pendingProps;

    if (workInProgress.mode &amp;amp; ProfileMode) {
      stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);
    }
  } else {
    next = beginWork(current, workInProgress, nextRenderExpirationTime);
    workInProgress.memoizedProps = workInProgress.pendingProps;
  }
  if (next === null) {
    next = completeUnitOfWork(workInProgress);
  }
	
  ......
  ReactCurrentOwner.current = null;

  return next;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先执行&lt;code&gt;next = beginWork(current, workInProgress, nextRenderExpirationTime)&lt;/code&gt;对节点进行操作，其内部会针对不同类型的节点进行创建，返回的结果即会赋值给&lt;code&gt;next&lt;/code&gt;，&lt;code&gt;return next&lt;/code&gt;。 如果&lt;code&gt;next === null&lt;/code&gt;，说明子节点已经处理完，调用&lt;code&gt;next = completeUnitOfWork(workInProgress)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;completeUnitOfWork&lt;/code&gt;会从下往上遍历，处理&lt;code&gt;effact tag&lt;/code&gt;，如果到&lt;code&gt;root&lt;/code&gt;节点返回的是&lt;code&gt;null&lt;/code&gt;，代表整棵树的遍历已经结束了，如果找到了其他兄弟节点，就返回这个节点，重新走一遍&lt;code&gt;workLoop&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;12-updateclasscomponent&#34;&gt;12.updateClassComponent&lt;/h2&gt;

&lt;p&gt;在&lt;code&gt;beginWork&lt;/code&gt;中，会针对不同的节点类型来调用不同的方法处理，这里以&lt;code&gt;ClassComponent&lt;/code&gt;为例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function updateClassComponent(
  current: Fiber | null,
  workInProgress: Fiber,
  Component: any,
  nextProps,
  renderExpirationTime: ExpirationTime,
) {
	......
  // 对context进行处理
  let hasContext;
  // 如果当前组件是context provider
  // 设置hasContext标记
  if (isLegacyContextProvider(Component)) {
    hasContext = true;
    pushLegacyContextProvider(workInProgress);
  } else {
    hasContext = false;
  }
  prepareToReadContext(workInProgress, renderExpirationTime);

  const instance = workInProgress.stateNode;
  let shouldUpdate;
  // 如果实例为空
  if (instance === null) {
    if (current !== null) {
      current.alternate = null;
      workInProgress.alternate = null;
      workInProgress.effectTag |= Placement;
    }
    constructClassInstance(
      workInProgress,
      Component,
      nextProps,
      renderExpirationTime,
    );
    // 挂载这个实例
    mountClassInstance(
      workInProgress,
      Component,
      nextProps,
      renderExpirationTime,
    );
    shouldUpdate = true;
  } else if (current === null) {
    // 第一次渲染时，current为null
    // 重新挂载实例
    shouldUpdate = resumeMountClassInstance(
      workInProgress,
      Component,
      nextProps,
      renderExpirationTime,
    );
  } else {
    // 更新类组件的时候
    // 调用updateClassInstance
    shouldUpdate = updateClassInstance(
      current,
      workInProgress,
      Component,
      nextProps,
      renderExpirationTime,
    );
  }
  ......
  // 调用finishClassComponent
  // 如果需要更新，调用reconcileChildren，返回更新后的workInProgress
  const nextUnitOfWork = finishClassComponent(
    current,
    workInProgress,
    Component,
    shouldUpdate,
    hasContext,
    renderExpirationTime,
  );
  return nextUnitOfWork;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;constructClassInstance&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function constructClassInstance(
  workInProgress: Fiber,
  ctor: any,
  props: any,
  renderExpirationTime: ExpirationTime,
): any {
  .......
  adoptClassInstance(workInProgress, instance);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;adoptClassInstance&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function adoptClassInstance(workInProgress: Fiber, instance: any): void {
  instance.updater = classComponentUpdater;
  workInProgress.stateNode = instance;
  setInstance(instance, workInProgress);
	......
}
  
const classComponentUpdater = {
  isMounted,
  enqueueSetState(inst, payload, callback) {
  },
  enqueueReplaceState(inst, payload, callback) {
  },
  enqueueForceUpdate(inst, callback) {
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;classComponentUpdater&lt;/code&gt;里面几个方法，即对应着&lt;code&gt;setState&lt;/code&gt;、&lt;code&gt;replaceState&lt;/code&gt;、&lt;code&gt;forceUpdate&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mountClassInstance&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function mountClassInstance(
  workInProgress: Fiber,
  ctor: any,
  newProps: any,
  renderExpirationTime: ExpirationTime,
): void {
  if (__DEV__) {
    checkClassInstance(workInProgress, ctor, newProps);
  }

  const instance = workInProgress.stateNode;
  // 初始化 props、state 等实例属性
  instance.props = newProps;
  instance.state = workInProgress.memoizedState;
  instance.refs = emptyRefsObject;

  const contextType = ctor.contextType;
  if (typeof contextType === &#39;object&#39; &amp;amp;&amp;amp; contextType !== null) {
    instance.context = readContext(contextType);
  } else {
    const unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
    instance.context = getMaskedContext(workInProgress, unmaskedContext);
  }
	.......
	// 如果有updateQueue就更新
  let updateQueue = workInProgress.updateQueue;
  if (updateQueue !== null) {
    processUpdateQueue(
      workInProgress,
      updateQueue,
      newProps,
      instance,
      renderExpirationTime,
    );
    instance.state = workInProgress.memoizedState;
  }
	
	// 如果定义了getDerivedStateFromProps周期函数，则调用
  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  if (typeof getDerivedStateFromProps === &#39;function&#39;) {
    applyDerivedStateFromProps(
      workInProgress,
      ctor,
      getDerivedStateFromProps,
      newProps,
    );
    instance.state = workInProgress.memoizedState;
  }

  if (
    typeof ctor.getDerivedStateFromProps !== &#39;function&#39; &amp;amp;&amp;amp;
    typeof instance.getSnapshotBeforeUpdate !== &#39;function&#39; &amp;amp;&amp;amp;
    (typeof instance.UNSAFE_componentWillMount === &#39;function&#39; ||
      typeof instance.componentWillMount === &#39;function&#39;)
  ) {
    callComponentWillMount(workInProgress, instance);
    updateQueue = workInProgress.updateQueue;
    if (updateQueue !== null) {
      processUpdateQueue(
        workInProgress,
        updateQueue,
        newProps,
        instance,
        renderExpirationTime,
      );
      instance.state = workInProgress.memoizedState;
    }
  }

  // 判断是否有componentDidMount，
	// componentDidMount要在真正渲染进DOM之后才调用，也就是commit之后
  if (typeof instance.componentDidMount === &#39;function&#39;) {
    workInProgress.effectTag |= Update;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;13-commitroot&#34;&gt;13.commitRoot&lt;/h2&gt;

&lt;p&gt;调用完&lt;code&gt;renderRoot&lt;/code&gt;之后，&lt;code&gt;fiber&lt;/code&gt;中对应的每个节点都执行了&lt;code&gt;render&lt;/code&gt;之前所有的生命周期函数，并创建了对应的DOM元素，放在&lt;code&gt;workInProgress.stateNode&lt;/code&gt;中。然后调用&lt;code&gt;commitRoot&lt;/code&gt;，提交子树中优先级最高的任务，更新DOM元素的属性后，挂载组件，调用&lt;code&gt;componentDidMount&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;参考链接&#34;&gt;参考链接&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://react.jokcy.me/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;react源码解析&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Flutter各种踩坑心得</title>
      <link>https://xtid.github.io/2020/flutter%E5%90%84%E7%A7%8D%E8%B8%A9%E5%9D%91%E5%BF%83%E5%BE%97/</link>
      <pubDate>Sat, 05 Dec 2020 16:06:56 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/flutter%E5%90%84%E7%A7%8D%E8%B8%A9%E5%9D%91%E5%BF%83%E5%BE%97/</guid>
      <description>

&lt;h2 id=&#34;1-安卓开发环境的基本配置&#34;&gt;1.安卓开发环境的基本配置&lt;/h2&gt;

&lt;p&gt;首先修改你创建的项目中的&lt;code&gt;/android/build.gradle&lt;/code&gt;文件，修改&lt;code&gt;buildscript&lt;/code&gt;以及&lt;code&gt;allprojects&lt;/code&gt;的仓库地址，否则编译打包会卡住不动，其次就是&lt;code&gt;package get&lt;/code&gt;会卡住，原因是因为连接不上谷歌的服务，有点蛋疼&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;buildscript {
    repositories {
        // google()
        // jcenter()
        maven { url &#39;https://maven.aliyun.com/repository/google&#39; }
        maven { url &#39;https://maven.aliyun.com/repository/jcenter&#39; }
        maven { url &#39;https://maven.aliyun.com/nexus/content/groups/public&#39; }
    }
}

allprojects {
    repositories {
        // google()
        // jcenter()
        maven { url &#39;https://maven.aliyun.com/repository/google&#39; }
        maven { url &#39;https://maven.aliyun.com/repository/jcenter&#39; }
        maven { url &#39;https://maven.aliyun.com/nexus/content/groups/public&#39; }
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-signlechildscrollview页面不满一屏无法撑满全屏&#34;&gt;2.SignleChildScrollView页面不满一屏无法撑满全屏&lt;/h2&gt;

&lt;p&gt;可以换个布局组件或者将其设置为&lt;code&gt;Container&lt;/code&gt;子组件，设置&lt;code&gt;alignment&lt;/code&gt;，如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;Container(
  alignment: Alignment.topLeft,
  child: SingleChildScrollView(),
),
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-自定义appbar&#34;&gt;3.自定义AppBar&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;AppBar&lt;/code&gt;这个组件可拓展性还是比较低的，尤其是它的高度都是写死的，这种情况可以换&lt;code&gt;SliverAppBar&lt;/code&gt;或者自定义&lt;code&gt;AppBar&lt;/code&gt;，换句话说自定义组件，这里就不详诉&lt;/p&gt;

&lt;h2 id=&#34;4-push页面返回-保持上一次的页面位置状态&#34;&gt;4.push页面返回，保持上一次的页面位置状态&lt;/h2&gt;

&lt;p&gt;使用 &lt;code&gt;StatefulWidget&lt;/code&gt; 混入 &lt;code&gt;AutomaticKeepAliveClientMixin&lt;/code&gt;，覆盖&lt;code&gt;wantKeepAlive&lt;/code&gt;属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class TesPage extends StatefulWidget {
  @override
  createState() =&amp;gt; TesPageState();
}

class TesPageState extends State&amp;lt;TesPage&amp;gt; with AutomaticKeepAliveClientMixin {
  
  @override
  bool get wantKeepAlive =&amp;gt; true;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-路由跳转方式的选择&#34;&gt;5.路由跳转方式的选择&lt;/h2&gt;

&lt;p&gt;通常路由跳转会用到&lt;code&gt;Navigator.push&lt;/code&gt;推入路由栈，&lt;code&gt;Navigator.pop&lt;/code&gt;就移出、返回上一个的状态。如果在页面上全部用这两个方法，你会发现你的页面间的跳转仿佛乱了一样，原因就是&lt;code&gt;Navigator.push&lt;/code&gt;是每次将你的路由推入栈，也就是你可以一直做返回操作、手势来获取之前的页面状态。这个时候就要考虑用其他方式，如&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pushAndRemoveUntil&lt;/code&gt;：跳转到指定路由，删除先前的路由栈
&lt;code&gt;pushNamed&lt;/code&gt;：跳转到指定命名路由，路由栈不会删除。这种方式需要配合命名路由使用，即在入口文件&lt;code&gt;MaterialApp&lt;/code&gt;配置好&lt;code&gt;routes&lt;/code&gt;
&lt;code&gt;pushNamedAndRemoveUntil&lt;/code&gt;：跳转到指定路由，删除先前的路由栈
&lt;code&gt;pushReplacement&lt;/code&gt;：路由替换
&lt;code&gt;pushReplacementNamed&lt;/code&gt;：跳转到指定命名路由，并删除最后的路由&lt;/p&gt;

&lt;h2 id=&#34;6-页面初始化时拿到context&#34;&gt;6.页面初始化时拿到context&lt;/h2&gt;

&lt;p&gt;有时候，可能会在页面初始化使用&lt;code&gt;context&lt;/code&gt;，比如说路由相关的&lt;code&gt;Navigator.of(context)&lt;/code&gt;。解决方法很简单，在&lt;code&gt;initState&lt;/code&gt;方法中，&lt;code&gt;this&lt;/code&gt;指向上下文，即使用&lt;code&gt;this.context&lt;/code&gt;即可以保存页面初始的&lt;code&gt;context&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;7-键盘弹出时将布局打乱-或者说将元素顶起来了&#34;&gt;7.键盘弹出时将布局打乱，或者说将元素顶起来了&lt;/h2&gt;

&lt;p&gt;在 &lt;code&gt;Scafold&lt;/code&gt; 里设置 &lt;code&gt;resizeToAvoidBottomInset: false&lt;/code&gt;，键盘会遮住布局，而不是顶起布局。&lt;/p&gt;

&lt;h2 id=&#34;8-无法设置虚线边框&#34;&gt;8.无法设置虚线边框&lt;/h2&gt;

&lt;p&gt;说实话当时发现&lt;code&gt;Flutter&lt;/code&gt;无法设置虚线边框的时候我是很震惊的，我感觉这算是基本的不能在基本的属性了，解决方法，参考官方&lt;code&gt;issues&lt;/code&gt;中大佬的解法，目前只能自己实现&lt;code&gt;paint&lt;/code&gt;方法，自己用&lt;code&gt;Canvas&lt;/code&gt;画&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;import &#39;package:flutter/material.dart&#39;;
import &#39;package:path_drawing/path_drawing.dart&#39;;

void main() =&amp;gt; runApp(MyApp());

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: &#39;Flutter Demo&#39;,
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: MyHomePage(title: &#39;Flutter Demo Home Page&#39;),
    );
  }
}

class MyHomePage extends StatefulWidget {
  MyHomePage({Key key, this.title}) : super(key: key);
  final String title;

  @override
  _MyHomePageState createState() =&amp;gt; _MyHomePageState();
}

class _MyHomePageState extends State&amp;lt;MyHomePage&amp;gt; {
  int _counter = 0;

  void _incrementCounter() {
    setState(() {
      _counter++;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: &amp;lt;Widget&amp;gt;[
            Container(
              decoration: BoxDecoration(
                border: DashPathBorder.all(
                  dashArray: CircularIntervalList&amp;lt;double&amp;gt;(&amp;lt;double&amp;gt;[5.0, 2.5]),
                ),
              ),
              padding: const EdgeInsets.all(20.0),
              child: const Text(&#39;You have pushed the button this many times:&#39;),
            ),
            Text(
              &#39;$_counter&#39;,
              style: Theme.of(context).textTheme.display1,
            ),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _incrementCounter,
        tooltip: &#39;Increment&#39;,
        child: Icon(Icons.add),
      ),
    );
  }
}

class DashPathBorder extends Border {
  DashPathBorder({
    @required this.dashArray,
    BorderSide top = BorderSide.none,
    BorderSide left = BorderSide.none,
    BorderSide right = BorderSide.none,
    BorderSide bottom = BorderSide.none,
  }) : super(
          top: top,
          left: left,
          right: right,
          bottom: bottom,
        );

  factory DashPathBorder.all({
    BorderSide borderSide = const BorderSide(),
    @required CircularIntervalList&amp;lt;double&amp;gt; dashArray,
  }) {
    return DashPathBorder(
      dashArray: dashArray,
      top: borderSide,
      right: borderSide,
      left: borderSide,
      bottom: borderSide,
    );
  }
  final CircularIntervalList&amp;lt;double&amp;gt; dashArray;

  @override
  void paint(
    Canvas canvas,
    Rect rect, {
    TextDirection textDirection,
    BoxShape shape = BoxShape.rectangle,
    BorderRadius borderRadius,
  }) {
    if (isUniform) {
      switch (top.style) {
        case BorderStyle.none:
          return;
        case BorderStyle.solid:
          switch (shape) {
            case BoxShape.circle:
              assert(borderRadius == null,
                  &#39;A borderRadius can only be given for rectangular boxes.&#39;);
              canvas.drawPath(
                dashPath(Path()..addOval(rect), dashArray: dashArray),
                top.toPaint(),
              );
              break;
            case BoxShape.rectangle:
              if (borderRadius != null) {
                final RRect rrect =
                    RRect.fromRectAndRadius(rect, borderRadius.topLeft);
                canvas.drawPath(
                  dashPath(Path()..addRRect(rrect), dashArray: dashArray),
                  top.toPaint(),
                );
                return;
              }
              canvas.drawPath(
                dashPath(Path()..addRect(rect), dashArray: dashArray),
                top.toPaint(),
              );

              break;
          }
          return;
      }
    }

    assert(borderRadius == null,
        &#39;A borderRadius can only be given for uniform borders.&#39;);
    assert(shape == BoxShape.rectangle,
        &#39;A border can only be drawn as a circle if it is uniform.&#39;);

    // TODO(dnfield): implement when borders are not uniform.
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;9-使用dio时-设置相应数据的媒体类型&#34;&gt;9.使用Dio时，设置相应数据的媒体类型&lt;/h2&gt;

&lt;p&gt;使用&lt;code&gt;Dio&lt;/code&gt;封装网络请求，普通的请求最好设置相应类型&lt;code&gt;dio.options.responseType = ResponseType.json&lt;/code&gt;，否则可能接收到的响应可能是字符串。&lt;/p&gt;

&lt;h2 id=&#34;10-build配置&#34;&gt;10.build配置&lt;/h2&gt;

&lt;h4 id=&#34;1-安卓的sha1码获取方式&#34;&gt;1.安卓的SHA1码获取方式&lt;/h4&gt;

&lt;p&gt;很多第三方应用都需要用到安卓的SHA1码，在&lt;code&gt;Flutter&lt;/code&gt;应用中，首先用&lt;code&gt;Andriod Studio&lt;/code&gt;打开项目，随意选择一个文件，点击右上角&lt;code&gt;Open for Editing in Android Studio&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/12/05/KrYUhiXpHu3cLBs.png&#34; alt=&#34;1.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;打开&lt;code&gt;Terminal&lt;/code&gt;，输入&lt;code&gt;gradlew signingReport&lt;/code&gt;，mac环境需要指定当前目录&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/12/05/BxEfHGOAtQcLSn7.png&#34; alt=&#34;2.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后控制台会打印出应用的各种签名信息，复制&lt;code&gt;SHA1&lt;/code&gt;码即可&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/12/05/6cKCEUzuBRS5Ohw.jpg&#34; alt=&#34;3.jpg&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-安卓打包-release-配置&#34;&gt;2.安卓打包&lt;code&gt;release&lt;/code&gt;配置&lt;/h4&gt;

&lt;p&gt;首先打开&lt;code&gt;/android/build.gradle&lt;/code&gt;文件，在&lt;code&gt;buildscript&lt;/code&gt;中指定&lt;code&gt;kotlin_version&lt;/code&gt;，否则&lt;code&gt;debug&lt;/code&gt;、&lt;code&gt;release&lt;/code&gt;编译会不通过&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;buildscript {
    ext.kotlin_version = &#39;1.3.50&#39;
    repositories {
        // google()
        // jcenter()
        maven { url &#39;https://maven.aliyun.com/repository/google&#39; }
        maven { url &#39;https://maven.aliyun.com/repository/jcenter&#39; }
        maven { url &#39;https://maven.aliyun.com/nexus/content/groups/public&#39; }
    }

    dependencies {
        classpath &#39;com.android.tools.build:gradle:3.5.0&#39;
        classpath &amp;quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后生成&lt;code&gt;key&lt;/code&gt;，同样打开&lt;code&gt;Andriod Studio&lt;/code&gt;，打开&lt;code&gt;Terminal&lt;/code&gt;，输入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;keytool -genkey -v -keystore ~/key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成过程中会让你输入存储密码和文件密码，生成完&lt;code&gt;key&lt;/code&gt;后记住文件地址&lt;/p&gt;

&lt;p&gt;然后在在&lt;code&gt;android&lt;/code&gt;目录中创建一个文件，文件名为：&lt;code&gt;key.properties&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/12/05/MuVAtUaI3TojQi6.jpg&#34; alt=&#34;05D6800C-27E4-4550-A7CD-88C691BC8202.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;添加内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;storePassword = // 和生成key输入的存储密码一致
keyPassword = // 和生成key输入的密码一致
keyAlias = key // 
storeFile = // key文件的存储路径
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;找到&lt;code&gt;android/app/build.gradle&lt;/code&gt;文件，添加签名配置&lt;code&gt;singingConfig&lt;/code&gt;以及打包配置&lt;code&gt;buildTypes&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;android {
		.....
    signingConfigs {
        release {
            keyAlias keystoreProperties[&#39;keyAlias&#39;]
            keyPassword keystoreProperties[&#39;keyPassword&#39;]
            storeFile file(keystoreProperties[&#39;storeFile&#39;])
            storePassword keystoreProperties[&#39;storePassword&#39;]
        }
    }

    buildTypes {
        release {
            signingConfig signingConfigs.release
            ndk {
                abiFilters &#39;armeabi-v7a&#39;,&#39;x86&#39; // 指定打包平台
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后进入项目根目录，执行&lt;code&gt;flutter build apk&lt;/code&gt;，即可以打包一个安卓apk包&lt;/p&gt;

&lt;h4 id=&#34;3-ios调试打包注意事项&#34;&gt;3.iOS调试打包注意事项&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;iOS&lt;/code&gt;模拟器调试体验比安卓好的多，但是真机调试，首先你得有个苹果ID，然后用&lt;code&gt;Xcode&lt;/code&gt;打开项目，点击&lt;code&gt;Signing &amp;amp; Capabilities&lt;/code&gt;，找到&lt;code&gt;Team&lt;/code&gt;设置，设置一个开发账号，可以是未付费注册的苹果ID，设置好开发者证书&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/12/05/IM1z4KEkUxPFAvl.jpg&#34; alt=&#34;4.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后&lt;code&gt;flutter run&lt;/code&gt;的时候，选择一个真机设备，即可在真机上调试&lt;code&gt;app&lt;/code&gt;了，但是未付费注册的苹果ID证书有效期只有七天，七天后你手机上的&lt;code&gt;app&lt;/code&gt;就不可用了。&lt;/p&gt;

&lt;p&gt;未付费注册的账号也无法打包上传&lt;code&gt;App Store&lt;/code&gt;，不过配置完了开发团队、账号后、开发证书后，可以直接&lt;code&gt;flutter build ios&lt;/code&gt;，这样会生成一个文件。这时候创建一个名为&lt;code&gt;Payload&lt;/code&gt;的文件夹，将打包生成的文件放进去、压缩，然后将压缩文件后缀改为&lt;code&gt;ipa&lt;/code&gt;，即可以生成一个&lt;code&gt;ipa&lt;/code&gt;文件了。然后借助第三方工具，如&lt;code&gt;itunes(貌似已经不能用)、xxx助手&lt;/code&gt;即可将这个文件安装在终端上运行。&lt;/p&gt;

&lt;h4 id=&#34;11-总结&#34;&gt;11.总结&lt;/h4&gt;

&lt;p&gt;断断续续做这个小项目已经有几个月了，因为平常很忙，所以拖了这么久。&lt;code&gt;Flutter&lt;/code&gt;给我的感觉优点就是流程、动画较为细腻，相对于其它跨平台方案，使用&lt;code&gt;JsBrigde&lt;/code&gt;与&lt;code&gt;native&lt;/code&gt;端通信，有较大的优势，毕竟它是自己的引擎绘制的页面。但是它的官方组件太少，自定义组件所需精力较多(可能是我不熟悉)，&lt;code&gt;iOS&lt;/code&gt;风格组件虽然样式和原生的差不多，但具体效果还是有差距。这种跨平台框架终于还是得要和原生开发人员一起操作才玩的溜。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Flutter自定义组件</title>
      <link>https://xtid.github.io/2020/flutter%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Sat, 28 Nov 2020 16:23:05 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/flutter%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/</guid>
      <description>

&lt;h3 id=&#34;简言&#34;&gt;简言&lt;/h3&gt;

&lt;p&gt;在使用&lt;code&gt;Flutter&lt;/code&gt;开发app的时候，是使用各种各样的&lt;code&gt;Widget&lt;/code&gt; 组合绘制出的页面，一些最基础的如&lt;code&gt;Container&lt;/code&gt;、&lt;code&gt;Padding&lt;/code&gt;、&lt;code&gt;Text&lt;/code&gt; 等等，由官方封装好的比较复杂的组件如&lt;code&gt;AppBar&lt;/code&gt;、&lt;code&gt;日历选择器&lt;/code&gt;等等。仅仅使用这些组件也确实能写出一些app，但是官方封装好的拓展性我觉得不太好，有些属性根本无法改变；另外一旦和设计稿出入比较大，那根不就玩不了了，所以这就涉及到自定义组件。&lt;code&gt;Flutter&lt;/code&gt;自定义组件的方式我了解到有三种，一是通过组合其它组件来达到你想要的效果；二是自绘，这块牵扯到&lt;code&gt;Canvas&lt;/code&gt;；三是实现&lt;code&gt;RenderObject&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;1-原理基本介绍&#34;&gt;1.原理基本介绍&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Flutter&lt;/code&gt;引擎会将我们所写组件生成一个&lt;code&gt;Widget Tree&lt;/code&gt;，而实际渲染出来的结果又有一个&lt;code&gt;RenderObject Tree&lt;/code&gt;，&lt;code&gt;RenderObject&lt;/code&gt;是继承&lt;code&gt;Widget&lt;/code&gt;的。在项目运行中`&lt;code&gt;Widget Tree&lt;/code&gt;是不断变化的，如果每次变化都要导致整个&lt;code&gt;RenderObject Tree&lt;/code&gt;变化，这对性能来说是一个很大的消耗，于是就有了一个&lt;code&gt;Element Trre&lt;/code&gt;，这就相当于一个中间层，由&lt;code&gt;Widget&lt;/code&gt;→&lt;code&gt;Elment&lt;/code&gt;→&lt;code&gt;RenderObject&lt;/code&gt;。每次&lt;code&gt;Widget&lt;/code&gt;变化时，与&lt;code&gt;Element&lt;/code&gt;做对比，找出最小最优的变化，作用于&lt;code&gt;RenderObject&lt;/code&gt;。我们创建的&lt;code&gt;Widget&lt;/code&gt;基本继承于&lt;code&gt;StatelessWidget&lt;/code&gt;、&lt;code&gt;StatefulWidget&lt;/code&gt;，他们仅负责属性、生命周期等的管理，最终也还是会继承于&lt;code&gt;RenderObjectWidget&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RenderObjectWidget&lt;/code&gt;下面又有三个子类&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SngleChildRenderObjectWidget&lt;/code&gt;：&lt;code&gt;RenderObject&lt;/code&gt;只有一个 &lt;code&gt;child&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MultiChildRenderObjectWidget&lt;/code&gt;：可以有多个 &lt;code&gt;child&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LeafRenderObjectWidget&lt;/code&gt; ：&lt;code&gt;RenderObject&lt;/code&gt;是一个叶子节点，没有&lt;code&gt;child&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;官方所提供的组件很多都是继承&lt;code&gt;singleChildRenderObjectWidget&lt;/code&gt;，所以我们通常只能传一个&lt;code&gt;child&lt;/code&gt;，找到&lt;code&gt;singleChildRenderObjectWidget&lt;/code&gt;定义&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;abstract class SingleChildRenderObjectWidget extends RenderObjectWidget {
  const SingleChildRenderObjectWidget({ Key key, this.child }) : super(key: key);
  final Widget child;

  @override
  SingleChildRenderObjectElement createElement() =&amp;gt; SingleChildRenderObjectElement(this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到每次创建一个&lt;code&gt;SingleChildRenderObjectWidget&lt;/code&gt;就会调用`&lt;code&gt;CreateElement&lt;/code&gt;生成一个对应的&lt;code&gt;Elment&lt;/code&gt;，当然&lt;code&gt;MultiChildRenderObjectWidget&lt;/code&gt;也是类似，这也就说明了他们一对一的关系。所以我们实现自定义组件必须得继承&lt;code&gt;SingleChildRenderObjectWidget&lt;/code&gt;或者&lt;code&gt;MultiChildRenderObjectWidget&lt;/code&gt;或者调用官方实现好的自绘类，这也是&lt;code&gt;Flutter&lt;/code&gt;引擎渲染的基本结构。&lt;/p&gt;

&lt;h4 id=&#34;2-组合其它组件&#34;&gt;2..组合其它组件&lt;/h4&gt;

&lt;p&gt;这种方式是最基本最简单的方式，说白了就是将一些原有的、封装好的组件合并再封装一次。&lt;code&gt;Flutter&lt;/code&gt;本身就有很多组合组件，比如常用的&lt;code&gt;Container&lt;/code&gt;，查看它的源码就知道，它是由&lt;code&gt;DecoratedBox&lt;/code&gt;、&lt;code&gt;ConstrainedBox&lt;/code&gt;、&lt;code&gt;Transform&lt;/code&gt;、&lt;code&gt;Padding&lt;/code&gt;、&lt;code&gt;Align&lt;/code&gt;等组件组成，其内部做了很多判断处理。这里实现一个自定义宽度的&lt;code&gt;drawer&lt;/code&gt;组件，创建一个类&lt;code&gt;SmartDrawer&lt;/code&gt;继承&lt;code&gt;StatelessWidget&lt;/code&gt;，并实现其具体方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class SmartDrawer extends StatelessWidget {
  final double elevation;
  final Widget child;
  final String semanticLabel;
  final double widthPercent;
  const SmartDrawer({
    Key key,
    this.elevation = 16.0,
    this.child,
    this.semanticLabel,
    this.widthPercent = 0.7,
  }) : 
   assert(widthPercent != null &amp;amp;&amp;amp; widthPercent &amp;lt; 1.0 &amp;amp;&amp;amp; widthPercent&amp;gt; 0.0)
   ,super(key: key);

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasMaterialLocalizations(context));
    String label = semanticLabel;
    final double _width = MediaQuery.of(context).size.width * widthPercent;
    
    return Semantics(
      scopesRoute: true,
      namesRoute: true,
      explicitChildNodes: true,
      label: label,
      child: ConstrainedBox(
        constraints: BoxConstraints.expand(width: _width),
        child: Material(
          elevation: elevation,
          child: child,
        ),
      ),
    );
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，上述组件就是将&lt;code&gt;ConstrainedBox&lt;/code&gt;以及传入的&lt;code&gt;child&lt;/code&gt;组合成一个新的组件，其他属性则是来控制样式的。这里需要特别说明的，最后返回的&lt;code&gt;Semantics&lt;/code&gt;，它继承&lt;code&gt;SingleChildRenderObjectWidget&lt;/code&gt;，它上面定义的属性有点带有语义化的意思，而它上面定义的&lt;code&gt;child&lt;/code&gt;属性则是返回的组件，这样&lt;code&gt;return Semantices{}&lt;/code&gt;实际就表示返回了带有一些语义的组件。&lt;/p&gt;

&lt;h4 id=&#34;4-自绘组件&#34;&gt;4.自绘组件&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Flutter&lt;/code&gt;跨平台的实现方式就是在不同操作系统的上层绘制一个中间的UI系统，对不同的操作系统的&lt;code&gt;API&lt;/code&gt;进行适配，风格统一，这样就能实现一个跨平台应用了，这也是和&lt;code&gt;React Native&lt;/code&gt;的最大的差异以及优于&lt;code&gt;React Native&lt;/code&gt;的地方。当你无法用现有的组件来描绘你所需要UI时，可以考虑使用自绘组件来实现。下面是一个自绘的验证码组件示例&lt;/p&gt;

&lt;p&gt;首先创建一个名为&lt;code&gt;CodeReview&lt;/code&gt;的&lt;code&gt;StatefulWidget&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class CodeReview extends StatefulWidget {

  final String text;
  final callback;

  CodeReview({Key key, this.text, this.callback}) : super(key: key);

  _CodeReviewState createState() =&amp;gt; _CodeReviewState();

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后实现具体代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class _CodeReviewState extends State&amp;lt;CodeReview&amp;gt; {
	
  // 存放每个验证码字符上的横线的位置
  List&amp;lt;Offset&amp;gt; _lineOffsets = &amp;lt;Offset&amp;gt;[];

  // 验证码的长度，由外部传入
  int _textLength;
  // 验证码宽度
  double _width;
  // 验证码高度
  double _height;

  // 生成验证码上的横线遮挡物的位置
  void _randLines() {
    _lineOffsets.clear();
    for (var i = 0; i &amp;lt; _textLength; i++) {
      double fromX = randomBetween(10, 20).toDouble();
      double fromY = randomBetween(3, 33).toDouble();
      Offset from = Offset(fromX, fromY);
      _lineOffsets.add(from);

      double endX = randomBetween(60, _width.toInt() - 10).toDouble();
      double endY = randomBetween(3, 33).toDouble();
      Offset end = Offset(endX, endY);
      _lineOffsets.add(end);
    }
  }

  @override
  void initState() {
    super.initState();
    _textLength = widget.text.length ?? 4;
    _width = _textLength.toDouble() * 22;
    _height = 36;
    _randLines();
  }

  void _changeCode() {
    setState(() {
      _randLines();
    });
  }
	
  // 对每个字符进行随机rotate操作
  Container _subString(index) {
    return Container(
      padding: EdgeInsets.only(left: 2, right: 2, top: randomBetween(0, 14).toDouble()),
      child: Transform.rotate(
        angle: pi / randomBetween(3, 30) * randomBetween(0, 1),
        child: Text(widget.text[index], style: TextStyle(fontSize: randomBetween(20, 22).toDouble(), color: Color(0xFF4abdcc))),
      ),
    );
  }
	
 	// 描绘验证码上横线遮挡物
  Container _backLines() {
    return Container(
      width: _width,
      height: _height,
      child: CustomPaint(
        painter: CodePaint(_lineOffsets, Tool.randomColor()),
        foregroundPainter: CodePaint(_lineOffsets, Tool.randomColor()),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      width: _width,
      height: _height,
      color: Colors.grey[200],
      child: Stack(
        alignment: Alignment.center,
        children: &amp;lt;Widget&amp;gt;[
          _backLines(),
          _backLines(),
          GestureDetector(
            behavior: HitTestBehavior.opaque,
            onTap: () {
              _changeCode();
              widget.callback();
            },
            child: Container(
              width: _width,
              height: _height,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: List.generate(_textLength, (int index) {
                  return _subString(index);
                }),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到上面用到了&lt;code&gt;CustomPaint&lt;/code&gt;，这个类继承&lt;code&gt;SingleChildRenderObjectWidget&lt;/code&gt;，这让我们直接能使用&lt;code&gt;Canvas&lt;/code&gt;来绘制你所需要的UI&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class CustomPaint extends SingleChildRenderObjectWidget {
  /// Creates a widget that delegates its painting.
  const CustomPaint({
    Key key,
    this.painter,
    this.foregroundPainter,
    this.size = Size.zero,
    this.isComplex = false,
    this.willChange = false,
    Widget child,
  })......
    ......
    ......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传入&lt;code&gt;painter&lt;/code&gt; 、&lt;code&gt;foregroundPainter&lt;/code&gt;对应类，在上述代码中，是创建一个类的&lt;code&gt;CodePaint&lt;/code&gt;继承&lt;code&gt;CustomPainer&lt;/code&gt;，重写&lt;code&gt;paint&lt;/code&gt;方法，然后设置画笔的属性，最后调用对应的&lt;code&gt;Canvas&lt;/code&gt;api即可，这里使用的是&lt;code&gt;drawPoints&lt;/code&gt;，还有其他的，如&lt;code&gt;drawCircle&lt;/code&gt;、&lt;code&gt;drawLine&lt;/code&gt;等等。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class CodePaint extends CustomPainter {
  final List&amp;lt;Offset&amp;gt; lineOffsets;
  final Color ranColor;
  CodePaint(this.lineOffsets, this.ranColor);

  @override
  void paint(Canvas canvas, Size size) {
    // debugPrint(canvas.runtimeType.toString());
    canvas.save();
    Paint _paint = Paint()
      ..color = ranColor // 画笔颜色
      ..strokeCap = StrokeCap.round // 画笔笔触类型
      ..isAntiAlias = true // 是否启动抗锯齿
      ..blendMode = BlendMode.exclusion // 颜色混合模式
      ..style = PaintingStyle.fill // 绘画风格，默认为填充
      ..colorFilter = ColorFilter.mode(ranColor, BlendMode.exclusion) // 颜色渲染模式，一般是矩阵效果来改变的,但是flutter中只能使用颜色混合模式
      ..maskFilter = MaskFilter.blur(BlurStyle.inner, 1.0) // 模糊遮罩效果
      ..filterQuality = FilterQuality.high // 颜色渲染模式的质量
      // ..strokeWidth = randomBetween(1, 3).toDouble(); // 暂时固定
      ..strokeWidth = 1;

    final pointMode = PointMode.lines;
    canvas.drawPoints(pointMode, lineOffsets, _paint);
    canvas.restore();
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) {
    return false;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;综上，自绘逐渐的核心是继承&lt;code&gt;CustomPaint&lt;/code&gt;，然后使用&lt;code&gt;Canvas&lt;/code&gt;实现UI的绘制&lt;/p&gt;

&lt;h4 id=&#34;5-实现renderobject&#34;&gt;5.实现RenderObject&lt;/h4&gt;

&lt;p&gt;实现&lt;code&gt;RenderObject&lt;/code&gt;即是自己重写一整套渲染树，首先得继承一个&lt;code&gt;RenderObject&lt;/code&gt;，实现其内置仿佛，还得继承&lt;code&gt;Element&lt;/code&gt;，实现其内置方法，复杂的自定义组件最终也是通过&lt;code&gt;Canvas&lt;/code&gt; API来绘制的，而上面说的&lt;code&gt;CustomPaint&lt;/code&gt;只是为了方便开发者封装的一个代理类，它直接继承自&lt;code&gt;SingleChildRenderObjectWidget&lt;/code&gt;，通过&lt;code&gt;RenderCustomPaint&lt;/code&gt;的&lt;code&gt;paint&lt;/code&gt;方法将&lt;code&gt;Canvas&lt;/code&gt;和画笔&lt;code&gt;Painter&lt;/code&gt;连接起来实现自绘组件。这种方式操作起来实在比较麻烦，我也没怎么用过，所以就不提供示例展示了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>输入一个URL到页面呈现的过程</title>
      <link>https://xtid.github.io/2020/%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAurl%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0%E7%9A%84%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Sun, 15 Nov 2020 15:21:34 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAurl%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0%E7%9A%84%E8%BF%87%E7%A8%8B/</guid>
      <description>

&lt;h4 id=&#34;1-dns解析&#34;&gt;1.DNS解析&lt;/h4&gt;

&lt;p&gt;平时在浏览器中输入的域名并非是网址或资源真实所在的服务器地址或资源，域名只是与&lt;code&gt;ip&lt;/code&gt;地址的一个映射。在进行正式的请求之前，就会先有这个过程：&lt;code&gt;DNS&lt;/code&gt;服务将域名解析成对应的&lt;code&gt;ip&lt;/code&gt;地址。其解析过程：&lt;/p&gt;

&lt;p&gt;1.检查本机&lt;code&gt;host&lt;/code&gt;中是否有配置相应的&lt;code&gt;ip&lt;/code&gt;映射关系，如果有则使用这个&lt;code&gt;ip&lt;/code&gt;地址，完成域名解析
2.检查浏览器缓存中是否缓存过该域名对应的&lt;code&gt;ip&lt;/code&gt;地址
3.检查找本机系统中是否缓存过&lt;code&gt;ip&lt;/code&gt;
4.向本地域名解析服务发起域名解析的请求
5.向根域名解析服务器发起域名解析请求
6.按照根域名&lt;code&gt;(.)&lt;/code&gt; -&amp;gt; 顶级域&lt;code&gt;(如：.com)&lt;/code&gt; -&amp;gt; 第二层域&lt;code&gt;(如：xxx.com)&lt;/code&gt; -&amp;gt; 子域&lt;code&gt;(如：www.xxx.com)&lt;/code&gt;的顺序查找到ip地址
8.返回解析结果给用户&lt;/p&gt;

&lt;h4 id=&#34;2-建立-tcp-连接&#34;&gt;2.建立&lt;code&gt;TCP&lt;/code&gt;连接&lt;/h4&gt;

&lt;p&gt;经典的三次握手&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;第一次握手： 建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；&lt;/p&gt;

&lt;p&gt;第二次握手： 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；&lt;/p&gt;

&lt;p&gt;第三次握手： 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单来说其步骤就是，客户端发送数据包告诉服务端连接请求，服务端返回数据包响应表示可以收到建立连接请求并且返回数据包通知客户端，客服端再次发送数据包确认并建立&lt;code&gt;TCP&lt;/code&gt;连接&lt;/p&gt;

&lt;h4 id=&#34;3-发送-http-请求&#34;&gt;3.发送&lt;code&gt;HTTP&lt;/code&gt;请求&lt;/h4&gt;

&lt;p&gt;一个&lt;code&gt;HTTP&lt;/code&gt;请求包含请求行，请求头，请求主体&lt;/p&gt;

&lt;h5 id=&#34;3-1请求行&#34;&gt;3.1请求行&lt;/h5&gt;

&lt;p&gt;常见的信息有请求地址、请求方法&lt;code&gt;GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE&lt;/code&gt;、&lt;code&gt;Http&lt;/code&gt;协议信息&lt;/p&gt;

&lt;h5 id=&#34;3-2请求头&#34;&gt;3.2请求头&lt;/h5&gt;

&lt;p&gt;常见的请求头信息有&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Host&lt;/code&gt;：主机名
&lt;code&gt;Connection&lt;/code&gt;：&lt;code&gt;HTTP/1.1&lt;/code&gt;增加的，使用&lt;code&gt;keepalive&lt;/code&gt;，一个连接可以发多个请求
&lt;code&gt;User-Agent&lt;/code&gt;：客户端程序的信息，就是发送请求的浏览器信息，可根据这个信息来对不同设备进行处理
&lt;code&gt;Accept&lt;/code&gt;：浏览器可以接收的媒体数据类型
&lt;code&gt;Accept-Encoding&lt;/code&gt;：是浏览器用来告知服务器它能够支持的内容编码及内容编码的优先级顺序，可一次性指定多种内容编码
&lt;code&gt;Accept-Language&lt;/code&gt;：告诉服务器浏览器能够处理的自然语言集
&lt;code&gt;Content-Type&lt;/code&gt;：请求中的数据的媒体类型
&lt;code&gt;Cookie&lt;/code&gt;：浏览器记录的用户相关信息&lt;/p&gt;

&lt;p&gt;当然还有很多其他的，这里就不罗列完了，另外还可以自己添加一些自定义请求头，在服务端手动获取处理就行了&lt;/p&gt;

&lt;h5 id=&#34;3-3请求主体&#34;&gt;3.3请求主体&lt;/h5&gt;

&lt;p&gt;主要是请求所带的一些参数信息，这里就不多赘述&lt;/p&gt;

&lt;h4 id=&#34;4-使用浏览器缓存&#34;&gt;4.使用浏览器缓存&lt;/h4&gt;

&lt;p&gt;浏览器缓存主要&lt;code&gt;强缓存&lt;/code&gt;和&lt;code&gt;协商缓存&lt;/code&gt;，具体使用哪一种缓存，强缓存的优先级比协商缓存高，怎么设置还是得从实际出发&lt;/p&gt;

&lt;h5 id=&#34;4-1强缓存&#34;&gt;4.1强缓存&lt;/h5&gt;

&lt;p&gt;强缓存可以用&lt;code&gt;Expires&lt;/code&gt;和&lt;code&gt;Cache-Control&lt;/code&gt;来控制，强缓存最大的特点就是通过服务器返回的过期时间来判断缓存是否过期，不会再去和服务端做校验看资源是否真正更新了&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Expires&lt;/code&gt;：主由服务端返给客户端，在过期时间内，浏览器可直接使用缓存而不需要重新请求，但它也有不少局限，首先它只能精确到秒，对于那种毫秒级更新的资源它没办法判断，其次它受限于本地时间，如果修改了本地时间，可能会造成缓存失效。&lt;code&gt;Expires&lt;/code&gt;是&lt;code&gt;Http/1&lt;/code&gt;时候的请求头，现在这样设置通常也是为了兼容&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Cache-Control&lt;/code&gt;：是现在主要使用的方式，可以在请求头以及响应头中设置，常见设置有&lt;code&gt;max-age(表示缓存在多少秒后过期)&lt;/code&gt;，&lt;code&gt;no-cache(表示使用Etag或者Last-Modified字段来控制缓存，即协商缓存)&lt;/code&gt;，通常来讲，&lt;code&gt;Cache-control&lt;/code&gt;的优先级是要高于&lt;code&gt;Expires&lt;/code&gt;的&lt;/p&gt;

&lt;h5 id=&#34;4-2协商缓存&#34;&gt;4.2协商缓存&lt;/h5&gt;

&lt;p&gt;在强缓存失效后就会用协商缓存，协商缓存主要使用&lt;code&gt;Last-Modified 和 ETag&lt;/code&gt;请求头控制，这两个字段都是由服务端返回的。如果说缓存还生效，那么这次请求的状态码会返回&lt;code&gt;304&lt;/code&gt;，表示资源未改动，如果缓存失效，返回新的资源并设置缓存，返回&lt;code&gt;200&lt;/code&gt;状态码&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Last-Modified&lt;/code&gt;：在设置&lt;code&gt;Last-Modified&lt;/code&gt;后，下次请求时请求头会带上&lt;code&gt;If-Modified-Since&lt;/code&gt;这个字段，然后服务器会用这个时间与资源修改时间做对比，然后就是返回&lt;code&gt;304&lt;/code&gt;还是&lt;code&gt;200&lt;/code&gt;的问题了，同样它也只能精确到秒，所以一些需要毫秒级更新的资源使用这个并不准确&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ETag&lt;/code&gt;：通常与&lt;code&gt;If-None-Match&lt;/code&gt;配合使用，&lt;code&gt;Etag&lt;/code&gt;为服务端为这资源生成的唯一标识，下次客户端请求的时候，带上这个值，由服务端再做校验，如果资源未改动，返回&lt;code&gt;304&lt;/code&gt;，使用原来的缓存，反之返回&lt;code&gt;200&lt;/code&gt;，设置缓存&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/10/28/O2gaJWm8jYPeI7c.png&#34; alt=&#34;浏览器缓存.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图出自&lt;a href=&#34;https://github.com/ljianshu/Blog&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;博客&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;5-浏览器接收响应&#34;&gt;5.浏览器接收响应&lt;/h4&gt;

&lt;p&gt;响应分为状态码，响应头，响应主体组成，响应主体通常是一些文件&lt;code&gt;如(HTML、JS、CSS文件)&lt;/code&gt;或者说是一些响应数据&lt;code&gt;(请求的响应数据)&lt;/code&gt;，状态码和响应头这里就不罗列了。有个特别的通常为了提升响应的效率，服务端会将一些进行&lt;code&gt;gzip&lt;/code&gt;压缩，然后响应头里面会有个响应头&lt;code&gt;content-encoding:gzip&lt;/code&gt;，然后浏览器会再进行解压&lt;/p&gt;

&lt;h4 id=&#34;6-页面渲染&#34;&gt;6.页面渲染&lt;/h4&gt;

&lt;p&gt;在接收响应成功之后，浏览器就开始渲染页面了。其步骤包括：1.解析&lt;code&gt;HTML&lt;/code&gt;为&lt;code&gt;DOM&lt;/code&gt;树、2.解析&lt;code&gt;CSS&lt;/code&gt;为&lt;code&gt;CSS&lt;/code&gt;树、3.合并&lt;code&gt;DOM&lt;/code&gt;树已经&lt;code&gt;CSS&lt;/code&gt;树、4.遍历整个节点、5.按照&lt;code&gt;CSS&lt;/code&gt;的优先级渲染每个节点的样式，呈现在屏幕上。当浏览器遇到一个&lt;code&gt;script&lt;/code&gt;标记时，&lt;code&gt;DOM&lt;/code&gt;构建将暂停，直至脚本完成执行，然后继续构建&lt;code&gt;DOM&lt;/code&gt;。每次去执行&lt;code&gt;JS&lt;/code&gt;脚本都会严重阻塞&lt;code&gt;DOM&lt;/code&gt;树的构建，如果&lt;code&gt;JS&lt;/code&gt;脚本还操作的&lt;code&gt;CSSOM&lt;/code&gt;，而正好这个&lt;code&gt;CSSOM&lt;/code&gt;还没有下载和构建，浏览器甚至会延迟脚本执行和构建&lt;code&gt;DOM&lt;/code&gt;，直至完成其&lt;code&gt;CSSOM&lt;/code&gt;的下载和构建。所以这里通常会有个常见的小优化，&lt;code&gt;CSS&lt;/code&gt;放在顶部，&lt;code&gt;JS&lt;/code&gt;放在底部，并且减少使用在加载的过程中操作&lt;code&gt;DOM&lt;/code&gt;，当然这也是比较老的做法了。在页面加载的过程中，所写的&lt;code&gt;CSS&lt;/code&gt;和&lt;code&gt;JS&lt;/code&gt;也要尽量避免重绘和回流&lt;/p&gt;

&lt;h4 id=&#34;7-四次握手&#34;&gt;7.四次握手&lt;/h4&gt;

&lt;p&gt;四次握手用于断开&lt;code&gt;Tcp&lt;/code&gt;连接，客户端发送请求表示要断开连接，服务接受到请求后响应，客户端收到响应准备断开连接，服务端将其余数据或没响应的数据全部返给客户端(即又一次握手)，客户端收到后响应后再发送请求确认关闭，服务端收到后断开连接&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&#34;参考链接&#34;&gt;参考链接&lt;/h6&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ljianshu/Blog&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;博客&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>浅谈前端统计</title>
      <link>https://xtid.github.io/2020/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E7%BB%9F%E8%AE%A1/</link>
      <pubDate>Wed, 28 Oct 2020 21:45:40 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E7%BB%9F%E8%AE%A1/</guid>
      <description>&lt;p&gt;监控系统在现在的项目中是必不可少的，它具有性能监控、错误监控以及数据上报等功能。通过对的错误监控、用户正常行为的收集，从而指定对应的优化方案、营销策略以及项目的迭代。 试想，如果没有这些监控系统，那么线上的运行的项目出问题了，定位是比较困难的，这时候修复起来就比较劳神了。我记录下我所了解的，常见的方式。&lt;/p&gt;

&lt;p&gt;1.错误监控&lt;/p&gt;

&lt;p&gt;我们对于错误的处理，在&lt;code&gt;js&lt;/code&gt;中很常见的错误捕获&lt;code&gt;try catch&lt;/code&gt;、&lt;code&gt;promise中的catch&lt;/code&gt;等等。在window对象上有一个方法&lt;code&gt;onerror&lt;/code&gt;，可以拿到当前报错的信息，我们就可以将这个信息拿到然后提交到我们自己的监控系统，还有个很重要的原因，不处理这些错误，导致页面挂了停止加载，那损失可就大了。对于抛出的错误，它有几个属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 定义一个错误对象
const defaults = {
  msg: &#39;&#39;, // 错误的具体信息
  url: &#39;&#39;, // 错误所在的url
  line: &#39;&#39;, // 错误所在的行
  col: &#39;&#39;, // 错误所在的列
  nowTime: &#39;&#39; // 时间
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后实现&lt;code&gt;window.onerror&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;window.onerror = function (msg, url, line, col, error) {
  col = col || (window.event &amp;amp;&amp;amp; window.event.errorCharacter) || 0

  defaults.url = url
  defaults.line = line
  defaults.col = col
  defaults.nowTime = new Date().getTime()

  if (error &amp;amp;&amp;amp; error.stack) {
    // 如果浏览器有错误堆栈信息，直接使用
    defaults.msg = error.stack.toString()
  } else if (arguments.callee) {
    // 通过callee拿堆栈信息
    let ext = []
    let fn = arguments.callee.caller
    // 最多拿到三层
    let floor = 3
    while (fn &amp;amp;&amp;amp; (--floor &amp;gt; 0)) {
      ext.push(fn.toString())
      if (fn === fn.caller) {
        break
      }
      fn = fn.caller
    }
    ext = ext.join(&#39;,&#39;)
    defaults.msg = error &amp;amp;&amp;amp; error.stack &amp;amp;&amp;amp; error.stack.toString()
  }
  let str = &#39;&#39;
  // 格式化这些错误信息
  for (const i in defaults) {
    if (!defaults[i]) {
      defaults[i] = &#39;null&#39;
    }
    str += &#39;&amp;amp;&#39; + i + &#39;=&#39; + defaults[i].toString()
  }
  // 确定错误是由哪位用户引起的，这一步有些时候可以不用
  let userinfo = // 拿到用户信息
  if (typeof userinfo === &#39;object&#39;) {
    userinfo = JSON.stringify(userinfo)
  }
  if (userinfo) userinfo = encodeURIComponent(userinfo)
  str = encodeURIComponent(str.replace(&#39;&amp;amp;&#39;, &#39;&#39;).replace(&#39;\n&#39;, &#39;&#39;).replace(/\s/g, &#39;&#39;))
	
  // 避免出现跨域错误
  new Image().src = &#39;api地址?msg=&#39; + str + &#39;&amp;amp;userinfo=&#39; + userinfo
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方式的缺陷在于，没办法处理&lt;code&gt;promise&lt;/code&gt;中未处理的错误，对于&lt;code&gt;promise&lt;/code&gt;，推荐使用&lt;code&gt;unhandledrejection&lt;/code&gt;事情处理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;window.addEventListener(&#39;unhandledrejection&#39;, event =&amp;gt; {
  let error = event.reason &amp;amp;&amp;amp; event.reason.message
  if (!error) {
    error = typeof event.reason === &#39;object&#39; ? JSON.stringify(event.reason) : event.reason
  }

  (new Image()).src = &#39;api地址?msg=&#39; + encodeURIComponent(error)
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.埋点&lt;/p&gt;

&lt;p&gt;埋点是一种常见的统计用户行为的方式或工具。通过在页面设置埋点，来统计用户对于某个页面、广告、功能的使用频率、喜好，然后通过对埋点的数据统计，确定好页面或功能的迭代。简单的做法，设置一个全局方法用来提交埋点点击的行为，在需要的地方调用这个方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 定义一个全局方法
// 传入的point为埋点数据
function clickPoint(point = {}) {
  const { id, name } = point
  cosnt userInfo = // 通过对应的操作拿到用户信息
  // 基础参数
  const basicParams = {
    id: id || &#39;&#39;,
    name: name || &#39;&#39;
  }
  // 用户信息
 	const userParams = {
  	name: userInfo.name || &#39;&#39;
    ......
 	}
  // 合并参数
  const params = {
    ...basicParams,
    ...userParams
  }
  let str = &#39;&#39;
  for (const i in params) {
    if (!params[i]) {
      params[i] = &#39;null&#39;
    }
    str += &#39;&amp;amp;&#39; + i + &#39;=&#39; + params[i].toString()
  }
  new Image().src = &#39;api地址?msg=&#39; + str
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常这样来统计页面上某个功能、某个广告的点击量，获取对应的统计数据。还有一种比较常见的方式，为需要添加埋点的&lt;code&gt;html&lt;/code&gt;标签上加上某个约定好的自定义属性，如&lt;code&gt;&amp;lt;div data-link=&amp;quot;111&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;，这个&lt;code&gt;111&lt;/code&gt;就是就是实现生成好或者规划好的埋点。然后给这种属性添加全局的点击事件，点击后同样的将对应的数据提交到自己的后台系统去。有些时候为了方便查阅或者直观的观看统计数据，还可以在页面渲染的时候，为含有&lt;code&gt;data-link&lt;/code&gt;属性的标签生成对应的一些图标或者文字标签，使用&lt;code&gt;absolute&lt;/code&gt;定位显示在对应的元素上，当然这种方式在你添加买点埋点属性的时候，需要给这个元素设置相应的&lt;code&gt;position css&lt;/code&gt;属性；当然也可能设置一些热力图啊等其它形式，反正都是实现同一个效果的。&lt;/p&gt;

&lt;p&gt;3.白屏时间&lt;/p&gt;

&lt;p&gt;这个之前说过，就不说废话了，白屏时间的统计是非常重要的。比如有些时候，只有某个用户的某个设备出现了页面加载过长，页面没内容，发现这个问题后，通过判断错误日志和白屏时间才能更快的定位问题。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;window.logInfo = {}
window.logInfo.openTime = window.performance &amp;amp;&amp;amp; window.performance.timing.navigationStart || 0
window.logInfo.whiteScreenTime = +new Date() - window.logInfo.openTime
window.logInfo.mobile = mobileType()

// 使用 DOMContentLoaded 统计页面有内容的时间
document.addEventListener(&#39;DOMContentLoaded&#39;, function () {
  window.logInfo.readyTime = +new Date() - window.logInfo.openTime
})
window.onload = function () {
  window.logInfo.allloadTime = +new Date() - window.logInfo.openTime
  window.logInfo.nowTime = new Date().getTime()
  let timname = {
    whiteScreenTime: &#39;白屏时间&#39;,
    readyTime: &#39;用户可操作时间&#39;,
    allloadTime: &#39;总下载时间&#39;,
    mobile: &#39;使用设备&#39;,
    nowTime: &#39;时间&#39;,
  }
  let logStr = &#39;&#39;
  for (const i in timname) {
    if (i === &#39;mobile&#39;) {
      logStr += &#39;&amp;amp;&#39; + i + &#39;=&#39; + window.logInfo[i]
    } else {
      logStr += &#39;&amp;amp;&#39; + i + &#39;=&#39; + window.logInfo[i]
    }
  }
  // 这里如果需要的话，还可以把用户的一些信息收集出来
  (new Image()).src = &#39;api地址?msg=&#39; + logStr
}

function mobileType() {
  const u = navigator.userAgent
  // 移动终端浏览器版本信息
  const type = {
    ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), // ios终端
    iPad: u.indexOf(&#39;iPad&#39;) &amp;gt; -1, // 是否iPad
    android: u.indexOf(&#39;Android&#39;) &amp;gt; -1 || u.indexOf(&#39;Linux&#39;) &amp;gt; -1, // android终端或者uc浏览器
    iPhone: u.indexOf(&#39;iPhone&#39;) &amp;gt; -1 || u.indexOf(&#39;Mac&#39;) &amp;gt; -1, // 是否为iPhone或者QQHD浏览器
    trident: u.indexOf(&#39;Trident&#39;) &amp;gt; -1, // IE内核
    presto: u.indexOf(&#39;Presto&#39;) &amp;gt; -1, // opera内核
    webKit: u.indexOf(&#39;AppleWebKit&#39;) &amp;gt; -1, // 苹果、谷歌内核
    gecko: u.indexOf(&#39;Gecko&#39;) &amp;gt; -1 &amp;amp;&amp;amp; u.indexOf(&#39;KHTML&#39;) === -1, // 火狐内核
    mobile: !!u.match(/AppleWebKit.*Mobile/i) || !!u.match(/MIDP|SymbianOS|NOKIA|SAMSUNG|LG|NEC|TCL|Alcatel|BIRD|DBTEL|Dopod|PHILIPS|HAIER|LENOVO|MOT-|Nokia|SonyEricsson|SIE-|Amoi|ZTE/), // 是否为移动终端
    webApp: u.indexOf(&#39;Safari&#39;) === -1 // 是否web应该程序，没有头部与底部
  }
  const lists = Object.keys(type)
  for (const i = 0; i &amp;lt; lists.length; i++) {
    if (type[lists[i]]) {
      return lists[i]
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>白屏时间</title>
      <link>https://xtid.github.io/2020/%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4/</link>
      <pubDate>Sat, 24 Oct 2020 23:45:12 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4/</guid>
      <description>&lt;p&gt;白屏时间指的是从用户进入网站，一直到页面有内容展示出来的时间节点，在这期间用户什么东西都看不到，这个过程包括dns查询、建立tcp连接、发送首个http请求、返回html文档、html文档head解析完毕。白屏时间的长短，影响着用户的体验，白屏时间过长，用户失去了耐心等待，也许就关闭了网页&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一份是 &lt;a href=&#34;http://www.akamai.com/html/about/press/releases/2009/press_091409.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Akamai&lt;/a&gt; 的研究报告，当时总共采访了大约 1048 名网上购物者，得出了这样的结论：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;大约有 47% 的用户期望他们的页面在两秒之内加载完成。&lt;/li&gt;
&lt;li&gt;如果页面加载时间超过 3s，大约有 40% 的用户选择离开或关闭页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;白屏时间的计算就如上诉定义说的那样，只需要记录用户进入页面的开始时间，记录head加载完成的时间，记录两者的差值，这就是所说的白屏时间。计算的时候可以分别获取两个时间，计算他们的差，也可以使用&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/mark&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;performance.mark&lt;/a&gt;，在开始地点标记或者说打点，在结束地点获取这个&lt;code&gt;entry&lt;/code&gt;，拿到它的&lt;code&gt;duration&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
	&amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
	&amp;lt;title&amp;gt;白屏时间&amp;lt;/title&amp;gt;
	&amp;lt;script&amp;gt;
		window.startTime = Date.now();
    // performance.mark(&amp;quot;timeStr&amp;quot;);
	&amp;lt;/script&amp;gt;
	&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;&amp;quot;&amp;gt;
	&amp;lt;script src=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
	&amp;lt;script&amp;gt;
		window.endTime = Date.now()
    // const timeStrEntries = performance.getEntriesByName(&amp;quot;timeStrEntries&amp;quot;);
    // console.log(timeStrEntries[0].duration)
	&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外还有一种方式，使用&lt;code&gt;window.performance&lt;/code&gt;，在&lt;code&gt;timing&lt;/code&gt;对象中，包含了各种时间相关的属性，其中&lt;code&gt;domLoading&lt;/code&gt;属性代表开始解析&lt;code&gt;DOM&lt;/code&gt;元素的时间，&lt;code&gt;fetchStart&lt;/code&gt;属性代表发送请求前的时间，两者之差也可以计算白屏时间&lt;/p&gt;

&lt;p&gt;对于具体的时间优化，可以针对整个页面渲染的过程来处理。这里说一下：&lt;code&gt;预渲染&lt;/code&gt;、&lt;code&gt;服务端渲染&lt;/code&gt;、&lt;code&gt;使用骨架屏&lt;/code&gt;，这也可以说是用户的体验优化&lt;/p&gt;

&lt;p&gt;首先预渲染，主要是用&lt;code&gt;prerender-spa-plugin&lt;/code&gt;来实现这个功能。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;prerender-spa-plugin 利用了 Puppeteer 的爬取页面的功能。 Puppeteer 是 Google Chrome 团队官方的无界面（Headless）Chrome 工具，它是一个 Node 库，提供了一个高级的 API 来控制 DevTools 协议上的无头版 Chrome 。prerender-spa-plugin 原理是在 Webpack 构建阶段的最后，在本地启动一个 Puppeteer 的服务，访问配置了预渲染的路由，然后将 Puppeteer 中渲染的页面输出到 HTML 文件中，并建立路由对应的目录。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先请求到对应的路由或者页面之后，&lt;code&gt;Puppeteer&lt;/code&gt;会获取渲染的页面的静态部分内容并替换打包出来的&lt;code&gt;html&lt;/code&gt;文件，达到预渲染的目的，页面加载完成之前呈现给用户部分内容，给用户一个相对好的体验。但是缺点是预渲染出的内容往往与最终渲染的页面内容不同，因为页面会有相应的交互或者数据的变化，所以最好对于一些静态页面才用这种方式处理。&lt;/p&gt;

&lt;p&gt;首先在对应的&lt;code&gt;webpack&lt;/code&gt;配置文件中添加这个插件的配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const PrerenderSPAPlugin = require(&#39;prerender-spa-plugin&#39;);
const Renderer = PrerenderSPAPlugin.PuppeteerRenderer;
const path = require(&#39;path&#39;);

module.exports = {
  plugins: [new PrerenderSPAPlugin({
    staticDir: path.join(__dirname, &#39;dist&#39;),
    routes: [ &#39;/&#39; ], // 需要预渲染的路由,
    renderer: new Renderer({
        headless: true, // 开启无头浏览器
        renderAfterDocumentEvent: &#39;render-event&#39;, 
    }),
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在页面触发&lt;code&gt;render-event&lt;/code&gt;事件，告诉&lt;code&gt;Puppeteer&lt;/code&gt;去爬取这个页面，这里以&lt;code&gt;vue&lt;/code&gt;为例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export default {
  mounted() {
    document.dispatchEvent(new Event(&#39;render-event&#39;));
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后访问对应的&lt;code&gt;route&lt;/code&gt;，在&lt;code&gt;index.html&lt;/code&gt;中就可以看到相应的内容了。实际应用中在静态页面中的时候，应当另外指定对应的&lt;code&gt;html&lt;/code&gt;文件，如果配置了&lt;code&gt;CDN&lt;/code&gt;，那么在本地开发的时候，应该将&lt;code&gt;CDN&lt;/code&gt;地址替换为本地地址，这个插件也提供了&lt;code&gt;server&lt;/code&gt;选项&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;server: {
  port: 80,
  proxy: {
    ......
    target: &#39;http://localhost&#39;,
    changeOrigin: true,
    ......
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务端渲染&lt;/p&gt;

&lt;p&gt;服务端渲染是由服务端将渲染好的&lt;code&gt;html&lt;/code&gt;字符串直接返给客户端，客户端接受到对应的&lt;code&gt;html&lt;/code&gt;字符串后，解析渲染呈现出相应的页面。客户端渲染时，客户端需要去请求相应的接口取得相应的数据然后渲染出&lt;code&gt;html&lt;/code&gt;页面，因此，服务端渲染白屏时间相对较短。还有个额外的好处当然是利于SEO，这个作用恐怕还在白屏优化之上。客户端渲染一开始的页面为空，在某些爬虫来爬的时候什么东西都获取不到，所以不利于SEO，当然这是后话了。现在我们这用的比较多的，一般是以&lt;code&gt;nodejs&lt;/code&gt;为中间层，接受到客户端的请求后，发送真正的请求到后台，随后在&lt;code&gt;nodejs&lt;/code&gt;中处理完对应的数据，渲染页面。现在以&lt;code&gt;react&lt;/code&gt;、&lt;code&gt;vue&lt;/code&gt;为基础，也有各自对应的服务端渲染方案，如&lt;code&gt;next.js&lt;/code&gt;、&lt;code&gt;nuxt.js&lt;/code&gt;这里就不介绍了&lt;/p&gt;

&lt;p&gt;骨架屏&lt;/p&gt;

&lt;p&gt;骨架屏可以看做用来代替页面&lt;code&gt;loading&lt;/code&gt;效果的一种方案，在页面加载完成之前，呈现出页面的一个大致结构，给用户一个良好的体验，让他觉得这个页面正在缓慢加载，这种效果看起来也比单纯的放一张菊花图、一张加载动画好一些。这个方案更多的是带来更好的用户体验。手写骨架屏，首先确定页面的基本结构，然后按照这个结构写一个类似的加载页面，这个由设计来定。以下介绍使用&lt;code&gt;webpack(4.0+)&lt;/code&gt;来写一个简单的骨架屏插件。&lt;/p&gt;

&lt;p&gt;首先定义一个骨架屏插件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)

let Skeleton = function (options) {
  // 接收传入的参数
}

Skeleton.prototype.apply = function (compiler) {
  compiler.plugin(&#39;compilation&#39;, compilation =&amp;gt; {
    HtmlWebpackPlugin.getHooks(compilation).beforeEmit.tapAsync(
      &#39;Skeleton&#39;,
      (htmlData, cb) =&amp;gt; {
        htmlData.html = htmlData.html.replace(&#39;&amp;lt;div id=&amp;quot;root&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#39;, `骨架屏代码`)
        cb(null, htmlData)
      }
    )
  })
}

module.exports = Skeleton
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后&lt;code&gt;webpack&lt;/code&gt;配置文件中引入即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;...
new HtmlWebPackPlugin({
  template: &#39;public/index.html&#39;,
  filename: &#39;index.html&#39;,
  inject: true
}),
new Skeleton({
  template: &#39;public/index.html&#39;
})
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.以上首先定义一个插件对象&lt;code&gt;Skeleton&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2.引入&lt;code&gt;html-webpack-plugin&lt;/code&gt;，在&lt;code&gt;html-webpack-plugin&lt;/code&gt;的钩子函数&lt;code&gt;beforeEmit&lt;/code&gt;中，调用这个&lt;code&gt;Skeleton&lt;/code&gt;对象，&lt;/p&gt;

&lt;p&gt;&lt;code&gt;beforeEmit&lt;/code&gt;这个钩子函数的作用在于&lt;code&gt;html-webpack-plugin&lt;/code&gt;插件将生成的&lt;code&gt;html&lt;/code&gt;插入模板文件前进行的操作。这里就相当于在生成真正的&lt;code&gt;html&lt;/code&gt;代码之前调用生成骨架屏页面。&lt;/p&gt;

&lt;p&gt;3.调用&lt;code&gt;cb&lt;/code&gt;，传回&lt;code&gt;html&lt;/code&gt;内容&lt;/p&gt;

&lt;p&gt;4.需要注意的是，&lt;code&gt;replace&lt;/code&gt;中的需要替换的根元素、类名不要搞错了。&lt;/p&gt;

&lt;p&gt;其余的，根据不同的路径，入口可以将参数传入这个构造函数中，然后判断显示不同的骨架屏。最大的缺点就是复用性不强，也许会随着页面的迭代而经常变动，维护起来也很麻烦。&lt;/p&gt;

&lt;p&gt;还有些其他自动生成骨架屏的开源方案。比如饿了么开源的&lt;code&gt;page-skeleton-webpack-plugin&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;通过 &lt;a href=&#34;https://link.zhihu.com/?target=https%3A//github.com/GoogleChrome/puppeteer&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;puppeteer&lt;/a&gt; 在服务端操控 &lt;a href=&#34;https://link.zhihu.com/?target=https%3A//developers.google.com/web/updates/2017/04/headless-chrome&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;headless Chrome&lt;/a&gt; 打开开发中的需要生成骨架屏的页面，在等待页面加载渲染完成之后，在保留页面布局样式的前提下，通过对页面中元素进行删减或增添，对已有元素通过层叠样式进行覆盖，这样达到在不改变页面布局下，隐藏图片和文字，通过样式覆盖，使得其展示为灰色块。然后将修改后的 HTML 和 CSS 样式提取出来，这样就是骨架屏了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;它的大致原理，就是利用&lt;code&gt;puppeteer&lt;/code&gt;获取页面结构，将不同的节点分类处理，展现不同的&amp;rsquo;骨架效果&amp;rsquo;，最后实际渲染的时候，进行相应的替换。但是就针对于这个项目&lt;code&gt;page-skeleton-webpack-plugin&lt;/code&gt;来说，坑比较多，而且不支持&lt;code&gt;webpack4&lt;/code&gt;，慎重使用。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Webpack打包优化</title>
      <link>https://xtid.github.io/2020/webpack%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 07 Sep 2020 22:03:34 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/webpack%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/</guid>
      <description>&lt;p&gt;之前了解了&lt;code&gt;webpack&lt;/code&gt;的基本打包流程或者说原理，如果只是配置一个基本的&lt;code&gt;webpack&lt;/code&gt;打包配置，
打包后的文件会变得很大，当你项目部署后，用户打开对应的界面，也许会很长时间才加载完(当然和网络环境或硬件设备也有关系)，尤其是单页面应用效果很明显，这样的用户体验自然是不好的，所以此文章主要是对&lt;code&gt;webpack&lt;/code&gt;打包优化的一个小小总结&lt;/p&gt;

&lt;p&gt;首先搭建好一个基本的项目，目录结构&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;├── dist // 打包目录
│   ├── bundle.js // 打包后的js
│   └── index.html // 入口html文件
├── package-lock.json
├── package.json
├── public
│   └── index.html // html模板文件
├── src
│   ├── actions // redux actions文件
│   │   └── index.js
│   ├── app.js // webpack打包入口文件，也是项目的入口文件
│   ├── assets // scss
│   │   ├── about.scss
│   │   ├── title.scss
│   │   └── user.scss
│   ├── dev.js // 开发时的一些配置
│   ├── pages // page页面
│   │   ├── about.jsx
│   │   ├── index.jsx
│   │   ├── title.jsx
│   │   └── user.jsx
│   ├── reducers // redux中的reducer
│   │   └── index.js
│   └── store.js
└── webpack.config.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt;基本配置如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const path = require(&#39;path&#39;)
const HtmlWebPackPlugin = require(&#39;html-webpack-plugin&#39;)

module.exports = {
  entry: &#39;./src/app.js&#39;,
  output: {
    path: path.resolve(__dirname, &#39;./dist/&#39;),
    filename: &#39;bundle.js&#39;
  },
  resolve: {
    extensions: [&#39;.wasm&#39;, &#39;.mjs&#39;, &#39;.js&#39;, &#39;.json&#39;, &#39;.jsx&#39;]
  },

  devServer: {
    contentBase: path.join(__dirname, &#39;./src/&#39;),
    publicPath: &#39;/&#39;,
    host: &#39;127.0.0.1&#39;,
    port: 3000,
    hot: true,
    stats: {
      colors: true
    }
  },
  module: {
    rules: [{
      test: /\.jsx?$/,
      exclude: /node_modules/,
      use: {
        loader: &#39;babel-loader&#39;
      }
    }, {
      test: /\.scss$/,
      use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;]
    }]
  },
  plugins: [
    new HtmlWebPackPlugin({
      template: &#39;public/index.html&#39;,
      filename: &#39;index.html&#39;,
      inject: true
    })
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优化：&lt;/p&gt;

&lt;p&gt;1.基础优化&lt;/p&gt;

&lt;p&gt;配置&lt;code&gt;loader&lt;/code&gt;，添加&lt;code&gt;exclude&lt;/code&gt;、&lt;code&gt;include&lt;/code&gt;缩小搜索范围，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  test: /\.jsx?$/,
    exclude: /node_modules/, // 过滤node_modules
      use: {
        loader: &#39;babel-loader&#39;
      }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.使用&lt;code&gt;DllPlugin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;将一些变动较少或者根本不会变动的库先打包生成对应的&lt;code&gt;.dll.js&lt;/code&gt;，在&lt;code&gt;webpack&lt;/code&gt;打包的时候，将这些资源引入&lt;/p&gt;

&lt;p&gt;首先新建一个&lt;code&gt;webpack.config.dll.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const path = require(&#39;path&#39;);
const DllPlugin = require(&#39;webpack/lib/DllPlugin&#39;);

module.exports = {
  entry: {
    react: [&#39;react&#39;, &#39;react-dom&#39;]
  },
  output: {
    filename: &#39;[name].dll.js&#39;,
    // 生成的文件目录
    path: path.resolve(__dirname, &#39;dist&#39;),
    // 动态链接库名称
    library: &#39;_dll_[name]&#39;
  },
  plugins: [
    new DllPlugin({
      name: &#39;_dll_[name]&#39;,
      path: path.join(__dirname, &#39;dist&#39;, &#39;[name].manifest.json&#39;),
      context: __dirname, 
    })
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在&lt;code&gt;package.json&lt;/code&gt;的&lt;code&gt;scripts&lt;/code&gt;中添加dll打包命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;webpack --config webpack.config.dll.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后运行此命令，可以看到会在&lt;code&gt;dist&lt;/code&gt;目录下面生成&lt;code&gt;react.dll&lt;/code&gt;，&lt;code&gt;react.manifest.json&lt;/code&gt;两个文件，这就是生成的&lt;code&gt;dll&lt;/code&gt;文件，然后&lt;code&gt;webpack.config.js&lt;/code&gt;里面添加配置，打包时引入这些的&lt;code&gt;dll&lt;/code&gt;文件。&lt;/p&gt;

&lt;p&gt;首先安装插件&lt;code&gt;add-asset-html-webpack-plugin&lt;/code&gt;，引入&lt;code&gt;DllReferencePlugin&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const DllReferencePlugin = require(&#39;webpack/lib/DllReferencePlugin&#39;)
const AddAssetHtmlPlugin = require(&#39;add-asset-html-webpack-plugin&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;插件里面配置(webpack4+)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;new DllReferencePlugin({
  context: __dirname,
  manifest: require(&#39;./dist/react.manifest.json&#39;),
}),
new AddAssetHtmlPlugin({
  filepath: path.resolve(__dirname, &#39;./dist/react.dll.js&#39;)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样打包时页面就会引入&lt;code&gt;react.dll.js&lt;/code&gt;资源了，从而减少重复的资源打包。这种方式可以简单的理解为，抽出公共模块打包，然后引入&lt;/p&gt;

&lt;p&gt;3.&lt;code&gt;splitChunks&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以前&lt;code&gt;webpack&lt;/code&gt;拆分模块还会用&lt;code&gt;CommonsChunkPlugin&lt;/code&gt;，在&lt;code&gt;webpack4&lt;/code&gt;后，可以直接用&lt;code&gt;splitChunks&lt;/code&gt;来代替完成这项工作，在&lt;code&gt;optimization&lt;/code&gt;里面设置了&lt;code&gt;splitChunks&lt;/code&gt;后，打包分割出来的文件是默认压缩过的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;splitChunks: {
  chunks: &amp;quot;async&amp;quot;, // &amp;quot;initial&amp;quot; | &amp;quot;all&amp;quot; | &amp;quot;async&amp;quot;，对哪种代码进行分割
  minSize: 30000, // 超过minSize的包才做代码分割
  minChunks: 1, // 一个包至少被用了多少次的时候才进行代码分割
  maxAsyncRequests: 5, // 按需加载最多能加载多少个模块
  maxInitialRequests: 3, // 对于entry里面的文件做代码分割最多能生成多少个js文件
  automaticNameDelimiter: &#39;~&#39;, // 文件生成时的连接符
  name: true, // 为true的时候，打包出来的文件名由cacheGroups里面设置的为准
  cacheGroups: {
    vendors: {
      test: /[\\/]node_modules[\\/]/, // 匹配哪些需要分割的模块
      priority: -10, // 优先级
     	filename: &#39;vendors.js&#39;// 打包到一个叫vendors.js的文件
    },
    default: {
      minChunks: 2,
      priority: -20,
      reuseExistingChunk: true
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.&lt;code&gt;catch-loader&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在一些性能开销较大的&lt;code&gt;loader&lt;/code&gt;之前添加此 &lt;code&gt;loader&lt;/code&gt;，以将结果缓存到磁盘里，不做过多介绍&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
  module: {
    rules: [
      {
        test: /\.ext$/,
        use: [
          &#39;cache-loader&#39;,
          ...loaders
        ],
        include: path.resolve(&#39;src&#39;)
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.&lt;code&gt;HappyPack&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HappyPack&lt;/code&gt;使用&lt;code&gt;node&lt;/code&gt;多线程进行构建来提升构建的速度，使用情况较少&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const HappyPack = require(&#39;happypack&#39;)
const os = require(&#39;os&#39;)
const happyThreadPool = HappyPack.ThreadPool({
  size: os.cpus().length
})

......
plugins: [
  new HtmlWebPackPlugin({
    template: &#39;public/index.html&#39;,
    filename: &#39;index.html&#39;,
    inject: true
  }),
  new HappyPack({
    id: &#39;happyBabel&#39;,
    loaders: [{
      loader: &#39;babel-loader?cacheDirectory=true&#39;,
    }],
    threadPool: happyThreadPool,
    verbose: true,
  })
],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.&lt;code&gt;css&lt;/code&gt;的压缩&lt;/p&gt;

&lt;p&gt;对于&lt;code&gt;scss&lt;/code&gt;文件，一般来讲，依次配置&lt;code&gt;sass-loader&lt;/code&gt;、&lt;code&gt;css-loader&lt;/code&gt;、&lt;code&gt;style-loader&lt;/code&gt;来进行处理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  test: /\.scss$/,
  use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后加载完后的页面&lt;code&gt;css&lt;/code&gt;会以内联样式的形式签入到页面中。在&lt;code&gt;webpack4&lt;/code&gt;中使用&lt;code&gt;mini-css-extract-plugin&lt;/code&gt;插件来提取、压缩&lt;code&gt;css&lt;/code&gt;。首先将&lt;code&gt;style-loade&lt;/code&gt;用&lt;code&gt;MiniCssExtractPlugin.loader&lt;/code&gt;代替，然后使用&lt;code&gt;MiniCssExtractPlugin&lt;/code&gt;插件，打包出对应的文件，并在页面中引入对应的&lt;code&gt;css&lt;/code&gt;文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;)

......

{
  test: /\.scss$/,
  use: [MiniCssExtractPlugin.loader, &#39;css-loader&#39;, &#39;sass-loader&#39;]
}

new MiniCssExtractPlugin({
  filename: &#39;[name].[hash:5].css&#39;,
  chunkFilename: &#39;[id].[hash:5].css&#39;
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.图片的处理&lt;/p&gt;

&lt;p&gt;同样的，先用&lt;code&gt;file-loader&lt;/code&gt;解析图片保证webpack能处理，然后可以用&lt;code&gt;image-webpack-loader&lt;/code&gt;压缩图片，或者说用&lt;code&gt;url-loader&lt;/code&gt;将图片转为&lt;code&gt;base64&lt;/code&gt;编码的形式，不多赘述&lt;/p&gt;

&lt;p&gt;8.CDN加速
通常在打包中，把不变的一些静态文件放到&lt;code&gt;CDN&lt;/code&gt;上，可以直观地减小资源包大小，比如项目中用到了&lt;code&gt;clipboard.js&lt;/code&gt;，然后在模板&lt;code&gt;html&lt;/code&gt;中引入这个文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;script src=&amp;quot;https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.6/clipboard.min.js&amp;quot; defer&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般来讲，这种方式引入js静态文件，那么全局对象(如window)里面是会有对应的对象的，就可以直接引用对应的对象。当然还可以加上&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;externals: {
  clipboard: &#39;clipboard&#39;
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就保证了打包时不打包&lt;code&gt;clipboard&lt;/code&gt;，优化打包后的文件体积&lt;/p&gt;

&lt;p&gt;还有一种方式就是把所有的静态资源，如&lt;code&gt;js&lt;/code&gt;、&lt;code&gt;css&lt;/code&gt;都放在相应的&lt;code&gt;CDN&lt;/code&gt;上，在打包的&lt;code&gt;config&lt;/code&gt;中指定对应资源的&lt;code&gt;CDN&lt;/code&gt;域名，同样配置&lt;code&gt;externals&lt;/code&gt;。但其实这种方式有个很大的缺点就是，如果全部这样做的话，万一&lt;code&gt;CDN&lt;/code&gt;挂了，整个页面也就挂了&lt;/p&gt;

&lt;p&gt;9.按需加载&lt;/p&gt;

&lt;p&gt;以&lt;code&gt;react&lt;/code&gt;为例，使用&lt;code&gt;react-loadable&lt;/code&gt;来做按需加载，以前还有些其它方法这里就不赘述。主要是针对&lt;code&gt;react-router&lt;/code&gt;做一个处理，首先安装依赖&lt;code&gt;react-loadable&lt;/code&gt;，入口文件中封装一个&lt;code&gt;loading&lt;/code&gt;组件，用于页面加载时给一个提示，然后封装一个方法，用于异步加载这些组件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import Loadable from &#39;react-loadable&#39;
const Loading = (props) =&amp;gt; {
  return &amp;lt;div&amp;gt;这是一个loading组件&amp;lt;/div&amp;gt;
};
const asyncLoad = loader =&amp;gt; Loadable({
  loader,
  loading: Loading
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下有三个页面，&lt;code&gt;index&lt;/code&gt;、&lt;code&gt;about&lt;/code&gt;、&lt;code&gt;user&lt;/code&gt;，调用&lt;code&gt;asyncLoad&lt;/code&gt;，引入这些文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const Index = asyncLoad(() =&amp;gt; import(&#39;./pages/index&#39;))
const About = asyncLoad(() =&amp;gt; import(&#39;./pages/about&#39;))
const User = asyncLoad(() =&amp;gt; import(&#39;./pages/user&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再配置好路由，这样打包出来的&lt;code&gt;js&lt;/code&gt;文件就只会在对应页面或者说对应路由命中时加载了，从而提升页面的一个加载速度，当然也把打包出来的js文件进一步的分割，减小体积，当然需要注意的是，要在&lt;code&gt;webpack.config&lt;/code&gt;里面配置好&lt;code&gt;chunFilename(按需加载的chunk名字)&lt;/code&gt;，资源的&lt;code&gt;publickPath&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;Router&amp;gt;
  &amp;lt;Switch&amp;gt;
  	&amp;lt;Route path=&amp;quot;/&amp;quot; exact component={Index} /&amp;gt;
    &amp;lt;Route path=&amp;quot;/about/&amp;quot; component={About} /&amp;gt;
    &amp;lt;Route path=&amp;quot;/users/&amp;quot; component={User} /&amp;gt;
  &amp;lt;/Switch&amp;gt;
&amp;lt;/Router&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;webpack.config.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;output: {
  path: path.resolve(__dirname, &#39;./dist/&#39;),
  filename: &#39;[name].[hash:5].bundle.js&#39;,
  chunkFilename: &#39;[name].[hash:5].bundle.js&#39;,
  publicPath: &#39;/&#39;
},
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Webpack理解</title>
      <link>https://xtid.github.io/2020/webpack%E7%90%86%E8%A7%A3/</link>
      <pubDate>Sun, 23 Aug 2020 21:36:20 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/webpack%E7%90%86%E8%A7%A3/</guid>
      <description>&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt;是一个模块打包器，老一点的还有&lt;code&gt;gulp&lt;/code&gt;、&lt;code&gt;grunt&lt;/code&gt;等等，
他最显著的特点就是将文件视为一个个模块，通过设置入口文件&lt;code&gt;entry&lt;/code&gt;，加载不同类型的文件用不同&lt;code&gt;loader&lt;/code&gt;转换文件，
然后使用不同&lt;code&gt;plugin&lt;/code&gt;对文件处理，最后输出多个打包、分割后的文件&lt;/p&gt;

&lt;p&gt;首先有几个概念
1.entry：即&lt;code&gt;webpack&lt;/code&gt;打包的入口，告诉它应该从那个文件开始进行构建
2.output：设置打包后文件的输出路径以及如何命名这些文件
3.loader：处理那些非&lt;code&gt;javaScript&lt;/code&gt;文件，通过指定对应文件所需的对应&lt;code&gt;loader&lt;/code&gt;的处理，将文件转换为&lt;code&gt;webpack&lt;/code&gt;能够处理的有效模块
4.plugins：转换某些类型的模块，功能强大，可以做到打包优化，压缩以及各种各样的其它任务&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bundle&lt;/code&gt;：视为&lt;code&gt;webpack&lt;/code&gt;打包提取的模块生成的&lt;code&gt;js&lt;/code&gt;文件，将其它具体模块的代码传入其中执行，原本独立的模块文件，通过调用&lt;code&gt;__webpack_require__&lt;/code&gt;，合并到了&lt;code&gt;bundle&lt;/code&gt;中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function(modules) {
/******/    var installedModules = {};
/******/
/******/    var installedChunks = {
/******/        2: 0
/******/    };
/******/
/******/    function __webpack_require__(moduleId) {
/******/
/******/        if(installedModules[moduleId]) {
/******/            return installedModules[moduleId].exports;
/******/        }
/******/        var module = installedModules[moduleId] = {
/******/            i: moduleId,
/******/            l: false,
/******/            exports: {}
/******/        };
/******/
/******/        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/        module.l = true;
/******/
/******/        return module.exports;
/******/    }
/******/ })
/************************************************************************/
/******/ ({
	// 传入的模块
	......
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打包后的&lt;code&gt;bundle&lt;/code&gt;是一个立即执行的匿名函数，其参数就是打包后的模块，上面&lt;code&gt;__webpack_require__&lt;/code&gt;方法会首先判断当前模块&lt;code&gt;moduleId&lt;/code&gt;是否已经存在缓存&lt;code&gt;installedModules&lt;/code&gt;中，若是存在则直接返回。若是不存在，则会构造一个对象并将其同时存到&lt;code&gt;installedModules&lt;/code&gt;中和&lt;code&gt;module&lt;/code&gt;中&lt;/p&gt;

&lt;p&gt;&lt;code&gt;modules[moduleId].call(module.exports, module, module.exports, __webpack_require__)&lt;/code&gt;
这段代码首先执行当前模块的具体代码，传入&lt;code&gt;module&lt;/code&gt;，&lt;code&gt;module.exports&lt;/code&gt;，&lt;code&gt;__webpack_require__&lt;/code&gt;，递归调用&lt;code&gt;__webpack_require__&lt;/code&gt;处理每个模块种引入的其它模块
如以下形式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/***/ 0:
/***/ (function(module, exports, __webpack_require__) {
	......
	__webpack_require__(1);
	module.exports = __webpack_require__(2);
	......

/***/ })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个简单的bundle构建过程：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 引入相关依赖，对文件进行编译转换输出处理
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);
const parse = require(&#39;@babel/parser&#39;);
const traverse = require(&#39;@babel/traverse&#39;).default;
const babel = require(&#39;@babel/core&#39;);


let ID = 0;
// 读取文件信息，并获得当前js文件的依赖关系
function createAsset(filename) {
  // 获取文件，返回值是字符串
  const content = fs.readFileSync(filename, &#39;utf-8&#39;);

  // 将字符串转为ast
  const ast = parse.parse(content, {
    sourceType: &#39;module&#39;
  });

  //用来存储 文件所依赖的模块，简单来说就是，当前js文件 import 了哪些文件，都会保存在这个数组里
  const dependencies = [];

  //遍历当前ast（抽象语法树）
  traverse(ast, {
    //找到有 import语法 的对应节点
    ImportDeclaration: ({ node }) =&amp;gt; {
      //把当前依赖的模块加入到数组中
      dependencies.push(node.source.value);
    }
  });

  //模块的id 从0开始， 相当一个js文件 可以看成一个模块
  const id = ID++;

  //这边主要把ES6 的代码转成 ES5
  const { code } = babel.transformFromAstSync(ast, null, {
    presets: [&#39;@babel/preset-env&#39;]
  });

  return {
    id,
    filename,
    dependencies,
    code
  };
}

// 从入口开始分析所有依赖项，形成依赖图，采用广度遍历
function createGraph(entry) {
  const mainAsset = createAsset(entry);
    
  const queue = [mainAsset];

  for (const asset of queue) {
    const dirname = path.dirname(asset.filename);
    // 新增一个属性来保存子依赖项的数据
    asset.mapping = {};
    asset.dependencies.forEach(relativePath =&amp;gt; {
      const absolutePath = path.join(dirname, relativePath);
      //获得子依赖（子模块）的依赖项、代码、模块id，文件名
      const child = createAsset(absolutePath);
      //给子依赖项赋值，
      asset.mapping[relativePath] = child.id;
      //将子依赖也加入队列中，广度遍历
      queue.push(child);
    });
  }
  return queue;
}

//根据生成的依赖关系图，生成对应环境能执行的代码，目前是生产浏览器可以执行的
function bundle(graph) {
  let modules = &#39;&#39;;

  //循环依赖关系，并把每个模块中的代码存在function作用域里
  graph.forEach(mod =&amp;gt; {
    modules += `${mod.id}:[
      function (require, module, exports){
        ${mod.code}
      },
      ${JSON.stringify(mod.mapping)},
    ],`;
  });

  //require, module, exports 是 cjs的标准不能再浏览器中直接使用，所以这里模拟cjs模块加载，执行，导出操作。
  const result = `
    (function(modules){
      //创建require函数， 它接受一个模块ID（这个模块id是数字0，1，2） ，它会在我们上面定义 modules 中找到对应是模块.
      function __webpack_require__(id){
        const [fn, mapping] = modules[id];
        function localRequire(relativePath){
          //根据模块的路径在mapping中找到对应的模块id
          return __webpack_require__(mapping[relativePath]);
        }
        const module = {exports:{}};
        //执行每个模块的代码。
        fn(localRequire,module,module.exports);
        return module.exports;
      }
      //执行入口文件，
      __webpack_require__(0);
    })({${modules}})
  `;

  return result;
}

// 入口文件
const graph = createGraph(&#39;./entry.js&#39;);
// 文件内容
const ret = bundle(graph);

// 打包生成文件
fs.writeFileSync(&#39;./bundle.js&#39;, ret);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;loader&lt;/code&gt;，通过设置对应的&lt;code&gt;rule&lt;/code&gt;，使用不同的&lt;code&gt;loader&lt;/code&gt;来转换、处理不同的组件，比如&lt;code&gt;css&lt;/code&gt;文件使用&lt;code&gt;css-loader&lt;/code&gt;以及&lt;code&gt;style-loader&lt;/code&gt;来处理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  test: /\.css$/,
  loader: &#39;style-loader!css-loader&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外，还有一种内联&lt;code&gt;loader&lt;/code&gt;的形式，即&lt;code&gt;import loader from &#39;......&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;两种方式处理的顺序也不同，大致流程为
1.&lt;code&gt;webpack&lt;/code&gt;启动后，创建新的&lt;code&gt;compilation&lt;/code&gt;
2.实例化&lt;code&gt;rules&lt;/code&gt;
3.解析&lt;code&gt;inline loaders&lt;/code&gt;
4.解析&lt;code&gt;config&lt;/code&gt;配置里面的&lt;code&gt;loaders&lt;/code&gt;
5.组合这两种形式的&lt;code&gt;loader&lt;/code&gt;，最终输出上诉第一种形式的配置
6.使用&lt;code&gt;Loader-runner&lt;/code&gt;按配置执行&lt;code&gt;loader&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以下简单写一个&lt;code&gt;loader&lt;/code&gt;，首先写一个方法用于加载&lt;code&gt;loader&lt;/code&gt;，并处理传入的模块，然后返回处理完了之后的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let source = ...... // source为获取到的模块的代码
function loaderModule(loaderName) {
  // 获取loader路径
  const loaderPath = path.join(process.cwd(), loaderName)
  const loader = require(loaderPath)
  source = loader.call(_this, source)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义一个规则&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;rules: [{
  test:/\.js/,
  use:[
    &#39;./loaderModule.js&#39;, // loader的路径
  ]
}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行的时候遍历&lt;code&gt;rules&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;for (let i = rules.length - 1; i &amp;gt;= 0; i--) {
  const { test, use } = rules[i]
  if (test.test(modulePath)) {
    // 使用多个loader
    if (Array.isArray(use)) {
      for (let j = use.length - 1; j &amp;gt;= 0; j--) {
        loaderModule(use[j])
      }
    } else if (typeof use === &#39;string&#39;) {
      loaderModule(use)
      // 带参数型的loader
    } else if (use instanceof Object) {
      loaderModule(use.loader, {
        query: use.options
      })
    }
  }
}

// loaderModule.js内容
// loader-utils是webpack一个工具类，用于解析loader，获取配置的一些loader参数
const loaderUtils = require(&#39;loader-utils&#39;)

// 这个简单的loader会将js文件里面的hello字符串替换成word
module.exports = function (source) {
  const optionsName = loaderUtils.getOptions(this) &amp;amp;&amp;amp; loaderUtils.getOptions(this).name || &#39;world&#39;
  return source.replace(/hello/g, optionsName)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面是一个同步的&lt;code&gt;loader&lt;/code&gt;，如果想写一个异步的&lt;code&gt;loader&lt;/code&gt;，可以在&lt;code&gt;loader&lt;/code&gt;内部调用&lt;code&gt;async&lt;/code&gt;方法，然后在处理之后调用对应的回调方法处理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = function (source) {
  const optionsName = loaderUtils.getOptions(this) &amp;amp;&amp;amp; loaderUtils.getOptions(this).name || &#39;world&#39;
  cosnt callback = this.async()

  // 操作完了之后，调用callback返回结果进入下一个loader
  asyncOperation(source, optionsName, function(err, result) {
    if（err）return callback(err)
    callback(err, result)
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不用上面的方式，返回一个&lt;code&gt;promise&lt;/code&gt;也是可以的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = function (source) {
  const optionsName = loaderUtils.getOptions(this) &amp;amp;&amp;amp; loaderUtils.getOptions(this).name || &#39;world&#39;
  return new Promise(resolve =&amp;gt; {
    asyncOperation(source, function(err, result) {
      if (err) resolve(err)
      resolve(err, result)
    })
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;plugin&lt;/code&gt;
&lt;code&gt;plugin&lt;/code&gt;进一步拓展了&lt;code&gt;webpack&lt;/code&gt;的功能，比如打包优化和压缩，清空当前项目的目录，重新定义环境变量，将代码输出到某个文件，提取功能模块等等&lt;/p&gt;

&lt;p&gt;定义一个&lt;code&gt;plugin&lt;/code&gt;的时候，首先要提供一个&lt;code&gt;apply&lt;/code&gt;方法，接受一个&lt;code&gt;compiler&lt;/code&gt;对象，然后注册对应的钩子函数，在回调里面拿到对应参数，然后处理
以下定义一个&lt;code&gt;plugin&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const path = require(&#39;path&#39;)
const fs = require(&#39;fs&#39;)
const cheerio = require(&#39;cheerio&#39;)

class BasePlugin {
  constructor(options){
    // 插件的参数，filename、template等
    this.options = options
  }
  apply(compiler) {
    // 注册afterEmit钩子函数
    compiler.hooks.afterEmit.tap(&#39;BasePlugin&#39;, (compilation) =&amp;gt; {
      // 2. 根据模板读取html文件内容
      const result = fs.readFileSync(this.options.template, &#39;utf-8&#39;)
      
      // 3. 使用 cheerio 来分析 HTML
      let $ = cheerio.load(result)
    
      // 4. 创建 script 标签后插入HTML中
      // compilation.assets代表所有输出的资源文件
      Object.keys(compilation.assets).forEach(item =&amp;gt; {
        $(`&amp;lt;script src=&amp;quot;/${item}&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;`).appendTo(&#39;body&#39;)
      })
    
      // 5. 转换成新的HTML并写入到 dist 目录中
      fs.writeFileSync(path.join(process.cwd(), &#39;dist&#39;, this.options.filename), $.html())
    })
  } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;compiler&lt;/code&gt;对象包含了&lt;code&gt;webpack&lt;/code&gt;环境所有的的配置信息，包含&lt;code&gt;options&lt;/code&gt;，&lt;code&gt;loaders&lt;/code&gt;，&lt;code&gt;plugins&lt;/code&gt;这些信息，这个对象在&lt;code&gt;webpack&lt;/code&gt;启动时候被实例化，它是全局唯一的，可以简单地把它理解为&lt;code&gt;webpack&lt;/code&gt;实例，&lt;code&gt;compilation&lt;/code&gt;对象包含了当前的模块资源、编译生成资源、变化的文件等。当&lt;code&gt;webpack&lt;/code&gt;以开发模式运行时，每当检测到一个文件变化，&lt;code&gt;compilation&lt;/code&gt;就会被重新构建，其它的一些&lt;a href=&#34;https://www.webpackjs.com/api/compiler-hooks/#hooks&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;钩子函数&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;顺便总结一下，实现一个简单的&lt;code&gt;webpack&lt;/code&gt;的步骤
1.定一个基础对象，构造方法里面传入&lt;code&gt;entry&lt;/code&gt;、&lt;code&gt;output&lt;/code&gt;、&lt;code&gt;rules&lt;/code&gt;、&lt;code&gt;plugins&lt;/code&gt;等属性
2.然后定义一系列钩子函数，在&lt;code&gt;webpack&lt;/code&gt;执行中可以调用这些钩子函数做处理，
3.开始执行，初始化对应的钩子函数，传入&lt;code&gt;entry&lt;/code&gt;等相关信息
4.拿到文件源码信息，使用&lt;code&gt;loader&lt;/code&gt;处理，将代码转换成&lt;code&gt;ast&lt;/code&gt;形式
5.&lt;code&gt;traverse&lt;/code&gt;将&lt;code&gt;ast&lt;/code&gt;代码中的&lt;code&gt;require&lt;/code&gt;替换为&lt;code&gt;__webpack_require__&lt;/code&gt;，添加新的&lt;code&gt;module&lt;/code&gt;信息
6.递归处理每一个依赖，重复上面的步骤
7.初始化&lt;code&gt;plugin&lt;/code&gt;，并对文件做处理
8.输入到指定目录
9.客户端/浏览器运行时执行&lt;/p&gt;

&lt;p&gt;参考链接&lt;/p&gt;

&lt;p&gt;1.&lt;a href=&#34;https://juejin.im/post/6844903957769224206&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;webpack原理&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&#34;https://www.webpackjs.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;webpack官方文档&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Babel简介</title>
      <link>https://xtid.github.io/2020/babel%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sun, 23 Aug 2020 21:32:52 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/babel%E7%AE%80%E4%BB%8B/</guid>
      <description>

&lt;h3 id=&#34;1-babel-简介&#34;&gt;1.babel 简介&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Babel是现代JavaScript语法转换器，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中，包括不限于: eslint jsx vue-template等等。他能为你做的：语法转换、通过 Polyfill 方式在目标环境中添加缺失的特性、源码转换。可以说，通过babel，我们可以使用最新的语法或者特性专注的开发业务，而不用将精力花在代码的兼容上&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;2-babel的解析流程&#34;&gt;2.babel的解析流程&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/xtid/blog/blob/master/static/img/deal_process.png&#34; alt=&#34;babel处理流程&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-1词法解析&#34;&gt;2.1词法解析&lt;/h4&gt;

&lt;p&gt;首先由入口文件&lt;code&gt;@babel/core&lt;/code&gt;引入各种配置文件以及解析的模块，其中负责解析基本语法的为&lt;code&gt;parse&lt;/code&gt;模块，其中就定义了&lt;code&gt;词法解析器Tokenizer&lt;/code&gt;，可以看出初始化时会有一个&lt;code&gt;tokens&lt;/code&gt;数组，在这个阶段会把字符串形式的代码转换为一个数组，&lt;code&gt;tokens可以视为由拆分为各个片段组成的数组&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Tokenizer extends LocationParser {
  constructor(options, input) {
    super();
    this.tokens = [];
    this.state = new State();
    this.state.init(options);
    this.input = input;
    this.length = input.length;
    this.isLookahead = false;
  }
	
  ....
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;Tokenizer&lt;/code&gt;定义中还有一些其它的方法，他们会对各种语法字符串进行一个遍历过滤，比如跳过空格字符串，比如跳过注释等等&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;skipSpace() {
  loop: while (this.state.pos &amp;lt; this.length) {
    const ch = this.input.charCodeAt(this.state.pos);
    .
    .
    .
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后会把符合规则的语法字符串加入到&lt;code&gt;tokens&lt;/code&gt;数组中，也就生成代码拆分为各个片段组成的数组&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;pushToken(token) {
  this.tokens.length = this.state.tokensLength;
  this.tokens.push(token);
  ++this.state.tokensLength;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.log(&#39;我是一段语法&#39;) =&amp;gt; [&#39;console&#39;, &#39;log&#39;, &#39;(&#39;, &#39;&amp;quot;我是一段语法&amp;quot;&#39;, &#39;)&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-2语法解析&#34;&gt;2.2语法解析&lt;/h4&gt;

&lt;p&gt;当生成完&lt;code&gt;tokens&lt;/code&gt;，则进入到语法解析阶段，同样可以看见在&lt;code&gt;parse&lt;/code&gt;模块中定一个了一个&lt;code&gt;Node&lt;/code&gt;对象，这个对象定义了一些属性，当然还有个私有的&lt;code&gt;_clone&lt;/code&gt;方法，用于表示将要生成的&lt;code&gt;AST&lt;/code&gt;中节点的位置、名称、类型等等信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Node {
  constructor(parser, pos, loc) {
    this.type = &amp;quot;&amp;quot;;
    this.start = pos;
    this.end = 0;
    this.loc = new SourceLocation(loc);
    if (parser &amp;amp;&amp;amp; parser.options.ranges) this.range = [pos, 0];
    if (parser &amp;amp;&amp;amp; parser.filename) this.loc.filename = parser.filename;
  }

  __clone() {
    .
    .
    .
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后会定义相应的&lt;code&gt;Parse&lt;/code&gt;，遍历处理不同的&lt;code&gt;tokens&lt;/code&gt;字段，比如&lt;code&gt;ImportDeclaration&lt;/code&gt;用于import语法，导入模块；&lt;code&gt;VariableDeclarator&lt;/code&gt;用于处理表示是什么类型的变量声明，比如&lt;code&gt;var、let、const&lt;/code&gt;；&lt;code&gt;FunctionDeclaration&lt;/code&gt;用于处理函数声明，非函数表达式，其它的就不多赘述。最后则会将这个词法数组转换为&lt;code&gt;AST(抽象语法树)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var add = function(a, b) {
  return  a + b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后生成的&lt;code&gt;AST&lt;/code&gt;简易版本如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  &amp;quot;type&amp;quot;: &amp;quot;Program&amp;quot;,
  &amp;quot;body&amp;quot;: [{
    &amp;quot;type&amp;quot;: &amp;quot;VariableDeclaration&amp;quot;,
    &amp;quot;identifierName&amp;quot;: &amp;quot;add&amp;quot;,
    &amp;quot;init&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;ArrowFunctionExpression&amp;quot;,
      &amp;quot;params&amp;quot;: [{
          &amp;quot;type&amp;quot;: &amp;quot;identifier&amp;quot;,
          &amp;quot;identifierName&amp;quot;: &amp;quot;a&amp;quot;
        },
        {
          &amp;quot;type&amp;quot;: &amp;quot;identifier&amp;quot;,
          &amp;quot;identifierName&amp;quot;: &amp;quot;b&amp;quot;
        }
      ],
      &amp;quot;body&amp;quot;: {
        &amp;quot;type&amp;quot;: &amp;quot;BinaryExpression&amp;quot;,
        &amp;quot;left&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;identifier&amp;quot;,
          &amp;quot;identifierName&amp;quot;: &amp;quot;a&amp;quot;
        },
        &amp;quot;operator&amp;quot;: &amp;quot;+&amp;quot;,
        &amp;quot;right&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;identifier&amp;quot;,
          &amp;quot;identifierName&amp;quot;: &amp;quot;b&amp;quot;
        }
      }
    }
  }]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出这个语法树包含了整个语法的一个层级关系，并且标注了他们的名称、类型以及位置&lt;/p&gt;

&lt;h4 id=&#34;2-3traverser&#34;&gt;2.3Traverser&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Traverser&lt;/code&gt;会对生成好&lt;code&gt;AST&lt;/code&gt;进行一个遍历，在此过程中对节点进行添加、删除等等操作，这也是其他插件将要处理的地方，通过这些插件，也可以处理不同的&lt;code&gt;AST&lt;/code&gt;语法树，然后转换符合相应规则的代码，比如&lt;code&gt;Taro&lt;/code&gt;，就可以视为将&lt;code&gt;React&lt;/code&gt;代码转换成小程序对应代码的一个插件。&lt;code&gt;Traverser&lt;/code&gt;中会引入&lt;code&gt;visitors&lt;/code&gt;，用它来进行一个深度遍历操作；&lt;code&gt;Path&lt;/code&gt;用于关联各个节点，这样使得节点操作简单，例如：&lt;/p&gt;

&lt;p&gt;例如，如果有下面这样一个节点及其子节点︰&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  type: &amp;quot;ArrowFunctionExpression&amp;quot;,
  id: {
    type: &amp;quot;Identifier&amp;quot;,
    name: &amp;quot;a&amp;quot;
  },
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将子节点 &lt;code&gt;Identifier&lt;/code&gt; 表示为一个路径（Path）的话，看起来是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  &amp;quot;parent&amp;quot;: {
    &amp;quot;type&amp;quot;: &amp;quot;ArrowFunctionExpression&amp;quot;,
    &amp;quot;id&amp;quot;: {...},
    ....
  },
  &amp;quot;node&amp;quot;: {
    &amp;quot;type&amp;quot;: &amp;quot;Identifier&amp;quot;,
    &amp;quot;name&amp;quot;: &amp;quot;a&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Scope&lt;/code&gt;用来表示树中各个节点的一个作用域关系，就好像&lt;code&gt;js&lt;/code&gt;语法中，创建变量、函数时所呈现的一个作用域效果，在&lt;code&gt;babel&lt;/code&gt;中，新添加的引用或者变量名，&lt;code&gt;Scope&lt;/code&gt;表示的时候需要体现出节点的路径，节点间的关系，如以下形式:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  path: path,
  block: path.node,
  parentBlock: path.parent,
  parent: parentScope,
  bindings: [...]
  .
  .
  .
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有个很重要的概念&lt;code&gt;Bindings&lt;/code&gt;，&lt;code&gt;Bindings&lt;/code&gt;可以获取当前作用域下所有的标识符，其返回的信息包括节点的&lt;code&gt;标识符&lt;/code&gt;、&lt;code&gt;scope&lt;/code&gt;、&lt;code&gt;path&lt;/code&gt;、&lt;code&gt;引用&lt;/code&gt;等等信息，通过对这些属性的操作，达到对节点信息的一个更改&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export class Binding {
  identifier: t.Identifier;
  scope: Scope;
  path: NodePath;
  kind: &amp;quot;var&amp;quot; | &amp;quot;let&amp;quot; | &amp;quot;const&amp;quot; | &amp;quot;module&amp;quot;;
  referenced: boolean;
  references: number;              // 被引用的数量
  referencePaths: NodePath[];      // 获取所有应用该标识符的节点路径
  constant: boolean;               // 是否是常量
  constantViolations: NodePath[];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-4transform&#34;&gt;2.4Transform&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;transform&lt;/code&gt;会对抽象语法树进行又一次遍历，针对已经处理好的&lt;code&gt;AST&lt;/code&gt;做进一步处理，如对代码的更改，对节点的操作、节点的增删改查、压缩代码、删除注释等等。得到最终的一个&lt;code&gt;AST&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-5生成代码&#34;&gt;2.5生成代码&lt;/h4&gt;

&lt;p&gt;得到上一步生成的&lt;code&gt;AST&lt;/code&gt;之后，会调用对应的代码生成器代码，通过递归遍历生成最终的代码，其中遇到不同的节点类型时，会做不同的处理，比如函数类型、参数定义类型、代码块类型等等&lt;/p&gt;

&lt;h3 id=&#34;3-babel里面的一些依赖包&#34;&gt;3.babel里面的一些依赖包&lt;/h3&gt;

&lt;h4 id=&#34;3-1-babel-core&#34;&gt;3.1@babel/core&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;@babel/core&lt;/code&gt;整个&lt;code&gt;babel&lt;/code&gt;的一个核心，也算是&lt;code&gt;babel&lt;/code&gt;的一个入口，它会加载和处理用户定义的配置，加载各种各样的插件；调用&lt;code&gt;Parser&lt;/code&gt;进行语法解析，生成&lt;code&gt;Tokens&lt;/code&gt;以及&lt;code&gt;AST&lt;/code&gt;；调用&lt;code&gt;Traverser&lt;/code&gt;遍历&lt;code&gt;AST&lt;/code&gt;，进行一个转换；最后&lt;code&gt;generator&lt;/code&gt;生成源代码&lt;/p&gt;

&lt;h4 id=&#34;3-2插件&#34;&gt;3.2插件&lt;/h4&gt;

&lt;p&gt;语法插件：&lt;code&gt;babel&lt;/code&gt;有很多语法插件，用于支持&lt;code&gt;JavaScript&lt;/code&gt;的各种语法特性，在解析的时候会用的到，通常其形式为&lt;code&gt;@babel/plugin-syntax-*&lt;/code&gt;，比如&lt;code&gt;babel-plugin-syntax-dynamic-import&lt;/code&gt;就是用来处理&lt;code&gt;import&lt;/code&gt;语法的一个插件&lt;/p&gt;

&lt;p&gt;转换插件： 用于对 &lt;code&gt;AST&lt;/code&gt; 进行转换, 实现转换为&lt;code&gt;ES5&lt;/code&gt;代码、压缩、功能增强等目的，&lt;code&gt;babel&lt;/code&gt;仓库将转换插件划分为两种(只是命名上的区别)：&lt;/p&gt;

&lt;p&gt;如&lt;code&gt;@babel/plugin-transform-*&lt;/code&gt;： &lt;code&gt;babel&lt;/code&gt;中的一个转换插件&lt;/p&gt;

&lt;p&gt;预定义的插件：插件集合或者分组，可设置项目内所用插件的使用场景，主要方便用户对插件进行管理和使用。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@babel/preset-env&lt;/code&gt;：&lt;code&gt;preset-env&lt;/code&gt;是ES语法插件的合集，在根目录下创建&lt;code&gt;.babelrc&lt;/code&gt;配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt; {
   &amp;quot;presets&amp;quot;: [
     [&amp;quot;@babel/preset-env&amp;quot;, {
       &amp;quot;modules&amp;quot;: false,
       &amp;quot;targets&amp;quot;: {
         &amp;quot;browsers&amp;quot;: [&amp;quot;&amp;gt; 1%&amp;quot;, &amp;quot;last 2 versions&amp;quot;, &amp;quot;not ie &amp;lt;= 8&amp;quot;]
       },
       &amp;quot;useBuiltIns&amp;quot;: false,
       &amp;quot;corejs&amp;quot;: false
     }]
   ]
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;targets&lt;/code&gt;生成指定环境的代码，&lt;code&gt;useBuiltIns&lt;/code&gt;配合&lt;code&gt;@babel/polyfill&lt;/code&gt;使用，当然最新版的&lt;code&gt;babel&lt;/code&gt;可直接使用&lt;code&gt;corejs&lt;/code&gt;，填上对应的数值就行，&lt;code&gt;modules&lt;/code&gt;表示是否将代码ES6的模块语法转换为另一种类型或标准，比如&lt;code&gt;amd&lt;/code&gt;、&lt;code&gt;commonjs&lt;/code&gt;等&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@babel/polyfill&lt;/code&gt;顾名思义，在&lt;code&gt;babel&lt;/code&gt;转化的过程中，对于一些无法处理的特性或者属性，使用&lt;code&gt;@babel/polyfill&lt;/code&gt;来对这些功能进行处理；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@babel/runtime&lt;/code&gt;一般应用于两种场景：开发类库/工具（生成不污染全局空间和内置对象原型的代码）、借助 &lt;code&gt;@babel/runtime&lt;/code&gt; 中帮助函数（helper function）移除冗余工具函数，在最新的版本中，完全可以用&lt;code&gt;@babel/runtime&lt;/code&gt;代替&lt;code&gt;@babel/polyfill&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;3-3辅助开发工具&#34;&gt;3.3辅助开发工具&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;@babel/template&lt;/code&gt;： 某些场景直接操作&lt;code&gt;AST&lt;/code&gt;太麻烦，就比如我们直接操作&lt;code&gt;DOM&lt;/code&gt;一样，所以&lt;code&gt;babel&lt;/code&gt;实现了这么一个简单的模板引擎，可以将字符串代码转换为&lt;code&gt;AST&lt;/code&gt;。比如在生成一些辅助代码&lt;code&gt;(helper)&lt;/code&gt;时会用到这个库&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@babel/types&lt;/code&gt;： 主要用途是在创建&lt;code&gt;AST&lt;/code&gt;的过程中判断各种语法的类型。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@babel/helper-*&lt;/code&gt;： 一些辅助器，用于辅助插件开发，例如简化&lt;code&gt;AST&lt;/code&gt;操作&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@babel/helper&lt;/code&gt;： 辅助代码，单纯的语法转换可能无法让代码运行起来，比如低版本浏览器无法识别&lt;code&gt;class&lt;/code&gt;关键字，这时候需要添加辅助代码，对&lt;code&gt;class&lt;/code&gt;进行模拟。&lt;/p&gt;

&lt;h4 id=&#34;4-参考链接&#34;&gt;4.参考链接&lt;/h4&gt;

&lt;p&gt;1.&lt;a href=&#34;https://juejin.im/post/5d94bfbf5188256db95589be&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;深入浅出Babel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&#34;https://www.babeljs.cn/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;babel中文网&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.&lt;a href=&#34;https://github.com/jamiebuilds/babel-handbook&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;babel-handbook&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Vue中的patch</title>
      <link>https://xtid.github.io/2020/vue%E4%B8%AD%E7%9A%84patch/</link>
      <pubDate>Thu, 13 Aug 2020 00:12:17 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/vue%E4%B8%AD%E7%9A%84patch/</guid>
      <description>&lt;p&gt;在生成&lt;code&gt;vnode&lt;/code&gt;之后，可以通过&lt;code&gt;patch&lt;/code&gt;方法创建&lt;code&gt;DOM&lt;/code&gt;元素、进行&lt;code&gt;diff&lt;/code&gt;更新&lt;code&gt;DOM&lt;/code&gt;元素、销毁&lt;code&gt;DOM&lt;/code&gt;元素&lt;/p&gt;

&lt;p&gt;1.首先是第一次初始化时，生成了&lt;code&gt;vnode&lt;/code&gt;后，在&lt;code&gt;_update&lt;/code&gt;方法中调用&lt;code&gt;patch&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;vm.$el = vm.__patch__(
  vm.$el, vnode, hydrating, false
  // undefined
  vm.$options._parentElm,
  // undefined
  vm.$options._refElm
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时&lt;code&gt;vm.$el&lt;/code&gt;是挂载的根元素，&lt;code&gt;vnode&lt;/code&gt;是根元素对应的虚拟&lt;code&gt;Dom&lt;/code&gt;元素&lt;/p&gt;

&lt;p&gt;&lt;code&gt;patch&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    // 如果更新后的VNode不存在
    // 直接销毁旧的节点
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];
		
    if (isUndef(oldVnode)) {
      // 如果旧节点不存在
      // 创建VNode对应的元素
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      // oldValue是否是真实的DOM元素
      var isRealElement = isDef(oldVnode.nodeType);
      // 新旧节点相同
      if (!isRealElement &amp;amp;&amp;amp; sameVnode(oldVnode, vnode)) {
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // oldVNode类型为元素类型
          if (oldVnode.nodeType === 1 &amp;amp;&amp;amp; oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
      		......
          // 创建一个div空元素
          oldVnode = emptyNodeAt(oldVnode);
        }
				// oldElm代表真实的DOM元素
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);

        createElm(
          vnode,
          insertedVnodeQueue,
          oldElm._leaveCb ? null : parentElm$1,
          nodeOps.nextSibling(oldElm)
        );
				......
        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中调用了一个重要的方法&lt;code&gt;createElm&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  function createElm (
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
		......
    // VNode如果是一个组件，调用createComponent
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    // 如果tag是一个字符串，但非平台标签，也非自定义组件，抛错
    if (isDef(tag)) {
      if (process.env.NODE_ENV !== &#39;production&#39;) {
        if (data &amp;amp;&amp;amp; data.pre) {
          creatingElmInVPre++;
        }
        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn(
            &#39;Unknown custom element: &amp;lt;&#39; + tag + &#39;&amp;gt; - did you &#39; +
            &#39;register the component correctly? For recursive components, &#39; +
            &#39;make sure to provide the &amp;quot;name&amp;quot; option.&#39;,
            vnode.context
          );
        }
      }
			
      // setScope用户设置scoped CSS
      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

        var appendAsTree = isDef(data) &amp;amp;&amp;amp; isTrue(data.appendAsTree);
        if (!appendAsTree) {
          if (isDef(data)) {
            // 调用invokeCreateHooks
            // 此方法会处理directives、ref、attrs、class、domProps、on、style和show等一些属性
            // 如果VNode上有对应的狗子函数则会直接执行
            // 如果有insert方法，则把VNode添加到insertedVnodeQueue数组
            invokeCreateHooks(vnode, insertedVnodeQueue);
          }
          insert(parentElm, vnode.elm, refElm);
        }
      	// 递归处理子节点
        createChildren(vnode, children, insertedVnodeQueue);
        if (appendAsTree) {
          if (isDef(data)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
          }
          insert(parentElm, vnode.elm, refElm);
        }
      }

      if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; data &amp;amp;&amp;amp; data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      // 如果非保留标签，非自定义组件，并且是注释节点
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      // 创建文本节点
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在初始化时，&lt;code&gt;parentElm&lt;/code&gt;指的是&lt;code&gt;body&lt;/code&gt;，&lt;code&gt;refElm&lt;/code&gt;是当前节点的下一个兄弟元素&lt;/p&gt;

&lt;p&gt;2.上面说的是&lt;code&gt;Vue&lt;/code&gt;第一次加载页面时patch的操作，还有当页面绑定的数据修改后，&lt;code&gt;Vue&lt;/code&gt;对页面的更新，其核心也就是&lt;code&gt;diff&lt;/code&gt;算法了
在页面绑定的数据发生改变时，&lt;code&gt;watcher&lt;/code&gt;会调用&lt;code&gt;updateComponent&lt;/code&gt;，然后调用&lt;code&gt;vm._render&lt;/code&gt;生成最新的&lt;code&gt;vnode&lt;/code&gt;，
然后&lt;code&gt;vm._update&lt;/code&gt;会讲新旧&lt;code&gt;vnode&lt;/code&gt;传入&lt;code&gt;patch&lt;/code&gt;方法中进行diff处理，其实总体流程还是一样，只不过传入的参数不同&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
  ......

  let isInitialPatch = false;
  const insertedVnodeQueue = [];

  if (isUndef(oldVnode)) {
    isInitialPatch = true;
    createElm(vnode, insertedVnodeQueue, parentElm, refElm);
  } else {
     // oldValue是不是vnode真实的dom元素
    const isRealElement = isDef(oldVnode.nodeType);
    // 判断是否为同一vnode
    // 如果是统一vnode，调用patchVnode
    // sameVnode判断依据为两个vnode的key相同，tag名相同，type，data，attrs如果有的话必须相同
    // 如果可以复用，patchVnode
    if (!isRealElement &amp;amp;&amp;amp; sameVnode(oldVnode, vnode)) {
      patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
    } else {
      ......
    }
  }

  invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
  return vnode.elm
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;patchVnode&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
  // 如果新旧vnode相同，return
  if (oldVnode === vnode) {
    return
  }                           
  // vnode应的dom指向oldVnode的dom             
  const elm = vnode.elm = oldVnode.elm;

  ......

  // 如果新旧节点都是静态根节点
  // key也相同
  // 如果renderStatic或者markOnce
  if (isTrue(vnode.isStatic) &amp;amp;&amp;amp;
    isTrue(oldVnode.isStatic) &amp;amp;&amp;amp;
    vnode.key === oldVnode.key &amp;amp;&amp;amp;
    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
  ) {
    vnode.componentInstance = oldVnode.componentInstance;
    return
  }

  let i;
  const data = vnode.data;
  // 调用prepatch钩子函数
  if (isDef(data) &amp;amp;&amp;amp; isDef(i = data.hook) &amp;amp;&amp;amp; isDef(i = i.prepatch)) {
    i(oldVnode, vnode);
  }

  // 新旧vnode children
  const oldCh = oldVnode.children;
  const ch = vnode.children;
  // data不为空，即节点相关的属性不为空
  // isPatchable用于判断vnode的tag是否为空
  if (isDef(data) &amp;amp;&amp;amp; isPatchable(vnode)) {
    // 更新元素上相关各种属性
    for (i = 0; i &amp;lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode);
    // 调用update钩子函数
    if (isDef(i = data.hook) &amp;amp;&amp;amp; isDef(i = i.update)) i(oldVnode, vnode);
  }
  // 判断vnode是否为文本节点
  if (isUndef(vnode.text)) {
    // 新旧节点都有子元素
    if (isDef(oldCh) &amp;amp;&amp;amp; isDef(ch)) {
      // 子元素不相同
      // 调用updateChildren
      if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
      // 如果新的vnode有子元素，旧的没有
    } else if (isDef(ch)) {
      // 如果旧节点是文本节点，则置空
      if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &#39;&#39;);
      // addVnodes把ch中的元素依次添加到elm中
      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      // 如果新节点vnode没有子元素
    } else if (isDef(oldCh)) {
      // 删除旧节点的子元素
      removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      // 以上如果都不满足，如果oldVnode是文本结点，则直接内容置空
    } else if (isDef(oldVnode.text)) {
      nodeOps.setTextContent(elm, &#39;&#39;);
    }
    // 如果vnode是文本结点，且text有变化，则修改elm的文本内容
  } else if (oldVnode.text !== vnode.text) {
    nodeOps.setTextContent(elm, vnode.text);
  }
  // 调用postpatch钩子函数
  if (isDef(data)) {
    if (isDef(i = data.hook) &amp;amp;&amp;amp; isDef(i = i.postpatch)) i(oldVnode, vnode);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来重点是&lt;code&gt;updateChildren&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
  // 定义了一些索引以及起始节点的信息
  let oldStartIdx = 0
  let newStartIdx = 0
  let oldEndIdx = oldCh.length - 1
  let oldStartVnode = oldCh[0]
  let oldEndVnode = oldCh[oldEndIdx]
  let newEndIdx = newCh.length - 1
  let newStartVnode = newCh[0]
  let newEndVnode = newCh[newEndIdx]
  let oldKeyToIdx, idxInOld, vnodeToMove, refElm

  // removeOnly为false，transition-group中为true
  const canMove = !removeOnly

  if (process.env.NODE_ENV !== &#39;production&#39;) {
    checkDuplicateKeys(newCh)
  }
  // 新旧节点都未遍历完
  while (oldStartIdx &amp;lt;= oldEndIdx &amp;amp;&amp;amp; newStartIdx &amp;lt;= newEndIdx) {
    // 如果oldStartVnode未定义
    if (isUndef(oldStartVnode)) {
      // oldCh向后移一位
      oldStartVnode = oldCh[++oldStartIdx]
      // 如果oldEndVnode未定义
    } else if (isUndef(oldEndVnode)) {
      // oldCh尾索引向前移动一位
      oldEndVnode = oldCh[--oldEndIdx]
      // 首节点比较，如果能复用
    } else if (sameVnode(oldStartVnode, newStartVnode)) {
      // 调用patchVnode，更新oldStartVnode、newStartVnode，也会递归updateChildren
      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
      // 更新节点位置
      oldStartVnode = oldCh[++oldStartIdx]
      newStartVnode = newCh[++newStartIdx]
      // 尾节点比较
    } else if (sameVnode(oldEndVnode, newEndVnode)) {
      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)
      oldEndVnode = oldCh[--oldEndIdx]
      newEndVnode = newCh[--newEndIdx]
      // 首尾节点比较
    } else if (sameVnode(oldStartVnode, newEndVnode)) {
      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)
      canMove &amp;amp;&amp;amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))
      oldStartVnode = oldCh[++oldStartIdx]
      newEndVnode = newCh[--newEndIdx]
      // 尾首节点比较
    } else if (sameVnode(oldEndVnode, newStartVnode)) {
      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
      canMove &amp;amp;&amp;amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)
      oldEndVnode = oldCh[--oldEndIdx]
      newStartVnode = newCh[++newStartIdx]
    } else {
      // 以上条件都不满足，调用createKeyToOldIdx
      // createKeyToOldIdx 方法的作用，遍历oldCh，找到里面设置key的对象
      // 返回一个map，key为键，index为值
      if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)
      // 查询新节点在oldCh中的索引
      idxInOld = isDef(newStartVnode.key) ?
        oldKeyToIdx[newStartVnode.key] :
        findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)
      // 如果没找到，说明是新建的节点
      if (isUndef(idxInOld)) {
        // 创建新的DOM元素，插入到指定节点
        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
      } else {
        // 如果在oldCh中找到了索引
        vnodeToMove = oldCh[idxInOld]
        // 可复用
        if (sameVnode(vnodeToMove, newStartVnode)) {
          // patchVnode复用dom元素递归子元素
          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
          // vnode处理完了之后清楚oldCh对应的节点
          oldCh[idxInOld] = undefined
          canMove &amp;amp;&amp;amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
          // 不可复用，直接创建新元素
        } else {
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
        }
      }
      // newCh向后移一位
      newStartVnode = newCh[++newStartIdx]
    }
  }
  // 如果oldCh遍历完了
  if (oldStartIdx &amp;gt; oldEndIdx) {
    // 创建剩下的dom节点，添加到对应的位置
    refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm
    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)
    // 如果newCh遍历完了，oldCh没有 
    // 移出剩下的oldCh
  } else if (newStartIdx &amp;gt; newEndIdx) {
    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是&lt;code&gt;diff&lt;/code&gt;处理&lt;code&gt;vnode children&lt;/code&gt;属性的过程&lt;/p&gt;

&lt;p&gt;3.对于自定义组件，在&lt;code&gt;createElm&lt;/code&gt;方法中中，会调用一个方法&lt;code&gt;createComponent&lt;/code&gt;来判断是否是自定义组件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;...
if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
	return
}
...

createComponent

function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
  let i = vnode.data
  if (isDef(i)) {
    const isReactivated = isDef(vnode.componentInstance) &amp;amp;&amp;amp; i.keepAlive
    if (isDef(i = i.hook) &amp;amp;&amp;amp; isDef(i = i.init)) {
      i(vnode, false /* hydrating */, parentElm, refElm)
    }
    ......
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用&lt;code&gt;init&lt;/code&gt;初始化，&lt;code&gt;init&lt;/code&gt;方法定义在&lt;code&gt;componentVNodeHooks&lt;/code&gt;中，&lt;code&gt;componentVNodeHooks&lt;/code&gt;中定义的钩子函数，会在&lt;code&gt;patch&lt;/code&gt;中调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const componentVNodeHooks = {
  init (
    vnode,
    hydrating,
    parentElm,
    refElm
  ) {
    // 如果当前vnode上没有组件实例或者已经销毁，则创建新的新的component实例
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      // 调用createComponentInstanceForVnode
      // createComponentInstanceForVnode方法中会处理组件中的各种属性
      // 比如 Ctor是自定义组件的构造函数，propsData是父组件通过props传递的数据
      // listeners是添加在当前组件上的事件，tag是自定义的标签名，children即当前自定义组件的子元素
      const child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance,
        parentElm,
        refElm
      );
      // 调用$mount
      // 其内部依旧调用__patch__
      // 然后update
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      const mountedNode = vnode;
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },
  // patchVNode中调用
  // 组件diff之前的操作
  prepatch (oldVnode: MountedComponentVNode, vnode: MountedComponentVNode) {
    const options = vnode.componentOptions
    const child = vnode.componentInstance = oldVnode.componentInstance
    // 调用updateChildComponent，通过传入的属性，更新对应的模板，数据，事件
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    )
  },

  // patch invokeInsertHook中调用
  // 生成的dom元素插入页面后调用
  insert (vnode: MountedComponentVNode) {
    const { context, componentInstance } = vnode
    // 设置_isMounted为true，调用mounted钩子函数
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true
      callHook(componentInstance, &#39;mounted&#39;)
    }
    if (vnode.data.keepAlive) {
      // keepAlive组件，如果已经加载好了的
      // 调用queueActivatedComponent，放进activatedChildren
      if (context._isMounted) {
        queueActivatedComponent(componentInstance)
      } else {
        // 反之调用activateChildComponent，触发activated钩子函数
        // 这又是keepAlive专有的生命周期
        activateChildComponent(componentInstance, true /* direct */)
      }
    }
  },

  destroy (vnode: MountedComponentVNode) {
    const { componentInstance } = vnode
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        // 销毁组件
        componentInstance.$destroy()
      } else {
        // 对于keepAlive组件，调用deactivateChildComponent，触发deactivated钩子函数
        deactivateChildComponent(componentInstance, true /* direct */)
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;销毁组件&lt;code&gt;destroy&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Vue.prototype.$destroy = function () {
  const vm: Component = this
  if (vm._isBeingDestroyed) {
    return
  }
  // 调用beforeDestroy钩子函数
  callHook(vm, &#39;beforeDestroy&#39;)
  vm._isBeingDestroyed = true
  const parent = vm.$parent
  // 从父元素中删除当前元素
  if (parent &amp;amp;&amp;amp; !parent._isBeingDestroyed &amp;amp;&amp;amp; !vm.$options.abstract) {
    remove(parent.$children, vm)
  }
  // 销毁watcher
  if (vm._watcher) {
    vm._watcher.teardown()
  }
  // _watchers减一
  let i = vm._watchers.length
  while (i--) {
    vm._watchers[i].teardown()
  }
  // observe减一
  if (vm._data.__ob__) {
    vm._data.__ob__.vmCount--
  }
  vm._isDestroyed = true
  // 传入null，销毁当前组件
  vm.__patch__(vm._vnode, null)
  // 调用destroyed钩子函数
  callHook(vm, &#39;destroyed&#39;)
  // 销毁事件
  vm.$off()
  // 消除各种属性
  if (vm.$el) {
    vm.$el.__vue__ = null
  }
  vm.$options._parentElm = vm.$options._refElm = null
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上就是&lt;code&gt;patch&lt;/code&gt;的内容，包括一次生成&lt;code&gt;dom&lt;/code&gt;元素，&lt;code&gt;diff&lt;/code&gt;更新操作，还有对于&lt;code&gt;component&lt;/code&gt;先转换为&lt;code&gt;vnode&lt;/code&gt;再进行&lt;code&gt;patch&lt;/code&gt;，另外还有一些生命周期函数&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Vue中的VNode</title>
      <link>https://xtid.github.io/2020/vue%E4%B8%AD%E7%9A%84vnode/</link>
      <pubDate>Tue, 04 Aug 2020 23:28:03 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/vue%E4%B8%AD%E7%9A%84vnode/</guid>
      <description>&lt;p&gt;经过&lt;code&gt;compile&lt;/code&gt;编译模板字符串变成了&lt;code&gt;render&lt;/code&gt;函数，在&lt;code&gt;src/core/instance/render.js&lt;/code&gt;中，通过&lt;code&gt;vnode = render.call(vm._renderProxy, vm.$createElement)&lt;/code&gt;调用了&lt;code&gt;render&lt;/code&gt;方法并最终返回了一个&lt;code&gt;VNode&lt;/code&gt;对象实例，即&lt;code&gt;Vue&lt;/code&gt;中的虚拟&lt;code&gt;Dom&lt;/code&gt;，基本定义如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export default class VNode {
  constructor (
    tag?: string,
    data?: VNodeData,
    children?: ?Array&amp;lt;VNode&amp;gt;,
    text?: string,
    elm?: Node,
    context?: Component,
    componentOptions?: VNodeComponentOptions,
    asyncFactory?: Function
  ) {
    this.tag = tag v // 标签名
    this.data = data // 结点相关属性数据
    this.children = children // 子节点
    this.text = text // 文本
    this.elm = elm // dom元素 
    this.ns = undefined // 命名空间
    this.context = context // VNode上下文对象
    ...... 
    this.key = data &amp;amp;&amp;amp; data.key // key
    this.componentOptions = componentOptions // VNode对象如果对应的是一个自定义组件，componentOptions保存组件相关事件、props数据等
    this.componentInstance = undefined // VNode对象如果对应的是一个自定义组件，componentInstance保存相对应的vue实例
    this.parent = undefined // 当前自定义组件在父组件中的vnode
    this.raw = false
    this.isStatic = false // 是否静态节点
    .....
    this.isOnce = false // 是否为v-once元素的VNode对象
  }

  get child (): Component | void {
    return this.componentInstance
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后面还定义了一些创建简单的VNode的方法，如&lt;code&gt;createEmptyVNode&lt;/code&gt;、&lt;code&gt;reateEmptyVNode&lt;/code&gt;、&lt;code&gt;createTextVNode&lt;/code&gt;、&lt;code&gt;cloneVNode&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;前面说过，调用_init方法的最后，会调用vm._render来生成VNode节点，在&lt;code&gt;src/core/instance/render.js&lt;/code&gt;可以找到这个方法，
在这个方法里面，就会调用&lt;code&gt;vnode = render.call(vm._renderProxy, vm.$createElement)&lt;/code&gt;来生成&lt;code&gt;VNode&lt;/code&gt;，其中在这文件有两个&lt;code&gt;createElement&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;vm._c = (a, b, c, d) =&amp;gt; createElement(vm, a, b, c, d, false)
vm.$createElement = (a, b, c, d) =&amp;gt; createElement(vm, a, b, c, d, true)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;vm._c = (a, b, c, d) =&amp;gt; createElement(vm, a, b, c, d, false)&lt;/code&gt;是编译模板生成的render函数执行时调用的，
&lt;code&gt;vm.$createElement&lt;/code&gt;是自己添加&lt;code&gt;render&lt;/code&gt;函数时，作为参数传递给render函数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/core/vdom/create-element.js&lt;/code&gt;中&lt;code&gt;createElement&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function createElement (
  context: Component, // 当前的上下文对象，哪一个vm
  tag: any, //  标签名
  data: any, // 节点相关的属性，比如key，ref，attrs等等属性
  children: any, // children
  normalizationType: any, // 子元素扁平化处理的级别
  alwaysNormalize: boolean // 总是扁平化处理
): VNode | Array&amp;lt;VNode&amp;gt; {
  // 如果判定为true，说明该元素没有相关属性
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children
    children = data
    data = undefined
  }
  if (isTrue(alwaysNormalize)) {
    // 最高级别的扁平化处理
    normalizationType = ALWAYS_NORMALIZE
  }
  return _createElement(context, tag, data, children, normalizationType)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用&lt;code&gt;_createElement&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function _createElement (
  context: Component,
  tag?: string | Class&amp;lt;Component&amp;gt; | Function | Object,
  data?: VNodeData,
  children?: any,
  normalizationType?: number
): VNode | Array&amp;lt;VNode&amp;gt; {
	......
  if (!tag) {
    // 如果tag为空，创建一个空的VNode
    return createEmptyVNode()
  }
  // 在Vue中，如果设置对象或者数组为key的时候，会报错
  if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp;
    isDef(data) &amp;amp;&amp;amp; isDef(data.key) &amp;amp;&amp;amp; !isPrimitive(data.key)
  ) {
    if (!__WEEX__ || !(&#39;@binding&#39; in data.key)) {
      warn(
        &#39;Avoid using non-primitive value as key, &#39; +
        &#39;use string/number value instead.&#39;,
        context
      )
    }
  }
  // 如果只有一个children，则当成slot解析
  if (Array.isArray(children) &amp;amp;&amp;amp;
    typeof children[0] === &#39;function&#39;
  ) {
    data = data || {}
    data.scopedSlots = { default: children[0] }
    children.length = 0
  }
  // 扁平化处理
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children)
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children)
  }
  let vnode, ns
  if (typeof tag === &#39;string&#39;) {
    let Ctor
    ns = (context.$vnode &amp;amp;&amp;amp; context.$vnode.ns) || config.getTagNamespace(tag)
    if (config.isReservedTag(tag)) {
      // 如果tag为String，且为平台保留的标签，直接创建VNode
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      )
    } else if ((!data || !data.pre) &amp;amp;&amp;amp; isDef(Ctor = resolveAsset(context.$options, &#39;components&#39;, tag))) {
      // 如果不是保留标签，并且有数据，没有设置跳过，且是自定义组件
      vnode = createComponent(Ctor, data, context, children, tag)
    } else {
      // 否则，创建VNode对象
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      )
    }
  } else {
    // 如果tab不是字符串，也是直接createComponent
    vnode = createComponent(tag, data, context, children)
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) applyNS(vnode, ns)
    if (isDef(data)) registerDeepBindings(data)
    return vnode
  } else {
    return createEmptyVNode()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;createComponent&lt;/code&gt;可以创建自定义组件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function createComponent (
  Ctor: Class&amp;lt;Component&amp;gt; | Function | Object | void,
  data: ?VNodeData,
  context: Component,
  children: ?Array&amp;lt;VNode&amp;gt;,
  tag?: string
): VNode | Array&amp;lt;VNode&amp;gt; | void {
  // 如果Ctor为空，跳过此步骤，对应的实际情况就是传入的参数并不是字符串或者自定义组件
  if (isUndef(Ctor)) {
    return
  }
	
	// baseCtor其实就是指的Vue对象
  const baseCtor = context.$options._base

  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor)
  }
	......
  data = data || {}
	
	// 递归合并父对象上的options
  resolveConstructorOptions(Ctor)

	// 处理v-model指令
  if (isDef(data.model)) {
    transformModel(Ctor.options, data)
  }
	
	// 抽取props属性
  const propsData = extractPropsFromVNodeData(data, Ctor, tag)

  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }
	
	// 处理组件.native的事件，表示组件上的事件
  const listeners = data.on
  data.on = data.nativeOn
		
	// 处理抽象组件中的slot，如keep-alive
  if (isTrue(Ctor.options.abstract)) {
    const slot = data.slot
    data = {}
    if (slot) {
      data.slot = slot
    }
  }
	
	// 合并一些钩子函数
  installComponentHooks(data)

  const name = Ctor.options.name || tag
  
  // 生成VNode
  const vnode = new VNode(
    `vue-component-${Ctor.cid}${name ? `-${name}` : &#39;&#39;}`,
    data, undefined, undefined, undefined, context,
    { Ctor, propsData, listeners, tag, children },
    asyncFactory
  )
	
  ......

  return vnode
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;extractPropsFromVNodeData&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function extractProps (data: VNodeData, Ctor: Class&amp;lt;Component&amp;gt;, tag?: string): ?Object {
  const propOptions = Ctor.options.props
  // 组件没有props，return
  if (!propOptions) {
    return
  }
  const res = {}
  // domProps表示input的value、option的selected等属性
  // attrs表父组件绑定在子元素上的属性值
  const { attrs, props, domProps } = data
  if (attrs || props || domProps) {
    for (const key in propOptions) {
      // 将驼峰命名转化为连线命名
			// aB -&amp;gt; a-b
      const altKey = hyphenate(key)
      .....
      
      // 遍历找到props、attrs、domProps中的属性
      // 如果没有传递preserve参数，则表示找到该key的值时删除对应的属性
      // 最后返回res，并且只留下props上的属性
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey) ||
      checkProp(res, domProps, key, altKey)
    }
  }
  return res
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，对于自定义组件，会创建一个&lt;code&gt;vnode&lt;/code&gt;对象，并返回一个标签名为&lt;code&gt;vue-component-cid-name&lt;/code&gt;格式的&lt;code&gt;VNode&lt;/code&gt;对象。&lt;/p&gt;

&lt;p&gt;上面说的扁平化处理其实就是将多维的数组，合并转换成一个一维的数组&lt;/p&gt;

&lt;p&gt;&lt;code&gt;simpleNormalizeChildren&lt;/code&gt;简单的扁平化处理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function simpleNormalizeChildren (children: any) {
  for (let i = 0; i &amp;lt; children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;normalizeChildren&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function normalizeChildren (children: any): ?Array&amp;lt;VNode&amp;gt; {
  return isPrimitive(children)
  	// 如果传入的children是字符串或者数字，则直接返回文本结点数组
    ? [createTextVNode(children)]
    : Array.isArray(children)
			// 如果传入的children是数组，调用normalizeArrayChildren
      ? normalizeArrayChildren(children)
      : undefined
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;normalizeArrayChildren&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function normalizeArrayChildren (children: any, nestedIndex?: string): Array&amp;lt;VNode&amp;gt; {
  const res = []
  let i, c, lastIndex, last
  for (i = 0; i &amp;lt; children.length; i++) {
    c = children[i]
    // 如果该元素为undefined或null或Boolean类型的值,continue
    if (isUndef(c) || typeof c === &#39;boolean&#39;) continue
    lastIndex = res.length - 1
    last = res[lastIndex]
    if (Array.isArray(c)) {
      if (c.length &amp;gt; 0) {
        // c是一个数组，则递归的执行normalizeArrayChildren方法
        c = normalizeArrayChildren(c, `${nestedIndex || &#39;&#39;}_${i}`)
        if (isTextNode(c[0]) &amp;amp;&amp;amp; isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]: any).text)
          c.shift()
        }
        res.push.apply(res, c)
      }
    } else if (isPrimitive(c)) {
      // 如果最后一个节点是文本节点
      if (isTextNode(last)) {
        // 合并last.text和c
        res[lastIndex] = createTextVNode(last.text + c)
      } else if (c !== &#39;&#39;) {
        // 如果最后一个节点不是文本节点，且不为空
        // 创建一个空文本节点
        res.push(createTextVNode(c))
      }
    } else {
      // 如果c是一个文本VNode对象，且res中最后一个元素也是文本结点
      // 合并两个VNode为一个
      if (isTextNode(c) &amp;amp;&amp;amp; isTextNode(last)) {
        res[lastIndex] = createTextVNode(last.text + c.text)
      } else {
        // 设置VNode的key
        if (isTrue(children._isVList) &amp;amp;&amp;amp;
          isDef(c.tag) &amp;amp;&amp;amp;
          isUndef(c.key) &amp;amp;&amp;amp;
          isDef(nestedIndex)) {
          c.key = `__vlist${nestedIndex}_${i}__`
        }
        res.push(c)
      }
    }
  }
  return res
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Vue里面compile模板编译</title>
      <link>https://xtid.github.io/2020/vue%E9%87%8C%E9%9D%A2compile%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/</link>
      <pubDate>Thu, 30 Jul 2020 22:16:42 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/vue%E9%87%8C%E9%9D%A2compile%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/</guid>
      <description>&lt;p&gt;1.complie简述&lt;/p&gt;

&lt;p&gt;&lt;code&gt;complie&lt;/code&gt;阶段主要是将&lt;code&gt;Vue&lt;/code&gt;代码通过一系列转换，最终生成对应的&lt;code&gt;render&lt;/code&gt;字符串，然后&lt;code&gt;Vue&lt;/code&gt;通过&lt;code&gt;render&lt;/code&gt;字符串里面的关键词或者说定义，对页面内容进行增删改，&lt;code&gt;Vue&lt;/code&gt;对象上有一个全局函数&lt;code&gt;compile&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import { compileToFunctions } from &#39;./compiler/index&#39;
......
Vue.compile = compileToFunctions
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，他是引用的&lt;code&gt;./compiler/index&lt;/code&gt;模块导出的&lt;code&gt;compileToFunctions&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { baseOptions } from &#39;./options&#39;
import { createCompiler } from &#39;compiler/index&#39;
const { compile, compileToFunctions } = createCompiler(baseOptions)
export { compile, compileToFunctions }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;baseOptions&lt;/code&gt;，对解析模板的一些选项进行基本的定义，规定如果解析模板中的各种标签或代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export const baseOptions: CompilerOptions = {
  expectHTML: true,
  modules,
  directives,
  isPreTag,
  isUnaryTag,
  mustUseProp,
  canBeLeftOpenTag,
  isReservedTag,
  getTagNamespace,
  staticKeys: genStaticKeys(modules)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;expectHTML&lt;/code&gt;：为&lt;code&gt;true&lt;/code&gt;时，解析&lt;code&gt;HTML&lt;/code&gt;的结束标签&lt;/p&gt;

&lt;p&gt;&lt;code&gt;modules&lt;/code&gt;：包括&lt;code&gt;klass&lt;/code&gt;和&lt;code&gt;style&lt;/code&gt;，对模板中类和样式的解析。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;directives&lt;/code&gt;：这里包括&lt;code&gt;model&lt;/code&gt;（&lt;code&gt;v-model&lt;/code&gt;）、&lt;code&gt;html&lt;/code&gt;（&lt;code&gt;v-html&lt;/code&gt;）、&lt;code&gt;text&lt;/code&gt;(&lt;code&gt;v-text&lt;/code&gt;)三个指令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;isPreTag&lt;/code&gt;：是否是&lt;code&gt;pre&lt;/code&gt;标签&lt;/p&gt;

&lt;p&gt;&lt;code&gt;isUnaryTag&lt;/code&gt;：是否是单标签，比如&lt;code&gt;img&lt;/code&gt;、&lt;code&gt;input&lt;/code&gt;、&lt;code&gt;iframe&lt;/code&gt;等&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mustUseProp&lt;/code&gt;：需要使用&lt;code&gt;props&lt;/code&gt;绑定的属性，比如&lt;code&gt;value&lt;/code&gt;、&lt;code&gt;selected&lt;/code&gt;等&lt;/p&gt;

&lt;p&gt;&lt;code&gt;canBeLeftOpenTag&lt;/code&gt;：可以不闭合的标签，比如&lt;code&gt;tr&lt;/code&gt;、&lt;code&gt;td&lt;/code&gt;等&lt;/p&gt;

&lt;p&gt;&lt;code&gt;isReservedTag&lt;/code&gt;：是否是保留标签，&lt;code&gt;html&lt;/code&gt;标签和&lt;code&gt;SVG&lt;/code&gt;标签&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getTagNamespace&lt;/code&gt;：获取命名空间，&lt;code&gt;svg&lt;/code&gt;和&lt;code&gt;math&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;staticKeys&lt;/code&gt;：静态关键词，包括&lt;code&gt;staticClass,staticStyle&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后是&lt;code&gt;createCompiler&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function createCompilerCreator (baseCompile: Function): Function {
  // 接受一个基本的CompilerOptions
  return function createCompiler (baseOptions: CompilerOptions) {
    function compile (
      template: string,
      options?: CompilerOptions
    ): CompiledResult {
      // finalOptions继承自baseOptions
      const finalOptions = Object.create(baseOptions)
      const errors = []
      const tips = []

      let warn = (msg, range, tip) =&amp;gt; {
        (tip ? tips : errors).push(msg)
      }

      if (options) {
        if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; options.outputSourceRange) {
          // $flow-disable-line
          const leadingSpaceLength = template.match(/^\s*/)[0].length

          warn = (msg, range, tip) =&amp;gt; {
            const data: WarningMessage = { msg }
            if (range) {
              if (range.start != null) {
                data.start = range.start + leadingSpaceLength
              }
              if (range.end != null) {
                data.end = range.end + leadingSpaceLength
              }
            }
            (tip ? tips : errors).push(data)
          }
        }
        // 合并modules
        if (options.modules) {
          finalOptions.modules =
            (baseOptions.modules || []).concat(options.modules)
        }
        // 合并directives
        if (options.directives) {
          finalOptions.directives = extend(
            Object.create(baseOptions.directives || null),
            options.directives
          )
        }
        
        // 额外传入的options，合并
        for (const key in options) {
          if (key !== &#39;modules&#39; &amp;amp;&amp;amp; key !== &#39;directives&#39;) {
            finalOptions[key] = options[key]
          }
        }
      }
	
      // 收集到的错误日志
      finalOptions.warn = warn

      const compiled = baseCompile(template.trim(), finalOptions)
      if (process.env.NODE_ENV !== &#39;production&#39;) {
        detectErrors(compiled.ast, warn)
      }
      compiled.errors = errors
      compiled.tips = tips
      // 返回render字符串
      return compiled
    }

    return {
      compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导出的模块&lt;code&gt;compileToFunctions&lt;/code&gt;为&lt;code&gt;createCompileToFunctionFn&lt;/code&gt;执行返回的结果&lt;/p&gt;

&lt;p&gt;&lt;code&gt;createCompileToFunctionFn&lt;/code&gt;代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function createCompileToFunctionFn (compile: Function): Function {
  const cache = Object.create(null)

  return function compileToFunctions (
    template: string,
    options?: CompilerOptions,
    vm?: Component
  ): CompiledFunctionResult {
    // 拿到options，并且删除错误日志等数据
    options = extend({}, options)
    const warn = options.warn || baseWarn
    delete options.warn
		
    ......

		// 如果有缓存，拿到缓存中的编译结果
    const key = options.delimiters
      ? String(options.delimiters) + template
      : template
    if (cache[key]) {
      return cache[key]
    }

    // 编译的结果
    const compiled = compile(template, options)

 		......

    const res = {}
    const fnGenErrors = []
    // render字符串
    res.render = createFunction(compiled.render, fnGenErrors)
    // 将render字符串中的标识符转为函数，如_c、_m
    res.staticRenderFns = compiled.staticRenderFns.map(code =&amp;gt; {
      return createFunction(code, fnGenErrors)
    })

		......

    return (cache[key] = res)
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.生成ast&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;src/compiler/parser/index.js&lt;/code&gt;中，首先定义了各种&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 匹配@或v-on开头的属性
export const onRE = /^@|^v-on:/
// 是匹配v-或@或:开头的属性
export const dirRE = /^v-|^@|^:|^\./ 
// 匹配v-for中的属性值，比如item in items、(item, index) of items
export const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/ 
// 是对forAliasRE中捕获的第一部分内容，进行拆解，v-for中in|of前最后可以有三个逗号分隔的参数
export const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/
// 去掉字符串 &#39;(item, index)&#39; 中的左右括号
const stripParensRE = /^\(|\)$/g
// 用来匹配指令编写中的参数
const argRE = /:(.*)$/
// 匹配以字符:或字符串 v-bind: 开头的字符串
export const bindRE = /^:|^\.|^v-bind:/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;parse&lt;/code&gt;，里面解析的方法主要是&lt;code&gt;parseHTML&lt;/code&gt;，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function parse (
	template: string,
	options: CompilerOptions
  ): ASTElement | void {
	warn = options.warn || baseWarn
  
	......
	parseHTML()
  return root
}

// src/compiler/parser/html-parser.js

export function parseHTML (html, options) {
  const stack = []
  const expectHTML = options.expectHTML
  const isUnaryTag = options.isUnaryTag || no
  const canBeLeftOpenTag = options.canBeLeftOpenTag || no
  let index = 0
  let last, lastTag
  while (html) {}

  function advance (n) {
    ...
  }

  function parseStartTag () {
    ...
  }

  function handleStartTag (match) {
    ...
  }

	function parseEndTag (tagName, start, end) {
  	...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;parseHTML&lt;/code&gt;的&lt;code&gt;while&lt;/code&gt;循环里&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// advance这个方法，用于截取传入的字符串
// 过滤掉注释，doctype等
if (comment.test(html)) {
  const commentEnd = html.indexOf(&#39;--&amp;gt;&#39;)

  if (commentEnd &amp;gt;= 0) {
    advance(commentEnd + 3)
    continue
  }
}

// 过滤文档类型标示的字符串
const doctypeMatch = html.match(doctype)
if (doctypeMatch) {
  advance(doctypeMatch[0].length)
  continue
}

// 匹配结束的标签
const endTagMatch = html.match(endTag)
if (endTagMatch) {
  const curIndex = index
  advance(endTagMatch[0].length)
  parseEndTag(endTagMatch[1], curIndex, index)
  continue
}

// 匹配开始标签
// 传入handleStartTag处理完后，会生成一个包含标签各种属性的对象
const startTagMatch = parseStartTag()
if (startTagMatch) {
  handleStartTag(startTagMatch)
  continue
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后续会调用&lt;code&gt;parse&lt;/code&gt;里调用&lt;code&gt;parseHTML&lt;/code&gt;传入的&lt;code&gt;start&lt;/code&gt;的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;start () {
  // 定义基本的ast结构
  createASTElement()
  // 解析v-pre、v-if、v-for、v-once、slot、key、ref等指令
  processPre()
  processFor()
  ......
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;处理完后会调用&lt;code&gt;parse&lt;/code&gt;里调用&lt;code&gt;parseHTML&lt;/code&gt;传入的&lt;code&gt;end&lt;/code&gt;的方法&lt;/p&gt;

&lt;p&gt;1、取出&lt;code&gt;stack&lt;/code&gt;中的最后一个元素。&lt;/p&gt;

&lt;p&gt;2、取出该元素的最后一个子元素。&lt;/p&gt;

&lt;p&gt;3、如果最后一个子元素是纯文本&lt;code&gt;&#39; &#39;&lt;/code&gt;则删除，这是因为我们的模板一般都会缩进，都会有换行，所以这里是清除换行等添加的内容。&lt;/p&gt;

&lt;p&gt;4、&lt;code&gt;stack&lt;/code&gt;长度减一&lt;/p&gt;

&lt;p&gt;5、&lt;code&gt;currentParent&lt;/code&gt;变为栈中最后一个元素&lt;/p&gt;

&lt;p&gt;6、 处理&lt;code&gt;v-pre&lt;/code&gt;或&lt;code&gt;pre&lt;/code&gt;的结束标签&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;end (tag, start, end) {
  const element = stack[stack.length - 1]
  if (!inPre) {
    const lastNode = element.children[element.children.length - 1]
    if (lastNode &amp;amp;&amp;amp; lastNode.type === 3 &amp;amp;&amp;amp; lastNode.text === &#39; &#39;) {
      element.children.pop()
    }
  }
  stack.length -= 1
  currentParent = stack[stack.length - 1]
  if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; options.outputSourceRange) {
    element.end = end
  }
  closeElement(element)
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，得到一个包含名称、类型、属性、父子节点信息的一个&lt;code&gt;ast&lt;/code&gt;语法树，如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const element = {
  type: 1,
  tag: &#39;&#39;,
  attrsList: [],
  attrsMap: {},
  parent: {},
  children: []
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.优化静态内容，打开&lt;code&gt;src/compiler/index&lt;/code&gt;，看到调用&lt;code&gt;const ast = parse(template.trim(), options)&lt;/code&gt;生成&lt;code&gt;ast&lt;/code&gt;后，调用&lt;code&gt;optimize&lt;/code&gt;，传入&lt;code&gt;ast&lt;/code&gt; ，打开&lt;code&gt;optimisze&lt;/code&gt;源码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 获取基本静态key的一个集合
const genStaticKeysCached = cached(genStaticKeys)
export function optimize (root: ?ASTElement, options: CompilerOptions) {
  if (!root) return
  // 如果ast上有staticKeys选项
  isStaticKey = genStaticKeysCached(options.staticKeys || &#39;&#39;)
  // 是不是平台保留tag，如HTML 标签
  isPlatformReservedTag = options.isReservedTag || no
  // 标记所有静态和非静态节点
  markStatic(root)
  // 标记静态根节点
  markStaticRoots(root, false)
}

function genStaticKeys (keys: string): Function {
  return makeMap(
    &#39;type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap,has$Slot&#39; +
    (keys ? &#39;,&#39; + keys : &#39;&#39;)
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;markStatic&lt;/code&gt;标记所有静态和非静态节点&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function markStatic (node: ASTNode) {
  // 判断当前节点是否为静态节点
  // 静态节点包括普通元素、纯文本元素、v-pre、v-once
  node.static = isStatic(node)
 	// 如果type为1，代表当前节点为元素节点
  if (node.type === 1) {
    if (
      // 如果不是保留标签，即自定义标签时
      !isPlatformReservedTag(node.tag) &amp;amp;&amp;amp;
      // 如果不是component标签
      !node.component &amp;amp;&amp;amp;
      // 如果标签不是slot
      node.tag !== &#39;slot&#39; &amp;amp;&amp;amp;
      // 不是一个内联模板容器？？
      node.attrsMap[&#39;inline-template&#39;] == null
    ) {
      // 直接return，不对子节点做处理，反之，递归对子节点做标记
      return
    }
  	......
  }
}
  
function isStatic (node: ASTNode): boolean {
  // 表达式
  if (node.type === 2) {
    return false
  }
  // text
  if (node.type === 3) { 
    return true
  }
  return !!(node.pre || (
    // 没有任何指令或事件绑定
    !node.hasBindings &amp;amp;&amp;amp; 
    // 没有if 和 for 指令
    !node.if &amp;amp;&amp;amp; !node.for &amp;amp;&amp;amp; 
    // 不是内置标签，如slot
    !isBuiltInTag(node.tag) &amp;amp;&amp;amp;
    // 平台保留标签，如HTML
    isPlatformReservedTag(node.tag) &amp;amp;&amp;amp; 
    // 不是template标签的直接子元素且没有包含在for循环中
    !isDirectChildOfTemplateFor(node) &amp;amp;&amp;amp;
    // 结点包含的属性只能有isStaticKey中指定的几个
    Object.keys(node).every(isStaticKey)
  ))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;markStaticRoots&lt;/code&gt;标记静态根节点&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function markStaticRoots (node: ASTNode, isInFor: boolean) {
  // 只处理元素节点类型
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor
    }
    // 标记静态根节点的条件为本身static标记为true
    // 并且该结点不是只有一个静态文本子节点
    if (node.static &amp;amp;&amp;amp; node.children.length &amp;amp;&amp;amp; !(
      node.children.length === 1 &amp;amp;&amp;amp;
      node.children[0].type === 3
    )) {
      node.staticRoot = true
      return
    } else {
      node.staticRoot = false
    }
		......
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.生成render字符串&lt;/p&gt;

&lt;p&gt;在标记完静态节点之后，会调用&lt;code&gt;generate&lt;/code&gt;方法来生成render字符串，生成的字符串中&lt;/p&gt;

&lt;p&gt;&lt;code&gt;_c&lt;/code&gt; 该方法对应的是&lt;code&gt;createElement&lt;/code&gt;方法，顾名思义，它的含义是创建一个元素，它的第一个参数是要定义的元素标签名、第二个参数是元素上添加的属性，第三个参数是子元素数组，第四个参数是子元素数组进行归一化处理的级别。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;_v&lt;/code&gt; 该方法是创建一个文本结点。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;_s&lt;/code&gt; 是把一个值转换为字符串。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;_m&lt;/code&gt; 是渲染静态内容，它接收的第一个参数是一个索引值，指向最终生成的&lt;code&gt;staticRenderFns&lt;/code&gt;数组中对应的内容，第二个参数是标识元素是否包裹在&lt;code&gt;for&lt;/code&gt;循环内。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function generate (
  ast: ASTElement | void,
  options: CompilerOptions
): CodegenResult {
  const state = new CodegenState(options)
  // 如果ast为空，直接返回一个空的div节点
  // 有过有值，调用genElement
  const code = ast ? genElement(ast, state) : &#39;_c(&amp;quot;div&amp;quot;)&#39;
  // 返回render字符串
  return {
    render: `with(this){return ${code}}`,
    staticRenderFns: state.staticRenderFns
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;genElement&lt;/code&gt;会通过节点上的标志来判断使用什么方法来生成render字符串，这里说一下&lt;code&gt;genStatic&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function genElement (el: ASTElement, state: CodegenState): string {
  // pre的状态用来判断是否跳过当前解析
  if (el.parent) {
    el.pre = el.pre || el.parent.pre
  }
	
  if (el.staticRoot &amp;amp;&amp;amp; !el.staticProcessed) {
    return genStatic(el, state)
  } 
  ...... 
		else {
      let data
      // 如果节点没其他属性或者跳过解析，直接genData
      // genData这个方法会给节点添加各种属性
      if (!el.plain || (el.pre &amp;amp;&amp;amp; state.maybeComponent(el))) {
        data = genData(el, state)
      }
			
      // 如果不是内部模板，调用genChildren，返回对应的字符串
      const children = el.inlineTemplate ? null : genChildren(el, state, true)
      code = `_c(&#39;${el.tag}&#39;${
        data ? `,${data}` : &#39;&#39; 
      }${
        children ? `,${children}` : &#39;&#39; 
      })`
    }
    for (let i = 0; i &amp;lt; state.transforms.length; i++) {
      code = state.transforms[i](el, code)
    }
    return code
  }
}

function genStatic (el: ASTElement, state: CodegenState): string {
  el.staticProcessed = true
  // 暂存pre
  const originalPreState = state.pre
  // 如果当前节点pre为true，更改pre的状态
  if (el.pre) {
    state.pre = el.pre
  }
  // 通过递归处理静态根节点及其子内容，添加到staticRenderFns
  state.staticRenderFns.push(`with(this){return ${genElement(el, state)}}`)
  // 恢复pre状态
  state.pre = originalPreState
  return `_m(${
    state.staticRenderFns.length - 1
  }${
    el.staticInFor ? &#39;,true&#39; : &#39;&#39;
  })`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后返回的结果就包含&lt;code&gt;render&lt;/code&gt;字符串以及&lt;code&gt;staticRenderFns&lt;/code&gt;静态节点&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Vue2.x里面的双向数据绑定</title>
      <link>https://xtid.github.io/2020/vue2.x%E9%87%8C%E9%9D%A2%E7%9A%84%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</link>
      <pubDate>Wed, 29 Jul 2020 22:13:21 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/vue2.x%E9%87%8C%E9%9D%A2%E7%9A%84%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</guid>
      <description>&lt;p&gt;Vue2.x的数据绑定是通过数据劫持的方式来实现的，其中最核心的便是&lt;code&gt;Object.defineProperty()&lt;/code&gt;，而Vue3.0里面数据绑定是通过&lt;code&gt;Proxy&lt;/code&gt;实现的&lt;/p&gt;

&lt;p&gt;Vue2.x的双向数据绑定，有三个比较核心的部分&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Observer&lt;/code&gt;：通过&lt;code&gt;Object.defineProperty&lt;/code&gt;来做数据劫持，递归地监听对象上的所有属性，在属性值改变的时候，触发相应的&lt;code&gt;Watcher&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Watcher&lt;/code&gt;：订阅者，当监听的数据值修改时，执行通知&lt;code&gt;Dep&lt;/code&gt;执行对应的响应的回调函数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Dep&lt;/code&gt;：将&lt;code&gt;Observer&lt;/code&gt;和&lt;code&gt;Watcher&lt;/code&gt;关联起来，这个双向数据绑定实现的设计模式为发布订阅模式，&lt;code&gt;Dep&lt;/code&gt;就相当于发布订阅模式的中间对象&lt;/p&gt;

&lt;p&gt;Observer&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export class Observer {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that have this object as root $data

  constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0
    // 通过Object.defineProperty设置_ob_值，使用_ob_可以直接拿到Observer对象
    def(value, &#39;__ob__&#39;, this)
    if (Array.isArray(value)) {
      if (hasProto) {
        protoAugment(value, arrayMethods)
      } else {
        copyAugment(value, arrayMethods, arrayKeys)
      }
      // 如果是数组，调用observeArray处理
      this.observeArray(value)
    } else {
      // 如果是其他对象调用walk处理
      this.walk(value)
    }
  }

  walk (obj: Object) {
    const keys = Object.keys(obj)
    // 遍历对象属性，对每个属性添加数据邦数据绑定
    for (let i = 0; i &amp;lt; keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }

  observeArray (items: Array&amp;lt;any&amp;gt;) {
    // 如果是数组，则循环遍历数组，调用observe
    for (let i = 0, l = items.length; i &amp;lt; l; i++) {
      observe(items[i])
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;defineReactive&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  const dep = new Dep()
	
  // 获取obj上对应属性key的描述符，如果configurable为false，属性不能改变，return
  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property &amp;amp;&amp;amp; property.configurable === false) {
    return
  }

  const getter = property &amp;amp;&amp;amp; property.get
  const setter = property &amp;amp;&amp;amp; property.set
  if ((!getter || setter) &amp;amp;&amp;amp; arguments.length === 2) {
    val = obj[key]
  }

  let childOb = !shallow &amp;amp;&amp;amp; observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      // 获取这个值
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        // 将当前dep添加到target中，然后将dep添加到subs中	
        dep.depend()
        if (childOb) 
          childOb.dep.depend()
          if (Array.isArray(value)) {
						// 如果传入的值为数组，遍历这个数组，对每一个元素depend
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
    	// 获取对象原来的值
      const value = getter ? getter.call(obj) : val
      // 如果新设置的值和原来的值一样，直接return
      if (newVal === value || (newVal !== newVal &amp;amp;&amp;amp; value !== value)) {
        return
      }
    	// 打印错误
      if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; customSetter) {
        customSetter()
      }
    	// 若属性上设置了getter没设置setter，return
      if (getter &amp;amp;&amp;amp; !setter) return
      if (setter) {
        setter.call(obj, newVal)
      } else {
        // 设置新的值
        val = newVal
      }
    	// 创建一个新的observe，并触发对应的更新事件
      childOb = !shallow &amp;amp;&amp;amp; observe(newVal)
      dep.notify()
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;observe&lt;/code&gt;这个方法主要是返回与对象相关的&lt;code&gt;Observer&lt;/code&gt;对象，如果没有，则新创建一个&lt;code&gt;Observer&lt;/code&gt;对象并返回&lt;/p&gt;

&lt;p&gt;defineReactive中还有几个方法，&lt;code&gt;protoAugment&lt;/code&gt;和&lt;code&gt;copyAugment&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var arrayProto = Array.prototype
var arrayMethods = Object.create(arrayProto)
function protoAugment (target, src) {
  target.__proto__ = src;
}
protoAugment(value, arrayMethods)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于数组对象来说在当前环境如果能使用&lt;code&gt;__proto__&lt;/code&gt;对象(&lt;code&gt;__proto__ in {}&lt;/code&gt;)，则调用&lt;code&gt;protoAugment&lt;/code&gt;，其实就是将当前的数组对象&lt;code&gt;__proto__&lt;/code&gt;指向数组原型对象，然后对于&lt;code&gt;push&lt;/code&gt;、&lt;code&gt;pop&lt;/code&gt;、&lt;code&gt;shift&lt;/code&gt;、&lt;code&gt;unshift&lt;/code&gt;、&lt;code&gt;splice&lt;/code&gt;、&lt;code&gt;sort&lt;/code&gt;、&lt;code&gt;reverse&lt;/code&gt;这些操作数组的方法，遍历，添加到&lt;code&gt;arrayMethods&lt;/code&gt;上，操作之后，调用&lt;code&gt;ob.dep.notify()&lt;/code&gt;触发更新&lt;/p&gt;

&lt;p&gt;&lt;code&gt;copyAugment&lt;/code&gt;则是在循环中把&lt;code&gt;arrayMethods&lt;/code&gt;上的&lt;code&gt;arrayKeys&lt;/code&gt;方法添加到&lt;code&gt;value&lt;/code&gt;上&lt;/p&gt;

&lt;p&gt;Dep&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Dep&lt;/code&gt;的定义比较简单，就是简单的保存了一个&lt;code&gt;Wacher&lt;/code&gt;数组，有一些增删的方法，最后&lt;code&gt;notify&lt;/code&gt;调用对应&lt;code&gt;Wacher&lt;/code&gt;更新的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export default class Dep {
  static target: ?Watcher;
  id: number;
  subs: Array&amp;lt;Watcher&amp;gt;;

  constructor () {
    this.id = uid++
    this.subs = []
  }

  addSub (sub: Watcher) {
    this.subs.push(sub)
  }

  removeSub (sub: Watcher) {
    remove(this.subs, sub)
  }

  depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }

  notify () {
    const subs = this.subs.slice()
    if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; !config.async) {
      subs.sort((a, b) =&amp;gt; a.id - b.id)
    }
    for (let i = 0, l = subs.length; i &amp;lt; l; i++) {
      subs[i].update()
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Watcher&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export default class Watcher {
	......
  constructor (
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) {
    this.vm = vm
    if (isRenderWatcher) {
      vm._watcher = this
    }
    vm._watchers.push(this)
    // 创建Watcher时传的options
    // 如之前调用updateComponet方法时，传入before来调用beforeUpdate钩子函数
    if (options) {
      this.deep = !!options.deep
      this.user = !!options.user
      this.lazy = !!options.lazy
      this.sync = !!options.sync
      this.before = options.before
    } else {
      this.deep = this.user = this.lazy = this.sync = false
    }
    this.cb = cb
    this.id = ++uid 
    this.active = true
    this.dirty = this.lazy 
    this.deps = []
    this.newDeps = []
    this.depIds = new Set()
    this.newDepIds = new Set()
    this.expression = process.env.NODE_ENV !== &#39;production&#39;
      ? expOrFn.toString()
      : &#39;&#39;
    
    // 设置getter
    // 如果传入expOrFn是一个函数
    if (typeof expOrFn === &#39;function&#39;) {
      this.getter = expOrFn
    } else {
      // 如果传入的不是一个函数，通过parsePath解析，赋值给getter
      this.getter = parsePath(expOrFn)
      if (!this.getter) {
        // 如果解析出来的getter不是一个函数，设置为空 noop，并打印错误
        this.getter = noop
        process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; warn(
          `Failed watching path: &amp;quot;${expOrFn}&amp;quot; ` +
          &#39;Watcher only accepts simple dot-delimited paths. &#39; +
          &#39;For full control, use a function instead.&#39;,
          vm
        )
      }
    }
    this.value = this.lazy
      ? undefined
      : this.get()
  }

  /**
   * Evaluate the getter, and re-collect dependencies.
   */
  get () {
    // 设置Dep.tartget为当前watcher，这样它就有addSub、removeSub等方法
    pushTarget(this)
    let value
    const vm = this.vm
    try {
      // 得到调用getter的value
      value = this.getter.call(vm, vm)
    } catch (e) {
      if (this.user) {
        handleError(e, vm, `getter for watcher &amp;quot;${this.expression}&amp;quot;`)
      } else {
        throw e
      }
    } finally {
      if (this.deep) {
        traverse(value)
      }
      // 清楚Dep，移出target队列，重新设置Dep.target值
      popTarget()
      this.cleanupDeps()
    }
    
    // 在进行模板渲染的时候，value为undefined
    return value
  }
	
	......
	
  // 在更新数据时，调用dep.notify，会触发update方法
  update () {
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) {
      // 若生成Watcher传入配置sync
      // 在更新的时候直接调用run方法，调用回掉方法
      this.run()
    } else {
      // 如果不是sync配置，处理Watcher队列
      // queueWatcher方法里会使用一个id来表示Watcher的优先级，依次执行上面的run方法
      // 更新的时候如果watcher列表正在更新，则把新的watcher添加到对应的位置，并更新
      // 否则，在下一个nextTick中执行flushSchedulerQueue
      queueWatcher(this)
    }
  }

  run () {
    if (this.active) {
      const value = this.get()
      if (
        value !== this.value ||
        isObject(value) ||
        this.deep
      ) {
        const oldValue = this.value
        this.value = value
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue)
          } catch (e) {
            handleError(e, this.vm, `callback for watcher &amp;quot;${this.expression}&amp;quot;`)
          }
        } else {
          // 回调
          this.cb.call(this.vm, value, oldValue)
        }
      }
    }
  }
	
	......
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Vue的初始化渲染过程简介</title>
      <link>https://xtid.github.io/2020/vue%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 27 Jul 2020 22:25:56 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/vue%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/</guid>
      <description>&lt;p&gt;首先进入到&lt;code&gt;src/core/instance/index.js&lt;/code&gt;，可以看到定义了一个&lt;code&gt;Vue&lt;/code&gt;构造函数，内容很简单，如果不是生产环境并且不是通过&lt;code&gt;new&lt;/code&gt;关键字创建对象的话，就在控制台打印一个&lt;code&gt;warn&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Vue (options) {
  if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp;
    !(this instanceof Vue)
  ) {
    warn(&#39;Vue is a constructor and should be called with the `new` keyword&#39;)
  }
  this._init(options)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后面调用了几个函数，用来在&lt;code&gt;Vue&lt;/code&gt;对象上创建各种属性或者方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;1.initMixin&lt;/h2&gt;

&lt;p&gt;初始化方法，首先为当前&lt;code&gt;vm&lt;/code&gt;设置一个&lt;code&gt;_uid&lt;/code&gt;，然后添加属性&lt;code&gt;_isVue&lt;/code&gt;，其目的在于监听数据变化时过滤&lt;code&gt;vm&lt;/code&gt;，&lt;code&gt;_isComponent&lt;/code&gt;是内部创建子组件时才会添加为&lt;code&gt;true&lt;/code&gt;的属性，然后走到&lt;code&gt;else&lt;/code&gt;分支，调用&lt;code&gt;resolveConstructorOptions&lt;/code&gt;会获取构造器父级的&lt;code&gt;options&lt;/code&gt;，然后调用&lt;code&gt;mergeOptions&lt;/code&gt;合并父级的&lt;code&gt;options&lt;/code&gt;以及本身传入的&lt;code&gt;options&lt;/code&gt;，最后生成的&lt;code&gt;options&lt;/code&gt;包含&lt;code&gt;components、directives&lt;/code&gt;等属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function initMixin (Vue: Class&amp;lt;Component&amp;gt;) {
  Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
    // a uid
    vm._uid = uid++

    let startTag, endTag
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; config.performance &amp;amp;&amp;amp; mark) {
      startTag = `vue-perf-start:${vm._uid}`
      endTag = `vue-perf-end:${vm._uid}`
      mark(startTag)
    }

    // a flag to avoid this being observed
    vm._isVue = true
    // merge options
    if (options &amp;amp;&amp;amp; options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options)
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== &#39;production&#39;) {
      initProxy(vm)
    } else {
      vm._renderProxy = vm
    }
    // expose real self
    vm._self = vm
    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    callHook(vm, &#39;beforeCreate&#39;)
    initInjections(vm) // resolve injections before data/props
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    callHook(vm, &#39;created&#39;)

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; config.performance &amp;amp;&amp;amp; mark) {
      vm._name = formatComponentName(vm, false)
      mark(endTag)
      measure(`vue ${vm._name} init`, startTag, endTag)
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt; 1.1initLifecycle &lt;/h3&gt;

&lt;p&gt;这个方法首先会设置&lt;code&gt;vm&lt;/code&gt;的一个父子节点、根节点信息，然后会定义一些生命周期相关的属性，比如&lt;code&gt;_isMounted、_isDestroyed、_isBeingDestroyed&lt;/code&gt;等&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function initLifecycle (vm: Component) {
  const options = vm.$options

  // locate first non-abstract parent
  let parent = options.parent
  if (parent &amp;amp;&amp;amp; !options.abstract) {
    while (parent.$options.abstract &amp;amp;&amp;amp; parent.$parent) {
      parent = parent.$parent
    }
    parent.$children.push(vm)
  }

  vm.$parent = parent
  vm.$root = parent ? parent.$root : vm

  vm.$children = []
  vm.$refs = {}

  vm._watcher = null
  vm._inactive = null
  vm._directInactive = false
  vm._isMounted = false
  vm._isDestroyed = false
  vm._isBeingDestroyed = false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt; 1.2initEvents &lt;/h3&gt;

&lt;p&gt;通过名字可以看出是一个初始化事件相关的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function initEvents (vm: Component) {
  // events表示父组件绑定在当前组件上的事件
  vm._events = Object.create(null)
  // 属性表示父组件是否通过&amp;quot;@hook:&amp;quot;把钩子函数绑定在当前组件上
  vm._hasHookEvent = false
  // init parent attached events
  // 同样是来表示父组件绑定在当前组件上的事件
  const listeners = vm.$options._parentListeners
  if (listeners) {
    updateComponentListeners(vm, listeners)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果&lt;code&gt;listeners&lt;/code&gt;有值，则调用&lt;code&gt;updateComponentListeners&lt;/code&gt;这个方法，其内部调用了&lt;code&gt;updateListeners&lt;/code&gt;，其中的&lt;code&gt;add&lt;/code&gt;方法会调用&lt;code&gt;vm.$on&lt;/code&gt;，&lt;code&gt;vm.$on&lt;/code&gt;会监听当前实例上的自定义事件，&lt;code&gt;remove&lt;/code&gt;会调用&lt;code&gt;vm.$off&lt;/code&gt;，移出这个事件监听&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function add (event, fn) {
  target.$on(event, fn)
}

function remove (event, fn) {
  target.$off(event, fn)
}

export function updateComponentListeners (
  vm: Component,
  listeners: Object,
  oldListeners: ?Object
) {
  // 保存当前的vm引用
  target = vm
  // 传入listeners，父组件绑定在当前组件上的事件，oldListeners同理，不过在第一次初始化的时候为空
  // 其内部会遍历listeners调用add方法添加监听事件，同时移出oldListeners
  updateListeners(listeners, oldListeners || {}, add, remove, createOnceHandler, vm)
  target = undefined
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt; 1.3initRender &lt;/h3&gt;

&lt;p&gt;主要是添加了一些虚拟dom、&lt;code&gt;slot&lt;/code&gt;等相关的属性和方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function initRender (vm: Component) {
  // 表示虚拟dom节点
  vm._vnode = null 
  // 表示当前实例render得到的Vnode
  vm._staticTrees = null 
  const options = vm.$options
  const parentVnode = vm.$vnode = options._parentVnode  tree
  const renderContext = parentVnode &amp;amp;&amp;amp; parentVnode.context
  // 生成插槽内容
  vm.$slots = resolveSlots(options._renderChildren, renderContext)
  // 作用域插槽，此时为空
  vm.$scopedSlots = emptyObject
  vm._c = (a, b, c, d) =&amp;gt; createElement(vm, a, b, c, d, false)
  vm.$createElement = (a, b, c, d) =&amp;gt; createElement(vm, a, b, c, d, true)
  const parentData = parentVnode &amp;amp;&amp;amp; parentVnode.data
	......
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;resolveSlots&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function resolveSlots (
  children: ?Array&amp;lt;VNode&amp;gt;,
  context: ?Component
): { [key: string]: Array&amp;lt;VNode&amp;gt; } {
  if (!children || !children.length) {
    return {}
  }
  const slots = {}
  // 遍历当前节点chilren
  for (let i = 0, l = children.length; i &amp;lt; l; i++) {
    const child = children[i]
    // 获取data
    const data = child.data
    if (data &amp;amp;&amp;amp; data.attrs &amp;amp;&amp;amp; data.attrs.slot) {
      delete data.attrs.slot
    }
    if ((child.context === context || child.fnContext === context) &amp;amp;&amp;amp;
      data &amp;amp;&amp;amp; data.slot != null
    ) {
      // 拿到插槽名称
      const name = data.slot
      const slot = (slots[name] || (slots[name] = []))
      if (child.tag === &#39;template&#39;) {
        slot.push.apply(slot, child.children || [])
      } else {
        slot.push(child)
      }
    } else {
      // 如果 data.slot 不存在，则是默认插槽的内容，则把对应的 child 添加到 slots.defaults 中
      (slots.default || (slots.default = [])).push(child)
    }
  }
  // 最后过滤一些空内容
  for (const name in slots) {
    if (slots[name].every(isWhitespace)) {
      delete slots[name]
    }
  }
  return slots
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用钩子函数&lt;code&gt;beforeCreate&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt; 1.4initProvide和initInjection &lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === &#39;function&#39;
      ? provide.call(vm)
    : provide;
  }
}
function initInjections (vm) {
  // 获取当前节点上的inject属性
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    toggleObserving(false);
    // 遍历这些属性，defineReactive，将这些属性变成响应式的
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      {
        defineReactive$$1(vm, key, result[key], function () {
          warn(
            &amp;quot;Avoid mutating an injected value directly since the changes will be &amp;quot; +
            &amp;quot;overwritten whenever the provided component re-renders. &amp;quot; +
            &amp;quot;injection being mutated: \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot;&amp;quot;,
            vm
          );
        });
      }
    });
    toggleObserving(true);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt; 1.5initState &lt;/h3&gt;

&lt;p&gt;主要是初始化一些数据和属性，比如&lt;code&gt;props&lt;/code&gt;、&lt;code&gt;methods&lt;/code&gt;、&lt;code&gt;data&lt;/code&gt;、&lt;code&gt;computed&lt;/code&gt;、&lt;code&gt;watch&lt;/code&gt;,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch &amp;amp;&amp;amp; opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化&lt;code&gt;props&lt;/code&gt;属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function initProps (vm, propsOptions) {
  // 获取当前节点的props属性值
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  var isRoot = !vm.$parent;
  // 用于保存当前组件的props里的key，以便之后在父组件更新props时可以直接使用数组迭代
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  if (!isRoot) {
    toggleObserving(false);
  }
  var loop = function ( key ) {
    keys.push(key);
    // validateProp验证当前prop[key]是否propsOptions定义的要求
    var value = validateProp(key, propsOptions, propsData, vm);
    {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          (&amp;quot;\&amp;quot;&amp;quot; + hyphenatedKey + &amp;quot;\&amp;quot; is a reserved attribute and cannot be used as component prop.&amp;quot;),
          vm
        );
      }
      // 添加响应式属性，这样props里面的值改变之后，组件会自动更新视图
      defineReactive$$1(props, key, value, function () {
        if (!isRoot &amp;amp;&amp;amp; !isUpdatingChildComponent) {
          warn(
            &amp;quot;Avoid mutating a prop directly since the value will be &amp;quot; +
            &amp;quot;overwritten whenever the parent component re-renders. &amp;quot; +
            &amp;quot;Instead, use a data or computed property based on the prop&#39;s &amp;quot; +
            &amp;quot;value. Prop being mutated: \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot;&amp;quot;,
            vm
          );
        }
      });
    }
    // static props are already proxied on the component&#39;s prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, &amp;quot;_props&amp;quot;, key);
    }
  };
	// 循环遍历key
  for (var key in propsOptions) loop( key );
  toggleObserving(true);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化&lt;code&gt;methods&lt;/code&gt;属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function initMethods (vm, methods) {
  // props属性用于判断methods中的方法名是否和props的属性重名
  var props = vm.$options.props;
  for (var key in methods) {
    {
      if (typeof methods[key] !== &#39;function&#39;) {
        warn(
          &amp;quot;Method \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot; has type \&amp;quot;&amp;quot; + (typeof methods[key]) + &amp;quot;\&amp;quot; in the component definition. &amp;quot; +
          &amp;quot;Did you reference the function correctly?&amp;quot;,
          vm
        );
      }
      // 如果props中有同名属性，则报错
      if (props &amp;amp;&amp;amp; hasOwn(props, key)) {
        warn(
          (&amp;quot;Method \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot; has already been defined as a prop.&amp;quot;),
          vm
        );
      }
      // 如果key是以$或_开头则，也报错
      if ((key in vm) &amp;amp;&amp;amp; isReserved(key)) {
        warn(
          &amp;quot;Method \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot; conflicts with an existing Vue instance method. &amp;quot; +
          &amp;quot;Avoid defining component methods that start with _ or $.&amp;quot;
        );
      }
    }
    vm[key] = typeof methods[key] !== &#39;function&#39; ? noop : bind(methods[key], vm);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化&lt;code&gt;data&lt;/code&gt;属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function initData (vm) {
  // 获取data属性
  var data = vm.$options.data;
  // 如果data是一个function，则调用getData返回里面的值，否则直接将data属性赋给_data
  data = vm._data = typeof data === &#39;function&#39;
    ? getData(data, vm)
  : data || {};
  // 如果data属性不是一个对象，设置data为空对象，并打印一个warn
  if (!isPlainObject(data)) {
    data = {};
    warn(
      &#39;data functions should return an object:\n&#39; +
      &#39;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#39;,
      vm
    );
  }
  // 获取data keys，props属性，methods属性
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    {
      // 当前data的key如果和methods中的方法重名，抛出警告
      if (methods &amp;amp;&amp;amp; hasOwn(methods, key)) {
        warn(
          (&amp;quot;Method \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot; has already been defined as a data property.&amp;quot;),
          vm
        );
      }
    }
    // 当前data的key如果和props中的属性重名，抛出警告
    if (props &amp;amp;&amp;amp; hasOwn(props, key)) {
      warn(
        &amp;quot;The data property \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot; is already declared as a prop. &amp;quot; +
        &amp;quot;Use prop default value instead.&amp;quot;,
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, &amp;quot;_data&amp;quot;, key);
    }
  }
  // 双向数据绑定data
  observe(data, true /* asRootData */);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化&lt;code&gt;computed&lt;/code&gt;属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function initComputed (vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    // 每个computed key所定义的方法
    var userDef = computed[key];
    // 将该方法赋值给getter变量
    var getter = typeof userDef === &#39;function&#39; ? userDef : userDef.get;
    if (getter == null) {
			// 如果为空，打印错误
      warn(
        (&amp;quot;Getter is missing for computed property \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot;.&amp;quot;),
        vm
      );
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }

    // 如果当前节点computed上未有key这个方法
    if (!(key in vm)) {
      // defineComputed方法主要是为当前节点的computed属性添加响应式更新方法
      // 可以在defineComputed定义最后看到 Object.defineProperty(target, key, sharedPropertyDefinition) 
      defineComputed(vm, key, userDef);
    } else {
      if (key in vm.$data) {
        warn((&amp;quot;The computed property \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot; is already defined in data.&amp;quot;), vm);
      } else if (vm.$options.props &amp;amp;&amp;amp; key in vm.$options.props) {
        warn((&amp;quot;The computed property \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot; is already defined as a prop.&amp;quot;), vm);
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化&lt;code&gt;watch&lt;/code&gt;属性比较简单，在做了相应的判断后直接添加一个响应式更新属性，这里不多赘述，调用完&lt;code&gt;initState&lt;/code&gt;之后，会调用&lt;code&gt;created&lt;/code&gt;钩子函数，此时&lt;code&gt;vm&lt;/code&gt;上的属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// _init
vm._uid = 0
vm._isVue = true
vm.$options = {
  components: {
    KeepAlive,
    Transition,
    TransitionGroup
  },
  directives: {
    model,
    show
  },
  methods: {},
  computed: {},
  watch: {},
  filters: {},
  _base: Vue,
  el: &#39;#app&#39;,
  data: function mergedInstanceDataFn(){}
}
vm._renderProxy = vm
vm._self = vm

// initLifecycle
vm.$parent = parent
vm.$root = parent ? parent.$root : vm

vm.$children = []
vm.$refs = {}

vm._watcher = null
vm._inactive = null
vm._directInactive = false
vm._isMounted = false
vm._isDestroyed = false
vm._isBeingDestroyed = false

// initEvents	
vm._events = Object.create(null)
vm._hasHookEvent = false

// initRender
vm.$vnode = null  
vm._vnode = null
vm._staticTrees = null
vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext)
vm.$scopedSlots = emptyObject

vm._c = (a, b, c, d) =&amp;gt; createElement(vm, a, b, c, d, false)

vm.$createElement = (a, b, c, d) =&amp;gt; createElement(vm, a, b, c, d, true)
// 在 initState 中添加的属性
vm._watchers = []
vm._data
vm.message
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行完上面步骤后，会调用&lt;code&gt;vm.$mount&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 保存之前定义的$mount方法，然后重写Vue.prototype.$mount
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  // 查找当前节点
  el = el &amp;amp;&amp;amp; query(el)

 	// 如果事body元素或者documentElement元素则抛错
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; warn(
      `Do not mount Vue to &amp;lt;html&amp;gt; or &amp;lt;body&amp;gt; - mount to normal elements instead.`
    )
    return this
  }
	
  // 拿到options
  const options = this.$options
  // 如果节点上没有render函数
  if (!options.render) {
    // 获取template，template可以是#id、模板字符串、dom元素
    let template = options.template
    if (template) {
      if (typeof template === &#39;string&#39;) {
        if (template.charAt(0) === &#39;#&#39;) {
          // 获取templatge innerHTML
          template = idToTemplate(template)
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) {
        // 如果不是#id、模板字符串，直接获取其innerHTML
        template = template.innerHTML
      } else {
        if (process.env.NODE_ENV !== &#39;production&#39;) {
          warn(&#39;invalid template option:&#39; + template, this)
        }
        return this
      }
    } else if (el) {
      // 如果没有template，则获取el以及其子内容作为模板
      template = getOuterHTML(el)
    }
    if (template) {
      ......
    }
  }
  // 有render函数，直接执行mount.call(this, el, hydrating)
  return mount.call(this, el, hydrating)
}

function getOuterHTML (el: Element): string {
  if (el.outerHTML) {
    return el.outerHTML
  } else {
    const container = document.createElement(&#39;div&#39;)
    container.appendChild(el.cloneNode(true))
    return container.innerHTML
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面最后调用了&lt;code&gt;mount.call(this, el, hydrating)&lt;/code&gt;，其方法对应于&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el &amp;amp;&amp;amp; inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}

  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el
	......
  // 调用beforeMount钩子函数
  callHook(vm, &#39;beforeMount&#39;)

  let updateComponent
	
  ......
  
  // 更新当前节点的方法
  updateComponent = () =&amp;gt; {
    // vm._render会返回一个render字符串，_update其内部会调用patch方法来进行节点的增删改
    vm._update(vm._render(), hydrating)
  }

	// 创建一个watch对象，在调用updateComponent之前会先调用before方法
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted &amp;amp;&amp;amp; !vm._isDestroyed) {
        // 如果是更新节点，调用beforeUpdate钩子函数
        callHook(vm, &#39;beforeUpdate&#39;)
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

   // 当页面渲染完成后，调用钩子函数mounted
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, &#39;mounted&#39;)
  }
  return vm
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>