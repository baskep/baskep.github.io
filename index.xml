<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>😳 on 😳</title>
    <link>https://xtid.github.io/</link>
    <description>Recent content in 😳 on 😳</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 07 Sep 2020 22:03:34 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Webpack打包优化</title>
      <link>https://xtid.github.io/2020/webpack%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 07 Sep 2020 22:03:34 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/webpack%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/</guid>
      <description>&lt;p&gt;之前了解了&lt;code&gt;webpack&lt;/code&gt;的基本打包流程或者说原理，如果只是配置一个基本的&lt;code&gt;webpack&lt;/code&gt;打包配置，
打包后的文件会变得很大，当你项目部署后，用户打开对应的界面，也许会很长时间才加载完(当然和网络环境或硬件设备也有关系)，尤其是单页面应用效果很明显，这样的用户体验自然是不好的，所以此文章主要是对&lt;code&gt;webpack&lt;/code&gt;打包优化的一个小小总结&lt;/p&gt;

&lt;p&gt;首先搭建好一个基本的项目，目录结构&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;├── dist // 打包目录
│   ├── bundle.js // 打包后的js
│   └── index.html // 入口html文件
├── package-lock.json
├── package.json
├── public
│   └── index.html // html模板文件
├── src
│   ├── actions // redux actions文件
│   │   └── index.js
│   ├── app.js // webpack打包入口文件，也是项目的入口文件
│   ├── assets // scss
│   │   ├── about.scss
│   │   ├── title.scss
│   │   └── user.scss
│   ├── dev.js // 开发时的一些配置
│   ├── pages // page页面
│   │   ├── about.jsx
│   │   ├── index.jsx
│   │   ├── title.jsx
│   │   └── user.jsx
│   ├── reducers // redux中的reducer
│   │   └── index.js
│   └── store.js
└── webpack.config.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt;基本配置如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const path = require(&#39;path&#39;)
const HtmlWebPackPlugin = require(&#39;html-webpack-plugin&#39;)

module.exports = {
  entry: &#39;./src/app.js&#39;,
  output: {
    path: path.resolve(__dirname, &#39;./dist/&#39;),
    filename: &#39;bundle.js&#39;
  },
  resolve: {
    extensions: [&#39;.wasm&#39;, &#39;.mjs&#39;, &#39;.js&#39;, &#39;.json&#39;, &#39;.jsx&#39;]
  },

  devServer: {
    contentBase: path.join(__dirname, &#39;./src/&#39;),
    publicPath: &#39;/&#39;,
    host: &#39;127.0.0.1&#39;,
    port: 3000,
    hot: true,
    stats: {
      colors: true
    }
  },
  module: {
    rules: [{
      test: /\.jsx?$/,
      exclude: /node_modules/,
      use: {
        loader: &#39;babel-loader&#39;
      }
    }, {
      test: /\.scss$/,
      use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;]
    }]
  },
  plugins: [
    new HtmlWebPackPlugin({
      template: &#39;public/index.html&#39;,
      filename: &#39;index.html&#39;,
      inject: true
    })
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优化：&lt;/p&gt;

&lt;p&gt;1.基础优化&lt;/p&gt;

&lt;p&gt;配置&lt;code&gt;loader&lt;/code&gt;，添加&lt;code&gt;exclude&lt;/code&gt;、&lt;code&gt;include&lt;/code&gt;缩小搜索范围，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  test: /\.jsx?$/,
    exclude: /node_modules/, // 过滤node_modules
      use: {
        loader: &#39;babel-loader&#39;
      }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.使用&lt;code&gt;DllPlugin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;将一些变动较少或者根本不会变动的库先打包生成对应的&lt;code&gt;.dll.js&lt;/code&gt;，在&lt;code&gt;webpack&lt;/code&gt;打包的时候，将这些资源引入&lt;/p&gt;

&lt;p&gt;首先新建一个&lt;code&gt;webpack.config.dll.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const path = require(&#39;path&#39;);
const DllPlugin = require(&#39;webpack/lib/DllPlugin&#39;);

module.exports = {
  entry: {
    react: [&#39;react&#39;, &#39;react-dom&#39;]
  },
  output: {
    filename: &#39;[name].dll.js&#39;,
    // 生成的文件目录
    path: path.resolve(__dirname, &#39;dist&#39;),
    // 动态链接库名称
    library: &#39;_dll_[name]&#39;
  },
  plugins: [
    new DllPlugin({
      name: &#39;_dll_[name]&#39;,
      path: path.join(__dirname, &#39;dist&#39;, &#39;[name].manifest.json&#39;),
      context: __dirname, 
    })
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在&lt;code&gt;package.json&lt;/code&gt;的&lt;code&gt;scripts&lt;/code&gt;中添加dll打包命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;webpack --config webpack.config.dll.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后运行此命令，可以看到会在&lt;code&gt;dist&lt;/code&gt;目录下面生成&lt;code&gt;react.dll&lt;/code&gt;，&lt;code&gt;react.manifest.json&lt;/code&gt;两个文件，这就是生成的&lt;code&gt;dll&lt;/code&gt;文件，然后&lt;code&gt;webpack.config.js&lt;/code&gt;里面添加配置，打包时引入这些的&lt;code&gt;dll&lt;/code&gt;文件。&lt;/p&gt;

&lt;p&gt;首先安装插件&lt;code&gt;add-asset-html-webpack-plugin&lt;/code&gt;，引入&lt;code&gt;DllReferencePlugin&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const DllReferencePlugin = require(&#39;webpack/lib/DllReferencePlugin&#39;)
const AddAssetHtmlPlugin = require(&#39;add-asset-html-webpack-plugin&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;插件里面配置(webpack4+)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;new DllReferencePlugin({
  context: __dirname,
  manifest: require(&#39;./dist/react.manifest.json&#39;),
}),
new AddAssetHtmlPlugin({
  filepath: path.resolve(__dirname, &#39;./dist/react.dll.js&#39;)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样打包时页面就会引入&lt;code&gt;react.dll.js&lt;/code&gt;资源了，从而减少重复的资源打包。这种方式可以简单的理解为，抽出公共模块打包，然后引入&lt;/p&gt;

&lt;p&gt;3.&lt;code&gt;splitChunks&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以前&lt;code&gt;webpack&lt;/code&gt;拆分模块还会用&lt;code&gt;CommonsChunkPlugin&lt;/code&gt;，在&lt;code&gt;webpack4&lt;/code&gt;后，可以直接用&lt;code&gt;splitChunks&lt;/code&gt;来代替完成这项工作，在&lt;code&gt;optimization&lt;/code&gt;里面设置了&lt;code&gt;splitChunks&lt;/code&gt;后，打包分割出来的文件是默认压缩过的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;splitChunks: {
  chunks: &amp;quot;async&amp;quot;, // &amp;quot;initial&amp;quot; | &amp;quot;all&amp;quot; | &amp;quot;async&amp;quot;，对哪种代码进行分割
  minSize: 30000, // 超过minSize的包才做代码分割
  minChunks: 1, // 一个包至少被用了多少次的时候才进行代码分割
  maxAsyncRequests: 5, // 按需加载最多能加载多少个模块
  maxInitialRequests: 3, // 对于entry里面的文件做代码分割最多能生成多少个js文件
  automaticNameDelimiter: &#39;~&#39;, // 文件生成时的连接符
  name: true, // 为true的时候，打包出来的文件名由cacheGroups里面设置的为准
  cacheGroups: {
    vendors: {
      test: /[\\/]node_modules[\\/]/, // 匹配哪些需要分割的模块
      priority: -10, // 优先级
     	filename: &#39;vendors.js&#39;// 打包到一个叫vendors.js的文件
    },
    default: {
      minChunks: 2,
      priority: -20,
      reuseExistingChunk: true
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.&lt;code&gt;catch-loader&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在一些性能开销较大的&lt;code&gt;loader&lt;/code&gt;之前添加此 &lt;code&gt;loader&lt;/code&gt;，以将结果缓存到磁盘里，不做过多介绍&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
  module: {
    rules: [
      {
        test: /\.ext$/,
        use: [
          &#39;cache-loader&#39;,
          ...loaders
        ],
        include: path.resolve(&#39;src&#39;)
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.&lt;code&gt;HappyPack&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HappyPack&lt;/code&gt;使用&lt;code&gt;node&lt;/code&gt;多线程进行构建来提升构建的速度，使用情况较少&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const HappyPack = require(&#39;happypack&#39;)
const os = require(&#39;os&#39;)
const happyThreadPool = HappyPack.ThreadPool({
  size: os.cpus().length
})

......
plugins: [
  new HtmlWebPackPlugin({
    template: &#39;public/index.html&#39;,
    filename: &#39;index.html&#39;,
    inject: true
  }),
  new HappyPack({
    id: &#39;happyBabel&#39;,
    loaders: [{
      loader: &#39;babel-loader?cacheDirectory=true&#39;,
    }],
    threadPool: happyThreadPool,
    verbose: true,
  })
],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.&lt;code&gt;css&lt;/code&gt;的压缩&lt;/p&gt;

&lt;p&gt;对于&lt;code&gt;scss&lt;/code&gt;文件，一般来讲，依次配置&lt;code&gt;sass-loader&lt;/code&gt;、&lt;code&gt;css-loader&lt;/code&gt;、&lt;code&gt;style-loader&lt;/code&gt;来进行处理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  test: /\.scss$/,
  use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后加载完后的页面&lt;code&gt;css&lt;/code&gt;会以内联样式的形式签入到页面中。在&lt;code&gt;webpack4&lt;/code&gt;中使用&lt;code&gt;mini-css-extract-plugin&lt;/code&gt;插件来提取、压缩&lt;code&gt;css&lt;/code&gt;。首先将&lt;code&gt;style-loade&lt;/code&gt;用&lt;code&gt;MiniCssExtractPlugin.loader&lt;/code&gt;代替，然后使用&lt;code&gt;MiniCssExtractPlugin&lt;/code&gt;插件，打包出对应的文件，并在页面中引入对应的&lt;code&gt;css&lt;/code&gt;文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;)

......

{
  test: /\.scss$/,
  use: [MiniCssExtractPlugin.loader, &#39;css-loader&#39;, &#39;sass-loader&#39;]
}

new MiniCssExtractPlugin({
  filename: &#39;[name].[hash:5].css&#39;,
  chunkFilename: &#39;[id].[hash:5].css&#39;
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.图片的处理&lt;/p&gt;

&lt;p&gt;同样的，先用&lt;code&gt;file-loader&lt;/code&gt;解析图片保证webpack能处理，然后可以用&lt;code&gt;image-webpack-loader&lt;/code&gt;压缩图片，或者说用&lt;code&gt;url-loader&lt;/code&gt;将图片转为&lt;code&gt;base64&lt;/code&gt;编码的形式，不多赘述&lt;/p&gt;

&lt;p&gt;8.CDN加速
通常在打包中，把不变的一些静态文件放到&lt;code&gt;CDN&lt;/code&gt;上，可以直观地减小资源包大小，比如项目中用到了&lt;code&gt;clipboard.js&lt;/code&gt;，然后在模板&lt;code&gt;html&lt;/code&gt;中引入这个文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;script src=&amp;quot;https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.6/clipboard.min.js&amp;quot; defer&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般来讲，这种方式引入js静态文件，那么全局对象(如window)里面是会有对应的对象的，就可以直接引用对应的对象。当然还可以加上&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;externals: {
  clipboard: &#39;clipboard&#39;
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就保证了打包时不打包&lt;code&gt;clipboard&lt;/code&gt;，优化打包后的文件体积&lt;/p&gt;

&lt;p&gt;还有一种方式就是把所有的静态资源，如&lt;code&gt;js&lt;/code&gt;、&lt;code&gt;css&lt;/code&gt;都放在相应的&lt;code&gt;CDN&lt;/code&gt;上，在打包的&lt;code&gt;config&lt;/code&gt;中指定对应资源的&lt;code&gt;CDN&lt;/code&gt;域名，同样配置&lt;code&gt;externals&lt;/code&gt;。但其实这种方式有个很大的缺点就是，如果全部这样做的话，万一&lt;code&gt;CDN&lt;/code&gt;挂了，整个页面也就挂了&lt;/p&gt;

&lt;p&gt;9.按需加载&lt;/p&gt;

&lt;p&gt;以&lt;code&gt;react&lt;/code&gt;为例，使用&lt;code&gt;react-loadable&lt;/code&gt;来做按需加载，以前还有些其它方法这里就不赘述。主要是针对&lt;code&gt;react-router&lt;/code&gt;做一个处理，首先安装依赖&lt;code&gt;react-loadable&lt;/code&gt;，入口文件中封装一个&lt;code&gt;loading&lt;/code&gt;组件，用于页面加载时给一个提示，然后封装一个方法，用于异步加载这些组件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import Loadable from &#39;react-loadable&#39;
const Loading = (props) =&amp;gt; {
  return &amp;lt;div&amp;gt;这是一个loading组件&amp;lt;/div&amp;gt;
};
const asyncLoad = loader =&amp;gt; Loadable({
  loader,
  loading: Loading
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下有三个页面，&lt;code&gt;index&lt;/code&gt;、&lt;code&gt;about&lt;/code&gt;、&lt;code&gt;user&lt;/code&gt;，调用&lt;code&gt;asyncLoad&lt;/code&gt;，引入这些文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const Index = asyncLoad(() =&amp;gt; import(&#39;./pages/index&#39;))
const About = asyncLoad(() =&amp;gt; import(&#39;./pages/about&#39;))
const User = asyncLoad(() =&amp;gt; import(&#39;./pages/user&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再配置好路由，这样打包出来的&lt;code&gt;js&lt;/code&gt;文件就只会在对应页面或者说对应路由命中时加载了，从而提升页面的一个加载速度，当然也把打包出来的js文件进一步的分割，减小体积，当然需要注意的是，要在&lt;code&gt;webpack.config&lt;/code&gt;里面配置好&lt;code&gt;chunFilename(按需加载的chunk名字)&lt;/code&gt;，资源的&lt;code&gt;publickPath&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;Router&amp;gt;
  &amp;lt;Switch&amp;gt;
  	&amp;lt;Route path=&amp;quot;/&amp;quot; exact component={Index} /&amp;gt;
    &amp;lt;Route path=&amp;quot;/about/&amp;quot; component={About} /&amp;gt;
    &amp;lt;Route path=&amp;quot;/users/&amp;quot; component={User} /&amp;gt;
  &amp;lt;/Switch&amp;gt;
&amp;lt;/Router&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;webpack.config.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;output: {
  path: path.resolve(__dirname, &#39;./dist/&#39;),
  filename: &#39;[name].[hash:5].bundle.js&#39;,
  chunkFilename: &#39;[name].[hash:5].bundle.js&#39;,
  publicPath: &#39;/&#39;
},
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Webpack简单理解</title>
      <link>https://xtid.github.io/2020/webpack%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</link>
      <pubDate>Sun, 23 Aug 2020 21:36:20 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/webpack%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</guid>
      <description>&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt;是一个模块打包器，老一点的还有&lt;code&gt;gulp&lt;/code&gt;、&lt;code&gt;grunt&lt;/code&gt;等等，
他最显著的特点就是将文件视为一个个模块，通过设置入口文件&lt;code&gt;entry&lt;/code&gt;，加载不同类型的文件用不同&lt;code&gt;loader&lt;/code&gt;转换文件，
然后使用不同&lt;code&gt;plugin&lt;/code&gt;对文件处理，最后输出多个打包、分割后的文件&lt;/p&gt;

&lt;p&gt;首先有几个概念
1.entry：即&lt;code&gt;webpack&lt;/code&gt;打包的入口，告诉它应该从那个文件开始进行构建
2.output：设置打包后文件的输出路径以及如何命名这些文件
3.loader：处理那些非&lt;code&gt;javaScript&lt;/code&gt;文件，通过指定对应文件所需的对应&lt;code&gt;loader&lt;/code&gt;的处理，将文件转换为&lt;code&gt;webpack&lt;/code&gt;能够处理的有效模块
4.plugins：转换某些类型的模块，功能强大，可以做到打包优化，压缩以及各种各样的其它任务&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bundle&lt;/code&gt;：视为&lt;code&gt;webpack&lt;/code&gt;打包提取的模块生成的&lt;code&gt;js&lt;/code&gt;文件，将其它具体模块的代码传入其中执行，原本独立的模块文件，通过调用&lt;code&gt;__webpack_require__&lt;/code&gt;，合并到了&lt;code&gt;bundle&lt;/code&gt;中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function(modules) {
/******/    var installedModules = {};
/******/
/******/    var installedChunks = {
/******/        2: 0
/******/    };
/******/
/******/    function __webpack_require__(moduleId) {
/******/
/******/        if(installedModules[moduleId]) {
/******/            return installedModules[moduleId].exports;
/******/        }
/******/        var module = installedModules[moduleId] = {
/******/            i: moduleId,
/******/            l: false,
/******/            exports: {}
/******/        };
/******/
/******/        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/        module.l = true;
/******/
/******/        return module.exports;
/******/    }
/******/ })
/************************************************************************/
/******/ ({
	// 传入的模块
	......
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打包后的&lt;code&gt;bundle&lt;/code&gt;是一个立即执行的匿名函数，其参数就是打包后的模块，上面&lt;code&gt;__webpack_require__&lt;/code&gt;方法会首先判断当前模块&lt;code&gt;moduleId&lt;/code&gt;是否已经存在缓存&lt;code&gt;installedModules&lt;/code&gt;中，若是存在则直接返回。若是不存在，则会构造一个对象并将其同时存到&lt;code&gt;installedModules&lt;/code&gt;中和&lt;code&gt;module&lt;/code&gt;中&lt;/p&gt;

&lt;p&gt;&lt;code&gt;modules[moduleId].call(module.exports, module, module.exports, __webpack_require__)&lt;/code&gt;
这段代码首先执行当前模块的具体代码，传入&lt;code&gt;module&lt;/code&gt;，&lt;code&gt;module.exports&lt;/code&gt;，&lt;code&gt;__webpack_require__&lt;/code&gt;，递归调用&lt;code&gt;__webpack_require__&lt;/code&gt;处理每个模块种引入的其它模块
如以下形式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/***/ 0:
/***/ (function(module, exports, __webpack_require__) {
	......
	__webpack_require__(1);
	module.exports = __webpack_require__(2);
	......

/***/ })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个简单的bundle构建过程：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 引入相关依赖，对文件进行编译转换输出处理
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);
const parse = require(&#39;@babel/parser&#39;);
const traverse = require(&#39;@babel/traverse&#39;).default;
const babel = require(&#39;@babel/core&#39;);


let ID = 0;
// 读取文件信息，并获得当前js文件的依赖关系
function createAsset(filename) {
  // 获取文件，返回值是字符串
  const content = fs.readFileSync(filename, &#39;utf-8&#39;);

  // 将字符串转为ast
  const ast = parse.parse(content, {
    sourceType: &#39;module&#39;
  });

  //用来存储 文件所依赖的模块，简单来说就是，当前js文件 import 了哪些文件，都会保存在这个数组里
  const dependencies = [];

  //遍历当前ast（抽象语法树）
  traverse(ast, {
    //找到有 import语法 的对应节点
    ImportDeclaration: ({ node }) =&amp;gt; {
      //把当前依赖的模块加入到数组中
      dependencies.push(node.source.value);
    }
  });

  //模块的id 从0开始， 相当一个js文件 可以看成一个模块
  const id = ID++;

  //这边主要把ES6 的代码转成 ES5
  const { code } = babel.transformFromAstSync(ast, null, {
    presets: [&#39;@babel/preset-env&#39;]
  });

  return {
    id,
    filename,
    dependencies,
    code
  };
}

// 从入口开始分析所有依赖项，形成依赖图，采用广度遍历
function createGraph(entry) {
  const mainAsset = createAsset(entry);
    
  const queue = [mainAsset];

  for (const asset of queue) {
    const dirname = path.dirname(asset.filename);
    // 新增一个属性来保存子依赖项的数据
    asset.mapping = {};
    asset.dependencies.forEach(relativePath =&amp;gt; {
      const absolutePath = path.join(dirname, relativePath);
      //获得子依赖（子模块）的依赖项、代码、模块id，文件名
      const child = createAsset(absolutePath);
      //给子依赖项赋值，
      asset.mapping[relativePath] = child.id;
      //将子依赖也加入队列中，广度遍历
      queue.push(child);
    });
  }
  return queue;
}

//根据生成的依赖关系图，生成对应环境能执行的代码，目前是生产浏览器可以执行的
function bundle(graph) {
  let modules = &#39;&#39;;

  //循环依赖关系，并把每个模块中的代码存在function作用域里
  graph.forEach(mod =&amp;gt; {
    modules += `${mod.id}:[
      function (require, module, exports){
        ${mod.code}
      },
      ${JSON.stringify(mod.mapping)},
    ],`;
  });

  //require, module, exports 是 cjs的标准不能再浏览器中直接使用，所以这里模拟cjs模块加载，执行，导出操作。
  const result = `
    (function(modules){
      //创建require函数， 它接受一个模块ID（这个模块id是数字0，1，2） ，它会在我们上面定义 modules 中找到对应是模块.
      function __webpack_require__(id){
        const [fn, mapping] = modules[id];
        function localRequire(relativePath){
          //根据模块的路径在mapping中找到对应的模块id
          return __webpack_require__(mapping[relativePath]);
        }
        const module = {exports:{}};
        //执行每个模块的代码。
        fn(localRequire,module,module.exports);
        return module.exports;
      }
      //执行入口文件，
      __webpack_require__(0);
    })({${modules}})
  `;

  return result;
}

// 入口文件
const graph = createGraph(&#39;./entry.js&#39;);
// 文件内容
const ret = bundle(graph);

// 打包生成文件
fs.writeFileSync(&#39;./bundle.js&#39;, ret);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;loader&lt;/code&gt;，通过设置对应的&lt;code&gt;rule&lt;/code&gt;，使用不同的&lt;code&gt;loader&lt;/code&gt;来转换、处理不同的组件，比如&lt;code&gt;css&lt;/code&gt;文件使用&lt;code&gt;css-loader&lt;/code&gt;以及&lt;code&gt;style-loader&lt;/code&gt;来处理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  test: /\.css$/,
  loader: &#39;style-loader!css-loader&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外，还有一种内联&lt;code&gt;loader&lt;/code&gt;的形式，即&lt;code&gt;import loader from &#39;......&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;两种方式处理的顺序也不同，大致流程为
1.&lt;code&gt;webpack&lt;/code&gt;启动后，创建新的&lt;code&gt;compilation&lt;/code&gt;
2.实例化&lt;code&gt;rules&lt;/code&gt;
3.解析&lt;code&gt;inline loaders&lt;/code&gt;
4.解析&lt;code&gt;config&lt;/code&gt;配置里面的&lt;code&gt;loaders&lt;/code&gt;
5.组合这两种形式的&lt;code&gt;loader&lt;/code&gt;，最终输出上诉第一种形式的配置
6.使用&lt;code&gt;Loader-runner&lt;/code&gt;按配置执行&lt;code&gt;loader&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以下简单写一个&lt;code&gt;loader&lt;/code&gt;，首先写一个方法用于加载&lt;code&gt;loader&lt;/code&gt;，并处理传入的模块，然后返回处理完了之后的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let source = ...... // source为获取到的模块的代码
function loaderModule(loaderName) {
  // 获取loader路径
  const loaderPath = path.join(process.cwd(), loaderName)
  const loader = require(loaderPath)
  source = loader.call(_this, source)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义一个规则&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;rules: [{
  test:/\.js/,
  use:[
    &#39;./loaderModule.js&#39;, // loader的路径
  ]
}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行的时候遍历&lt;code&gt;rules&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;for (let i = rules.length - 1; i &amp;gt;= 0; i--) {
  const { test, use } = rules[i]
  if (test.test(modulePath)) {
    // 使用多个loader
    if (Array.isArray(use)) {
      for (let j = use.length - 1; j &amp;gt;= 0; j--) {
        loaderModule(use[j])
      }
    } else if (typeof use === &#39;string&#39;) {
      loaderModule(use)
      // 带参数型的loader
    } else if (use instanceof Object) {
      loaderModule(use.loader, {
        query: use.options
      })
    }
  }
}

// loaderModule.js内容
// loader-utils是webpack一个工具类，用于解析loader，获取配置的一些loader参数
const loaderUtils = require(&#39;loader-utils&#39;)

// 这个简单的loader会将js文件里面的hello字符串替换成word
module.exports = function (source) {
  const optionsName = loaderUtils.getOptions(this) &amp;amp;&amp;amp; loaderUtils.getOptions(this).name || &#39;world&#39;
  return source.replace(/hello/g, optionsName)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面是一个同步的&lt;code&gt;loader&lt;/code&gt;，如果想写一个异步的&lt;code&gt;loader&lt;/code&gt;，可以在&lt;code&gt;loader&lt;/code&gt;内部调用&lt;code&gt;async&lt;/code&gt;方法，然后在处理之后调用对应的回调方法处理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = function (source) {
  const optionsName = loaderUtils.getOptions(this) &amp;amp;&amp;amp; loaderUtils.getOptions(this).name || &#39;world&#39;
  cosnt callback = this.async()

  // 操作完了之后，调用callback返回结果进入下一个loader
  asyncOperation(source, optionsName, function(err, result) {
    if（err）return callback(err)
    callback(err, result)
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不用上面的方式，返回一个&lt;code&gt;promise&lt;/code&gt;也是可以的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = function (source) {
  const optionsName = loaderUtils.getOptions(this) &amp;amp;&amp;amp; loaderUtils.getOptions(this).name || &#39;world&#39;
  return new Promise(resolve =&amp;gt; {
    asyncOperation(source, function(err, result) {
      if (err) resolve(err)
      resolve(err, result)
    })
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;plugin&lt;/code&gt;
&lt;code&gt;plugin&lt;/code&gt;进一步拓展了&lt;code&gt;webpack&lt;/code&gt;的功能，比如打包优化和压缩，清空当前项目的目录，重新定义环境变量，将代码输出到某个文件，提取功能模块等等&lt;/p&gt;

&lt;p&gt;定义一个&lt;code&gt;plugin&lt;/code&gt;的时候，首先要提供一个&lt;code&gt;apply&lt;/code&gt;方法，接受一个&lt;code&gt;compiler&lt;/code&gt;对象，然后注册对应的钩子函数，在回调里面拿到对应参数，然后处理
以下定义一个&lt;code&gt;plugin&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const path = require(&#39;path&#39;)
const fs = require(&#39;fs&#39;)
const cheerio = require(&#39;cheerio&#39;)

class BasePlugin {
  constructor(options){
    // 插件的参数，filename、template等
    this.options = options
  }
  apply(compiler) {
    // 注册afterEmit钩子函数
    compiler.hooks.afterEmit.tap(&#39;BasePlugin&#39;, (compilation) =&amp;gt; {
      // 2. 根据模板读取html文件内容
      const result = fs.readFileSync(this.options.template, &#39;utf-8&#39;)
      
      // 3. 使用 cheerio 来分析 HTML
      let $ = cheerio.load(result)
    
      // 4. 创建 script 标签后插入HTML中
      // compilation.assets代表所有输出的资源文件
      Object.keys(compilation.assets).forEach(item =&amp;gt; {
        $(`&amp;lt;script src=&amp;quot;/${item}&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;`).appendTo(&#39;body&#39;)
      })
    
      // 5. 转换成新的HTML并写入到 dist 目录中
      fs.writeFileSync(path.join(process.cwd(), &#39;dist&#39;, this.options.filename), $.html())
    })
  } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;compiler&lt;/code&gt;对象包含了&lt;code&gt;webpack&lt;/code&gt;环境所有的的配置信息，包含&lt;code&gt;options&lt;/code&gt;，&lt;code&gt;loaders&lt;/code&gt;，&lt;code&gt;plugins&lt;/code&gt;这些信息，这个对象在&lt;code&gt;webpack&lt;/code&gt;启动时候被实例化，它是全局唯一的，可以简单地把它理解为&lt;code&gt;webpack&lt;/code&gt;实例，&lt;code&gt;compilation&lt;/code&gt;对象包含了当前的模块资源、编译生成资源、变化的文件等。当&lt;code&gt;webpack&lt;/code&gt;以开发模式运行时，每当检测到一个文件变化，&lt;code&gt;compilation&lt;/code&gt;就会被重新构建，其它的一些&lt;a href=&#34;https://www.webpackjs.com/api/compiler-hooks/#hooks&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;钩子函数&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;顺便总结一下，实现一个简单的&lt;code&gt;webpack&lt;/code&gt;的步骤
1.定一个基础对象，构造方法里面传入&lt;code&gt;entry&lt;/code&gt;、&lt;code&gt;output&lt;/code&gt;、&lt;code&gt;rules&lt;/code&gt;、&lt;code&gt;plugins&lt;/code&gt;等属性
2.然后定义一系列钩子函数，在&lt;code&gt;webpack&lt;/code&gt;执行中可以调用这些钩子函数做处理，
3.开始执行，初始化对应的钩子函数，传入&lt;code&gt;entry&lt;/code&gt;等相关信息
4.拿到文件源码信息，使用&lt;code&gt;loader&lt;/code&gt;处理，将代码转换成&lt;code&gt;ast&lt;/code&gt;形式
5.&lt;code&gt;traverse&lt;/code&gt;将&lt;code&gt;ast&lt;/code&gt;代码中的&lt;code&gt;require&lt;/code&gt;替换为&lt;code&gt;__webpack_require__&lt;/code&gt;，添加新的&lt;code&gt;module&lt;/code&gt;信息
6.递归处理每一个依赖，重复上面的步骤
7.初始化&lt;code&gt;plugin&lt;/code&gt;，并对文件做处理
8.输入到指定目录
9.客户端/浏览器运行时执行&lt;/p&gt;

&lt;p&gt;参考链接&lt;/p&gt;

&lt;p&gt;1.&lt;a href=&#34;https://juejin.im/post/6844903957769224206&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;webpack原理&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&#34;https://www.webpackjs.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;webpack官方文档&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>