<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>👨🏻‍💻 on 👨🏻‍💻</title>
    <link>https://xtid.github.io/</link>
    <description>Recent content in 👨🏻‍💻 on 👨🏻‍💻</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 03 Aug 2021 22:34:03 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Webpack5的新特性以及项目实战配置</title>
      <link>https://xtid.github.io/2021/webpack5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E4%BB%A5%E5%8F%8A%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Tue, 03 Aug 2021 22:34:03 +0800</pubDate>
      
      <guid>https://xtid.github.io/2021/webpack5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E4%BB%A5%E5%8F%8A%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E9%85%8D%E7%BD%AE/</guid>
      <description>

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;webpack5也已经发布了(2021.08)接进一年了，之前刚出来的时候还有些坑也不敢急着实际应用在项目中，现在官方的bug也修的差不多了，我也实际在项目中运用了下，所以现在做个总结&lt;/p&gt;

&lt;h3 id=&#34;新特性&#34;&gt;新特性&lt;/h3&gt;

&lt;h4 id=&#34;1-用持久性缓存来提高构建性能&#34;&gt;1.用持久性缓存来提高构建性能&lt;/h4&gt;

&lt;p&gt;在webpack4中，我们可以通过cache-loader等手段来将编译的结果写入到磁盘中，现在可以直接通过设置将编译结果缓存到文件系统中&lt;/p&gt;

&lt;p&gt;type：&lt;code&gt;string: &#39;memory&#39; | &#39;filesystem&#39;&lt;/code&gt; ，将 &lt;code&gt;cache&lt;/code&gt; 类型设置为内存或者文件系统&lt;/p&gt;

&lt;p&gt;buildDependencies：&lt;code&gt;object&lt;/code&gt;，针对构建的额外代码依赖的数组对象。webpack 将使用这些项和所有依赖项的哈希值来使文件系统缓存失效&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;cache: {
  type: &#39;filesystem&#39;, // 将缓存类型设置为文件系统，默认为memory
  buildDependencies: {
    config: [__filename], // 这样设置后webpack能获取最新的配置以及依赖项来重新缓存
  },
},
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-对资源实现了内部支持而不需要额外的loader&#34;&gt;2.对资源实现了内部支持而不需要额外的loader&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;asset/resource&lt;/code&gt; 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;asset/inline&lt;/code&gt; 导出一个资源的 data URI。之前通过使用 url-loader 实现。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;asset/source&lt;/code&gt; 导出资源的源代码。之前通过使用 raw-loader 实现。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;asset&lt;/code&gt; 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.export = {
  module: {
    rules: [{
      test: /\.png$/,
      type: &amp;quot;asset/resource&amp;quot;, //对应file-loader
    },
    {
      test: /\.svg$/,
      type: &amp;quot;asset/inline&amp;quot;, //对应url-loader 大小&amp;lt;limt 转化为base64
    },
    {
      test: /\.txt$/,
      type: &amp;quot;asset/source&amp;quot;, //对应raw-loader
    },
    {
      test: /\.gif$/,
      type: &amp;quot;asset&amp;quot;, //自动选择
      parser: {
        dataUrlCondition: {
          maxSize: 4 * 1024,
        },
      },
    }],
  },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-用更好的-tree-shaking-和代码生成来改善包大小&#34;&gt;3.用更好的 Tree Shaking 和代码生成来改善包大小&lt;/h4&gt;

&lt;p&gt;现在的Tree Shaking 能够完全剔除未使用的代码，同样使用ES6模块，并开起production mode；并且现在能处理对 Commonjs 的 tree shaking，&lt;strong&gt;允许消除未使用的CommonJs导出并跟踪require()调用中引用的导出名称&lt;/strong&gt;，在打包出的文件中可以看到最终的代码。&lt;/p&gt;

&lt;h4 id=&#34;4-moduleids-chunkids-content-hash-的优化&#34;&gt;4.moduleIds &amp;amp; chunkIds &amp;amp; content hash 的优化&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;moduleIds &amp;amp; chunkIds的优化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在webpack5以前，没有从entry打包的chunk文件，都会以1，2，3&amp;hellip;的文件命名方式输出，文件名称后的hash值是用chunkhash生成的。这样会造成当删除或者暂时不用1.js这个文件后，那么重新打包时2.js-&amp;gt;1.js,3.js-&amp;gt;2.js，这样会造成原来线上的2.js和3.js缓存失效。&lt;/p&gt;

&lt;p&gt;webpack5为了确保moduleId，chunkId 的确定性， 增加了如下配置：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;optimization.moduleIds&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;选荐值&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;natural&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;按使用顺序的数字 id。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;named&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;对调试更友好的可读的 id。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;deterministic&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;被哈希转化成的小位数值模块名。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;专注于让初始下载包大小更小的数字 id。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code&gt;deterministic&lt;/code&gt; 选项有益于长期缓存，但对比于 &lt;code&gt;hashed&lt;/code&gt; 来说，它会导致更小的文件 bundles。数字值的长度会被选作用于填满最多 80%的 id 空间。 当 &lt;code&gt;optimization.moduleIds&lt;/code&gt; 被设置成 &lt;code&gt;deterministic&lt;/code&gt;，默认最小 3 位数字会被使用。deterministic配置在生产模式下是默认开启）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;optimization.moduleIds = &#39;deterministic&#39;
optimization.chunkIds = &#39;deterministic&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然在开发模式下，可以设置成&lt;code&gt;natural&lt;/code&gt;以保持以前的老模式&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;content hash的优化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;之前使用content hash的时候，当改动文件内容的时候content hash会重新生成；而现在Webpack 5 将使用真正的文件内容哈希值，也就是说当进行了修改注释或者修改变量名等代码逻辑是没有影响的操作时，文件内容的变更不会导致 contenthash 变化。&lt;/p&gt;

&lt;h4 id=&#34;5-支持生成es6-es2015的代码&#34;&gt;5.支持生成ES6/ES2015的代码&lt;/h4&gt;

&lt;p&gt;webpack 4 默认只能输出 ES5 代码，现在支持指定环境，然后生成该环境的一个代码&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;target&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;string&lt;/code&gt; &lt;code&gt;[string]&lt;/code&gt; &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;告知 webpack 为目标(target)指定一个环境。默认值为 &lt;code&gt;&amp;quot;browserslist&amp;quot;&lt;/code&gt;，如果没有找到 browserslist 的配置，则默认为 &lt;code&gt;&amp;quot;web&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后我们设置&lt;/p&gt;

&lt;p&gt;&lt;code&gt;target: [&#39;web&#39;, &#39;es5&#39;]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;webpack 将生成 web 平台的运行时代码，并且只使用 ES5 相关的特性&lt;/p&gt;

&lt;h4 id=&#34;6-移除了-node-js-polyfills&#34;&gt;6.移除了 Node.js Polyfills&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;在早期，webpack 的目的是为了让大多数的 Node.js 模块运行在浏览器中，但如今模块的格局已经发生了变化，现在许多模块主要是为前端而编写。webpack &amp;lt;= 4 的版本中提供了许多 Node.js 核心模块的 polyfills，一旦某个模块引用了任何一个核心模块（如 &lt;code&gt;cypto&lt;/code&gt; 模块），webpack 就会自动引用这些 polyfills。&lt;/p&gt;

&lt;p&gt;尽管这会使得使用为 Node.js 编写模块变得容易，但它在构建时给 bundle 附加了庞大的 polyfills。在大部分情况下，这些 polyfills 并非必须。&lt;/p&gt;

&lt;p&gt;从 webpack 5 开始不再自动填充这些 polyfills，而会专注于前端模块兼容。我们的目标是提高 web 平台的兼容性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;迁移&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;尽量使用前端兼容的模块。&lt;/li&gt;
&lt;li&gt;可以手动为 Node.js 核心模块添加 polyfill。错误提示会告诉你如何实现。&lt;/li&gt;
&lt;li&gt;Package 作者：在 &lt;code&gt;package.json&lt;/code&gt; 中添加 &lt;code&gt;browser&lt;/code&gt; 字段，使 package 与前端兼容。为浏览器提供其他的实现/dependencies。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;7-module-federation&#34;&gt;7.Module Federation&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;多个独立的构建可以组成一个应用程序，这些独立的构建之间不应该存在依赖关系，因此可以单独开发和部&amp;gt;署它们。&lt;/p&gt;

&lt;p&gt;这通常被称作微前端，但并不仅限于此。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单来说就是允许一个应用中动态地去加载和引入另一个应用的代码，就好像本地起一个应用作CDN库，其它地方去引用，具体可以看&lt;a href=&#34;https://webpack.docschina.org/concepts/module-federation/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;官方配置&lt;/a&gt;，个人感觉并不是特别的实用&lt;/p&gt;

&lt;h3 id=&#34;项目实战&#34;&gt;项目实战&lt;/h3&gt;

&lt;p&gt;首先定义一个webpack.config.base.js，即开发环境以及生产环境都需要的配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const path = require(&#39;path&#39;)
const { CleanWebpackPlugin } = require(&#39;clean-webpack-plugin&#39;)
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)
const MiniCssExtractPlugin = require(&amp;quot;mini-css-extract-plugin&amp;quot;)

module.exports = {
  entry: &#39;./src/index.js&#39;, 
  output: {
    filename: &#39;[name].[chunkhash].bundle.js&#39;,
    path: path.resolve(__dirname, &#39;dist&#39;) 
  },
  module: {
    rules: [{
        test: /\.m?js$/,
        exclude: /node_modules/,
        use: {
          loader: &#39;babel-loader&#39;, 
        }
      },
      {
        test: /\.s[ac]ss$/, 
        use: [MiniCssExtractPlugin.loader, &#39;css-loader&#39;, &#39;sass-loader&#39;]
      },
      {
        test: /\.(png|svg|jpg|gif|webp|jfif)$/,
        use: [{
          loader: &#39;url-loader&#39;,
          options: {
            limit: 1024 * 100,
            name: &#39;assets/[name]_[hash:10].[ext]&#39;
          }
        }]
      }
    ]
  },
  plugins: [
    new CleanWebpackPlugin({ // 每次打包前删除dist文件夹中的文件
      cleanOnceBeforeBuildPatterns: [&#39;**/*&#39;, &#39;!favicon.ico&#39;, &#39;!lib/**&#39;], // dist文件夹下的favicon.ico文件和lib文件夹下的东西都忽略不进行删除
    }),
    new HtmlWebpackPlugin({
      template: &#39;index.html&#39;, 
      favicon: &#39;favicon.ico&#39;, 
      inject: &#39;head&#39; 
    }),
    new MiniCssExtractPlugin({
      filename: &#39;[name]-[contenthash].css&#39;
    }),
  ],
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后配置webpack.config.dev.js，开发环境主要配置代理服务器，代码热更新，以及使用最新的缓存特性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const { merge } = require(&#39;webpack-merge&#39;)
const path = require(&#39;path&#39;)
const baseConfig = require(&#39;./webpack.base.js&#39;)
const ReactRefreshPlugin = require(&#39;@pmmmwh/react-refresh-webpack-plugin&#39;)
const webpack = require(&#39;webpack&#39;)

module.exports = merge(baseConfig, {
  mode: &#39;development&#39;,
  devtool: &#39;eval-cheap-module-source-map&#39;,
  devServer: { 
    contentBase: path.resolve(__dirname, &#39;dist&#39;),
    port: &#39;8090&#39;,
    proxy: { 
      &#39;/api&#39;: {
        target: &#39;http://127.0.0.1:3001&#39;,
        pathRewrite: {
          &#39;^/api&#39;: &#39;
        }
      },
    },
    hot: true,
    open: true,
  },
  // 热更新
  plugins: [
    new ReactRefreshPlugin({
      overlay: false,
    }),
    new webpack.HotModuleReplacementPlugin()
  ],
  // 缓存
  cache: {
    type: &#39;filesystem&#39;,
    buildDependencies: {
      config: [__filename],
    },
  },
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后是生产环境的配置，生产环境的配置主要是对代码进行一个压缩&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const { merge } = require(&#39;webpack-merge&#39;) 
const OptimizeCSSAssetsPlugin = require(&amp;quot;optimize-css-assets-webpack-plugin&amp;quot;)
const TerserJSPlugin = require(&amp;quot;terser-webpack-plugin&amp;quot;)
const baseConfig = require(&#39;./webpack.base.js&#39;)

module.exports = merge(baseConfig, {
  mode: &amp;quot;production&amp;quot;,
  optimization: {
    minimizer: [new OptimizeCSSAssetsPlugin({})],
    minimizer: [new TerserJSPlugin({}), new OptimizeCSSAssetsPlugin({})] 
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上就是一个webpack5的基本配置，可以看到除了其内部更新的特性意外，其它的还是可以用原来的loader去配置，主要用到的还是它的缓存的一个功能，当然其它的你也可以按照官方文档进行一个配置&lt;/p&gt;

&lt;h3 id=&#34;参考链接&#34;&gt;参考链接&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://webpack.docschina.org/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;webpack官方网站&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6983985071699001357&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;webpack新特性&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>前端的模块规范简述以及如何实现一个UMD-Loader方法</title>
      <link>https://xtid.github.io/2021/%E5%89%8D%E7%AB%AF%E7%9A%84%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83%E7%AE%80%E8%BF%B0%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAumd-loader%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 10 Jul 2021 16:51:03 +0800</pubDate>
      
      <guid>https://xtid.github.io/2021/%E5%89%8D%E7%AB%AF%E7%9A%84%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83%E7%AE%80%E8%BF%B0%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAumd-loader%E6%96%B9%E6%B3%95/</guid>
      <description>

&lt;p&gt;现在的前端开发中根本离不开组件化、模块化的开发方式，这些模块有各种各样的规范，比如：&lt;/p&gt;

&lt;h4 id=&#34;1-commonjs规范&#34;&gt;1.CommonJS规范&lt;/h4&gt;

&lt;p&gt;主要用在与Nodejs服务端，在服务器端，模块的加载是&lt;strong&gt;运行时&lt;/strong&gt;同步加载的；在浏览器端，模块需要提前编译打包处理。模块本身是&lt;strong&gt;输出的是一个值的拷贝&lt;/strong&gt;，意思就是说拿到模块后，对其中exports的变量进行修改的时候，是不会影响到原来的模块的&lt;/p&gt;

&lt;p&gt;1.1.导出模块&lt;/p&gt;

&lt;p&gt;导出模块的方式有两种，两种写法都可以，&lt;code&gt;module.exports&lt;/code&gt;是对&lt;code&gt;exports&lt;/code&gt;的一个引用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {}

exports.xxx = &#39;xxx&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.2.引入模块&lt;/p&gt;

&lt;p&gt;指的说的一点就是这个路径可以是一个js表达式计算的结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const module = requore(&#39;路径&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-amd规范&#34;&gt;2.AMD规范&lt;/h4&gt;

&lt;p&gt;出现AMD规范的原因是因为CommonJS以服务端同步的方式加载本地的模块(文件)，服务器端所有的模块都存放在本地硬盘中，可以同步加载完成，等待时间就是硬盘的读取时间；而如果在客户端使用这个规范的去请求服务器上的模块资源的时候，请求的时间就取决于当前的网络状态了，加上CommonJS是一个同步的加载，那页面就会阻塞、卡顿，所以也就有了AMD(Asynchronous Module Definition)规范，主要用在客户端&lt;/p&gt;

&lt;p&gt;2.1定义(导出模块)&lt;/p&gt;

&lt;p&gt;定义模块使用&lt;code&gt;define(id?, dependencies?, factory)&lt;/code&gt;方法，id为你自定义模块的名称，dependencies为你当前模块所依赖的其他模块集合的路径数组，factory则是实际的定义模块的方法。也就是说一个简单AMD模块甚至直接传个factory函数就行了，这个回调函数里面的入参是dependencies数组里面加载成功的依赖&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;define(function () {
  return
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.2引入模块&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;require([&#39;module1&#39;, &#39;module2&#39;], function (m1, m2) {
  // 使用module1、module2
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的地方浏览器本身是不支持这个规范的，要使用的话必须依赖于require.js&lt;/p&gt;

&lt;h4 id=&#34;3-cmd规范&#34;&gt;3.CMD规范&lt;/h4&gt;

&lt;p&gt;CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近执行，延迟执行&lt;/p&gt;

&lt;p&gt;3.1定义(导出模块)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;define(id?, dependencies?, factory)&lt;/code&gt;，关于定义它和AMD规范很像，包括入参，不同地方在于&lt;code&gt;factory&lt;/code&gt;回调函数的入参不同&lt;code&gt;require, exports, module&lt;/code&gt;，可以通过这些关键字再导出或者引入相关依赖，然后&lt;code&gt;dependencies&lt;/code&gt;一般不会去使用，通常会在&lt;code&gt;factory&lt;/code&gt;的回调函数中用&lt;code&gt;require&lt;/code&gt;关键字去加载其他的依赖。&lt;/p&gt;

&lt;p&gt;它和AMD规范最大的不同，就是定义模块时，AMD会先去加载&lt;code&gt;dependencies&lt;/code&gt;的内容，然后加载模块本身的内容，CMD的话会加载就近的依赖，意思是遇到了require关键字的时候才会去加载模块。所以使用CMD规范的话，可以将require关键字写在模块的顶层，当然浏览器环境也要依赖与&lt;code&gt;sea.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;define(function (require, exports, module) {
  // require对象可以在模块中引入其他模块
  exports.xxx = value
  module.exports = value
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.ES6的模块规范&lt;/p&gt;

&lt;p&gt;1.导出：ES6模块有两种模块导出方式：命名式导出(名称导出)、默认导出(自定义导出)&lt;/p&gt;

&lt;p&gt;命名式导出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 最基本的
export const a = &#39;1&#39;

// 导出使用别名
const a = &#39;1&#39;
export { a as A }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认导出通常会在export后面加上一个default：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const a = &#39;1&#39;
export default a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.import导入模块&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export const a = &#39;1&#39;
import { a } from &#39;路径&#39;


export default const a = &#39;1&#39;
import a from &#39;./module&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述的&lt;code&gt;Commone.js&lt;/code&gt;、&lt;code&gt;CMD&lt;/code&gt;、&lt;code&gt;AMD&lt;/code&gt;规范的特点就是运行时加载、模块值的拷贝&lt;/p&gt;

&lt;p&gt;而&lt;code&gt;ES6&lt;/code&gt;模块的特点则是静态编译时加载、按需加载、模块值的引用，每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域&lt;/p&gt;

&lt;p&gt;requireJS会先尽早地执行(依赖)模块, 相当于所有的require都被提前了, 而且模块执行的顺序也不一定100%就是先mod1再mod2，所以使用requireJS的时候模块与模块之间应当尽量没有业务或者逻辑的交叉&lt;/p&gt;

&lt;p&gt;5.UMD规范&lt;/p&gt;

&lt;p&gt;所谓UMD (Universal Module Definition)，就是一种javascript通用模块定义规范，让你的模块能在javascript所有运行环境中发挥作用。顾名思义，就是兼容上述所有规范，实现方式是通过判断当前脚本运行环境是否支持相应的关键字来实现的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function (root, factory) {
  if (typeof module === &#39;object&#39; &amp;amp;&amp;amp; typeof module.exports === &#39;object&#39;) {
    module.exports = factory();
  } else if (typeof define === &#39;function&#39; &amp;amp;&amp;amp; define.amd) {
    define(factory())
  } else if (typeof define === &#39;function&#39; &amp;amp;&amp;amp; define.cmd) {
    define(function (require, exports, module) {
      module.exports = factory()
    })
  } else {
    root.curModule = factory();
  }
}(this, function () {
  return {
    name: &#39;我是一个umd模块&#39;
  }
}))

// 然后在使用的地方通过require或者根节点.curModule的形式引用
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际应用场景1：&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;Webpack -&amp;gt; Output&lt;/code&gt;选项中，可以配置library库，我们可以设置打包后的文件暴露出去的模块名，并且可以指定生成支持某个规范的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;output: {
  library: &#39;MyLibrary&#39;, // 暴露出的模块名
  libraryTarget: &#39;amd&#39;, // 指定的规范
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打包代码生成，即生成一个兼容的UMD模块&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === &#39;object&#39; &amp;amp;&amp;amp; typeof module === &#39;object&#39;)
    module.exports = factory();
  else if (typeof define === &#39;function&#39; &amp;amp;&amp;amp; define.amd)
    define([], factory);
  else if (typeof exports === &#39;object&#39;)
    exports[&amp;quot;MyLibrary&amp;quot;] = factory();
  else
    root[&amp;quot;MyLibrary&amp;quot;] = factory();
})(typeof self !== &#39;undefined&#39; ? self : this, function () {
 
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际应用场景2：&lt;/p&gt;

&lt;p&gt;对于一个大型的应用来说，其复杂的应用以及功能用户只会用到一部分，所以，我们可以在适当的时候去请求相应的模块，这些模块的资源放在服务端，从而减轻项目的体量以及减少项目的开发编译时间。对于这些远程的模块，就可以使用UMD模块封装，兼容不同环境，然后本地去请求。&lt;/p&gt;

&lt;p&gt;要做一个umd-loader，通过传入的url、name去加载第三方的模块，然后创建script标签插入到模板文件的head当中，再就是视图里面自己处理逻辑，首先我在本地定义好这个class，确定好相应的加载逻辑&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export class UMDLoader {
  static isExist (name) {
    return window.hasOwnProperty(name)
  }
  static getModule (name) {
    return window[name]
  }
  static getRemoteModule ({ name, url }) {
    if (UMDLoader.isExist(name)) {
      return Promise.resolve(UMDLoader.getModule(name))
    }
    return new Promise((resolve, reject) =&amp;gt; {
      const script = document.createElement(&#39;script&#39;)
      script.type = &#39;module&#39;
      script.url = url
      script.onload = () =&amp;gt; {
        return resolve(UMDLoader.getModule(name))
      }
      script.onerror = () =&amp;gt; {
        return reject(new Error(&#39;加载失败&#39;))
      }
      document.head.appendChild(script)
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在视图代码中使用的时候&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React, { useEffect } from &#39;react
import { UMDLoader } from &#39;路径&#39;

const TestView = () =&amp;gt; {
  useEffect(() =&amp;gt; {
    UMDLoader.getRemoteModule({ url: &#39;js模块地址&#39;, name: &#39;名字&#39; })
      .then((module) =&amp;gt; {
        console.log(module)
      }, (e) =&amp;gt; {
        console.log(e)
      })
  }, [])
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Links</title>
      <link>https://xtid.github.io/links/</link>
      <pubDate>Sun, 10 Jan 2021 23:35:28 +0800</pubDate>
      
      <guid>https://xtid.github.io/links/</guid>
      <description>&lt;p&gt;友情链接&lt;/p&gt;

&lt;blockquote&gt;
&lt;table style=&#34;width: 100%&#34;&gt;
 &lt;thead&gt;
  &lt;th colspan=&#34;3&#34;&gt;友情链接&lt;/th&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
  &lt;tr&gt;
  &lt;td align=&#34;center&#34;&gt;
      &lt;a href=&#34;http://jsshou.cn/&#34; title=&#34;JSShou的博客网站&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JSShou&lt;/a&gt;
    &lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>React调度过程</title>
      <link>https://xtid.github.io/2021/react%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Tue, 05 Jan 2021 23:02:17 +0800</pubDate>
      
      <guid>https://xtid.github.io/2021/react%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B/</guid>
      <description>

&lt;h2 id=&#34;1-forwardref&#34;&gt;1.forwardRef&lt;/h2&gt;

&lt;p&gt;用来解决高阶组件传递&lt;code&gt;ref&lt;/code&gt;的问题。它的用法就像是使用&lt;code&gt;redux&lt;/code&gt;的时候，在外面包裹一层，通过&lt;code&gt;...props&lt;/code&gt;的方式把外部的&lt;code&gt;props&lt;/code&gt;传入到实际组件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;const TargetComponent = React.forwardRef((props, ref) =&amp;gt; (
  &amp;lt;TargetComponent ref={ref} /&amp;gt;
))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-reactelement&#34;&gt;2.ReactElement&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ReactElement&lt;/code&gt;通过&lt;code&gt;createElement&lt;/code&gt;创建，调用该方法需要传入三个参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;type&lt;/li&gt;
&lt;li&gt;config&lt;/li&gt;
&lt;li&gt;children&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;type&lt;/code&gt;指代这个&lt;code&gt;ReactElement&lt;/code&gt;的类型&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;字符串比如&lt;code&gt;div&lt;/code&gt;，&lt;code&gt;p&lt;/code&gt;代表原生DOM，称为&lt;code&gt;HostComponent&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Class类型是我们继承自&lt;code&gt;Component&lt;/code&gt;或者&lt;code&gt;PureComponent&lt;/code&gt;的组件，称为&lt;code&gt;ClassComponent&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;方法就是&lt;code&gt;functional Component&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;原生提供的&lt;code&gt;Fragment&lt;/code&gt;、&lt;code&gt;AsyncMode&lt;/code&gt;等是Symbol，会被特殊处理&lt;/li&gt;
&lt;li&gt;TODO: 是否有其他的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从源码可以看出虽然创建的时候都是通过&lt;code&gt;config&lt;/code&gt;传入的，但是&lt;code&gt;key&lt;/code&gt;和&lt;code&gt;ref&lt;/code&gt;不会跟其他&lt;code&gt;config&lt;/code&gt;中的变量一起被处理，而是单独作为变量出现在&lt;code&gt;ReactElement&lt;/code&gt;上。&lt;/p&gt;

&lt;p&gt;从源码可以看出虽然创建的时候都是通过&lt;code&gt;config&lt;/code&gt;传入的，但是&lt;code&gt;key&lt;/code&gt;和&lt;code&gt;ref&lt;/code&gt;不会跟其他&lt;code&gt;config&lt;/code&gt;中的变量一起被处理，而是单独作为变量出现在&lt;code&gt;ReactElement&lt;/code&gt;上。在最后创建&lt;code&gt;ReactElement&lt;/code&gt;我们看到了这么一个变量&lt;code&gt;$$typeof&lt;/code&gt;，在这里他是一个常量：&lt;code&gt;REACT_ELEMENT_TYPE&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-react-children&#34;&gt;3.React Children&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;React&lt;/code&gt;上面有有一个&lt;code&gt;Children&lt;/code&gt;对象，上面有着&lt;code&gt;Children&lt;/code&gt;定义&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;const React = {
  Children: {
    map,
    forEach,
    count,
    toArray,
    only,
  },
	......
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;找到定义&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function mapChildren(children, func, context) {
  if (children == null) {
    return children
  }
  const result = []
  mapIntoWithKeyPrefixInternal(children, result, null, func, context)
  return result
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  let escapedPrefix = &#39;&#39;
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + &#39;/&#39;
  }
  const traverseContext = getPooledTraverseContext(
    array,
    escapedPrefix,
    func,
    context,
  )
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext)
  releaseTraverseContext(traverseContext)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到后面调用了&lt;code&gt;getPooledTraverseContext&lt;/code&gt;，这是从内容池中找到当前的&lt;code&gt;contex&lt;/code&gt;t对象，操作完了之后&lt;code&gt;releaseTraverseContext&lt;/code&gt;会把当前的&lt;code&gt;context&lt;/code&gt;对象清空然后放回到&lt;code&gt;pool&lt;/code&gt;中。然后调用&lt;code&gt;traverseAllChildren&lt;/code&gt;，这个方法的作用就是递归调用&lt;code&gt;mapChildren&lt;/code&gt;将所有&lt;code&gt;Children&lt;/code&gt;铺平，直到当前元素是一个有效的&lt;code&gt;ReactElement&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  const { result, keyPrefix, func, context } = bookKeeping

  let mappedChild = func.call(context, child, bookKeeping.count++)
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c =&amp;gt; c)
  } else if (mappedChild != null) {
    if (isValidElement(mappedChild)) {
      mappedChild = cloneAndReplaceKey(
        mappedChild,
        keyPrefix +
          (mappedChild.key &amp;amp;&amp;amp; (!child || child.key !== mappedChild.key)
            ? escapeUserProvidedKey(mappedChild.key) + &#39;/&#39;
            : &#39;&#39;) +
          childKey,
      )
    }
    result.push(mappedChild)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;React.Children.map(this.props.children, function (child) {
    return &amp;lt;li&amp;gt;{child}&amp;lt;/li&amp;gt;;
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-react中的数据结构&#34;&gt;4.React中的数据结构&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Update&lt;/code&gt; &amp;amp;&lt;code&gt;UpdateQueue&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;export type Update&amp;lt;State&amp;gt; = {
  // 更新的过期时间
  expirationTime: ExpirationTime,

  // export const UpdateState = 0;
  // export const ReplaceState = 1;
  // export const ForceUpdate = 2;
  // export const CaptureUpdate = 3;
  // 指定更新的类型，值为以上几种
  tag: 0 | 1 | 2 | 3,
  // 更新内容，比如`setState`接收的第一个参数
  payload: any, // 当前DOM元素？
  // 对应的回调，`setState`，`render`都有
  callback: (() =&amp;gt; mixed) | null,

  // 指向下一个更新
  next: Update&amp;lt;State&amp;gt; | null,
  // 指向下一个`side effect`
  nextEffect: Update&amp;lt;State&amp;gt; | null,
};

export type UpdateQueue&amp;lt;State&amp;gt; = {
  // 每次操作完更新之后的`state`
  baseState: State,

  // 队列中的第一个`Update`
  firstUpdate: Update&amp;lt;State&amp;gt; | null,
  // 队列中的最后一个`Update`
  lastUpdate: Update&amp;lt;State&amp;gt; | null,

  // 第一个捕获类型的`Update`
  firstCapturedUpdate: Update&amp;lt;State&amp;gt; | null,
  // 最后一个捕获类型的`Update`
  lastCapturedUpdate: Update&amp;lt;State&amp;gt; | null,

  // 第一个`side effect`
  firstEffect: Update&amp;lt;State&amp;gt; | null,
  // 最后一个`side effect`
  lastEffect: Update&amp;lt;State&amp;gt; | null,

  // 第一个和最后一个捕获产生的`side effect`
  firstCapturedEffect: Update&amp;lt;State&amp;gt; | null,
  lastCapturedEffect: Update&amp;lt;State&amp;gt; | null,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-初次reactdom-reander过程&#34;&gt;5.初次ReactDOM.reander过程&lt;/h2&gt;

&lt;p&gt;首先调用&lt;code&gt;legacyRenderSubtreeIntoContainer&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;ReactDOM = {
  render(
    element: React$Element&amp;lt;any&amp;gt;,
    container: DOMContainer,
    callback: ?Function,
  ) {
    return legacyRenderSubtreeIntoContainer(
      null,
      element,
      container,
      false,
      callback,
    )
  },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function legacyRenderSubtreeIntoContainer(
  parentComponent: ?React$Component&amp;lt;any, any&amp;gt;,
  children: ReactNodeList,
  container: DOMContainer,
  forceHydrate: boolean,
  callback: ?Function,
) {
  let root: Root = (container._reactRootContainer: any)
  if (!root) {
    // 生成root，当前传入的根container的_reactRootContainer指向生成的root
    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
      container,
      forceHydrate,
    )
    if (typeof callback === &#39;function&#39;) {
      const originalCallback = callback
      callback = function() {
        const instance = DOMRenderer.getPublicRootInstance(root._internalRoot)
        originalCallback.call(instance)
      }
    }
    // 首次render不比unbatchedUpdates
    DOMRenderer.unbatchedUpdates(() =&amp;gt; {
      if (parentComponent != null) {
        // 一般不会出现
      } else {
        root.render(children, callback)
      }
    })
  } else {
    // 有root的情况
  }
  return DOMRenderer.getPublicRootInstance(root._internalRoot)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;legacyCreateRootFromDOMContainer&lt;/code&gt;方法生成&lt;code&gt;root&lt;/code&gt;，返回的结果上的&lt;code&gt;_internalRoot&lt;/code&gt;指向这个&lt;code&gt;root&lt;/code&gt;。同时会调用&lt;code&gt;DOMRenderer.createContainer&lt;/code&gt;创建&lt;code&gt;FiberRoot&lt;/code&gt;，然后生成的&lt;code&gt;root&lt;/code&gt;的&lt;code&gt;current&lt;/code&gt;属性指向这个&lt;code&gt;FiberRoot&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function legacyCreateRootFromDOMContainer(
  container: DOMContainer,
  forceHydrate: boolean,
): Root {
  const shouldHydrate =
    forceHydrate || shouldHydrateDueToLegacyHeuristic(container)
  // First clear any existing content.
  if (!shouldHydrate) {
    let warned = false
    let rootSibling
    while ((rootSibling = container.lastChild)) {
      container.removeChild(rootSibling)
    }
  }
  // Legacy roots are not async by default.
  const isConcurrent = false
  return new ReactRoot(container, isConcurrent, shouldHydrate)
}

function ReactRoot(
  container: Container,
  isConcurrent: boolean,
  hydrate: boolean,
) {
  const root = DOMRenderer.createContainer(container, isConcurrent, hydrate)
  this._internalRoot = root
}

ReactRoot.prototype.render = function(
  children: ReactNodeList,
  callback: ?() =&amp;gt; mixed,
): Work {
  const root = this._internalRoot
  const work = new ReactWork()
  callback = callback === undefined ? null : callback
  if (__DEV__) {
    warnOnInvalidCallback(callback, &#39;render&#39;)
  }
  if (callback !== null) {
    work.then(callback)
  }
  DOMRenderer.updateContainer(children, root, null, work._onCommit)
  return work
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到还有个&lt;code&gt;updateContainer&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;export function updateContainer(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component&amp;lt;any, any&amp;gt;,
  callback: ?Function,
): ExpirationTime {
  const current = container.current
  const currentTime = requestCurrentTime()
  const expirationTime = computeExpirationForFiber(currentTime, current)
  return updateContainerAtExpirationTime(
    element,
    container,
    parentComponent,
    expirationTime,
    callback,
  )
}

export function updateContainerAtExpirationTime(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component&amp;lt;any, any&amp;gt;,
  expirationTime: ExpirationTime,
  callback: ?Function,
) {
  // TODO: If this is a nested container, this won&#39;t be the root.
  const current = container.current
  const context = getContextForSubtree(parentComponent)
  if (container.context === null) {
    container.context = context
  } else {
    container.pendingContext = context
  }

  return scheduleRootUpdate(current, element, expirationTime, callback)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到先生成一个时间&lt;code&gt;const expirationTime&lt;/code&gt;，也就是这次更新的超时时间，然后调用&lt;code&gt;updateContainerAtExpirationTime&lt;/code&gt;，然后调用&lt;code&gt;scheduleRootUpdate&lt;/code&gt;进行调度&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function scheduleRootUpdate(
  current: Fiber,
  element: ReactNodeList,
  expirationTime: ExpirationTime,
  callback: ?Function,
) {
  const update = createUpdate(expirationTime)

  update.payload = { element }

  callback = callback === undefined ? null : callback
  if (callback !== null) {
    warningWithoutStack(
      typeof callback === &#39;function&#39;,
      &#39;render(...): Expected the last optional `callback` argument to be a &#39; +
        &#39;function. Instead received: %s.&#39;,
      callback,
    )
    update.callback = callback
  }
  enqueueUpdate(current, update)

  scheduleWork(current, expirationTime)
  return expirationTime
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;scheduleRootUpdate&lt;/code&gt;会调用&lt;code&gt;createUpdate&lt;/code&gt;创建&lt;code&gt;Update&lt;/code&gt;对象，其&lt;code&gt;playload&lt;/code&gt;为&lt;code&gt;container&lt;/code&gt;上面的&lt;code&gt;ReactNodeList&lt;/code&gt;，然后调用&lt;code&gt;enqueueUpdate&lt;/code&gt;生成一个双向列表队列，然后调用&lt;code&gt;scheduleWork&lt;/code&gt;开始调用。上面的过程都是依赖的&lt;code&gt;FiberRoot&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;6-expirationtime&#34;&gt;6.expirationTime&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;import MAX_SIGNED_31_BIT_INT from &#39;./maxSigned31BitInt&#39;;

export type ExpirationTime = number;

export const NoWork = 0;
export const Never = 1;
export const Sync = MAX_SIGNED_31_BIT_INT;

const UNIT_SIZE = 10;
const MAGIC_NUMBER_OFFSET = MAX_SIGNED_31_BIT_INT - 1;

// 1 unit of expiration time represents 10ms.
export function msToExpirationTime(ms: number): ExpirationTime {
  // Always add an offset so that we don&#39;t clash with the magic number for NoWork.
  return MAGIC_NUMBER_OFFSET - ((ms / UNIT_SIZE) | 0);
}

export function expirationTimeToMs(expirationTime: ExpirationTime): number {
  return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;
}

function ceiling(num: number, precision: number): number {
  return (((num / precision) | 0) + 1) * precision;
}

function computeExpirationBucket(
  currentTime,
  expirationInMs,
  bucketSizeMs,
): ExpirationTime {
  return (
    MAGIC_NUMBER_OFFSET -
    ceiling(
      MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE,
      bucketSizeMs / UNIT_SIZE,
    )
  );
}

export const LOW_PRIORITY_EXPIRATION = 5000;
export const LOW_PRIORITY_BATCH_SIZE = 250;

export function computeAsyncExpiration(
  currentTime: ExpirationTime,
): ExpirationTime {
  return computeExpirationBucket(
    currentTime,
    LOW_PRIORITY_EXPIRATION,
    LOW_PRIORITY_BATCH_SIZE,
  );
}

export const HIGH_PRIORITY_EXPIRATION = __DEV__ ? 500 : 150;
export const HIGH_PRIORITY_BATCH_SIZE = 100;

export function computeInteractiveExpiration(currentTime: ExpirationTime) {
  return computeExpirationBucket(
    currentTime,
    HIGH_PRIORITY_EXPIRATION,
    HIGH_PRIORITY_BATCH_SIZE,
  );
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后的计算公式为&lt;code&gt;((((currentTime - 2 + 5000 / 10) / 25) | 0) + 1) * 25&lt;/code&gt;（公式存疑），也就是说最后的结果是以&lt;code&gt;25ms&lt;/code&gt;为单位向上增加的，在&lt;code&gt;25ms&lt;/code&gt;内，&lt;code&gt;react&lt;/code&gt;这样做为的是让两次时间非常想尽的更新得到同样的&lt;code&gt;expirationTime&lt;/code&gt;，然后他们的优先级就会判定一样，就会再一次更新中完成，也就是一个&lt;code&gt;batchedUpdates&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;计算当前&lt;code&gt;currentTime&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function requestCurrentTime() {
  if (isRendering) {
    return currentSchedulerTime
  }
  findHighestPriorityRoot()
  if (
    nextFlushedExpirationTime === NoWork ||
    nextFlushedExpirationTime === Never
  ) {
    recomputeCurrentRendererTime()
    currentSchedulerTime = currentRendererTime
    return currentSchedulerTime
  }
  return currentSchedulerTime
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;react&lt;/code&gt;为了避免每次计算&lt;code&gt;expirationTime&lt;/code&gt;都要&lt;code&gt;Date now&lt;/code&gt;，所以用&lt;code&gt;currentRendererTime&lt;/code&gt;来保存了这个值，上面的&lt;code&gt;currentSchedulerTime&lt;/code&gt;也是记录这个值的&lt;/p&gt;

&lt;p&gt;首先&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;if (isRendering) {
  return currentSchedulerTime
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个&lt;code&gt;isRendering&lt;/code&gt;只有在&lt;code&gt;performWorkOnRoot&lt;/code&gt;的时候才会被设置为&lt;code&gt;true&lt;/code&gt;，而其本身是一个同步的方法，不存在他执行到一半没有设置&lt;code&gt;isRendering&lt;/code&gt;为&lt;code&gt;false&lt;/code&gt;的时候就跳出，那么什么情况下会在这里出现新的&lt;code&gt;requestCurrentTime&lt;/code&gt;呢？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在生命周期方法中调用了&lt;code&gt;setState&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;需要挂起任务的时候&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也就是说 React 要求&lt;strong&gt;在一次&lt;code&gt;rendering&lt;/code&gt;过程中，新产生的&lt;code&gt;update&lt;/code&gt;用于计算过期时间的&lt;code&gt;current&lt;/code&gt;必须跟目前的&lt;code&gt;renderTime&lt;/code&gt;保持一致，同理在这个周期中所有产生的新的更新的过期时间都会保持一致！&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;  findHighestPriorityRoot()
  if (
    nextFlushedExpirationTime === NoWork ||
    nextFlushedExpirationTime === Never
  ) {
    recomputeCurrentRendererTime()
    currentSchedulerTime = currentRendererTime
    return currentSchedulerTime
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;findHighestPriorityRoot&lt;/code&gt;找到优先级最高的节点，同时设置&lt;code&gt;nextFlushedExpirationTime&lt;/code&gt;，然后if判断当前队列中没有更新的任务，就会重新计算当前时间，否则，还是返回最初的&lt;code&gt;currentSchedulerTime&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;7-各种expirationtime&#34;&gt;7.各种expirationTime&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;root.expirationTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;root.nextExpirationTimeToWorkOn&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;root.childExpirationTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;root.earliestPendingTime &amp;amp; root.lastestPendingTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;root.earliestSuspendedTime &amp;amp; root.lastestSuspendedTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;root.lastestPingedTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nextFlushedExpirationTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nextLatestAbsoluteTimeoutMs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;currentRendererTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;currentSchedulerTime&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;React&lt;/code&gt;更新是从&lt;code&gt;FilberRoot&lt;/code&gt;开始的，所以每次更新时都会遍历向上查找&lt;code&gt;FiberRoot&lt;/code&gt;，而这个&lt;code&gt;childExpirationTime&lt;/code&gt;会设置到每个父节点，代表其子节点&lt;code&gt;expirationTime&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pendingTime&lt;/code&gt;，在&lt;code&gt;FiberRoot&lt;/code&gt;上有两个值&lt;code&gt;earliestPendingTime&lt;/code&gt;和&lt;code&gt;lastestPedingTime&lt;/code&gt;，他们是一对值，&lt;strong&gt;用来记录所有子树中需要进行渲染的更新的&lt;code&gt;expirationTime&lt;/code&gt;的区间&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;suspendedTime&lt;/code&gt;，同样的在&lt;code&gt;ReactFiber&lt;/code&gt;上有两个值&lt;code&gt;earliestSuspendedTime&lt;/code&gt;和&lt;code&gt;lastestSuspendedTime&lt;/code&gt;，&lt;strong&gt;这两个值是用来记录被挂起的任务的过期时间的&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先我们定义一下什么情况下任务是被挂起的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;出现可捕获的错误并且还有优先级更低的任务的情况下&lt;/li&gt;
&lt;li&gt;当捕获到&lt;code&gt;thenable&lt;/code&gt;，并且需要设置&lt;code&gt;onTimeout&lt;/code&gt;的时候&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;root.expirationTime&lt;/code&gt;是用来标志当前渲染的过期时间的，请注意他只管本渲染周期，他并不管你现在的渲染目标是哪个，渲染目标是由&lt;code&gt;root.nextExpirationTimeToWorkOn&lt;/code&gt;来决定的。&lt;/p&gt;

&lt;p&gt;那么他们有什么区别呢？主要区别在于发挥作用的阶段&lt;/p&gt;

&lt;p&gt;&lt;code&gt;expirationTime&lt;/code&gt;作用于调度阶段，主要指责是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;决定是异步执行渲染还是同步执行渲染&lt;/li&gt;
&lt;li&gt;作为&lt;code&gt;react-scheduler&lt;/code&gt;的&lt;code&gt;timeout&lt;/code&gt;标准，决定是否要优先渲染&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;nextExpirationTimeToWorkOn&lt;/code&gt;主要作用于渲染阶段：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;决定那些更新要在当前周期中被执行&lt;/li&gt;
&lt;li&gt;通过跟每个节点的&lt;code&gt;expirationTime&lt;/code&gt;比较决定该节点是否可以直接&lt;code&gt;bailout&lt;/code&gt;（跳过）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;他们都是通过&lt;code&gt;pendingTime&lt;/code&gt;、&lt;code&gt;suspenededTime&lt;/code&gt;和&lt;code&gt;pingedTime&lt;/code&gt;中删选出来的，唯一的不同是，&lt;code&gt;nextExpirationTimeToWorkOn&lt;/code&gt;在没有&lt;code&gt;pending&lt;/code&gt;或者&lt;code&gt;pinged&lt;/code&gt;的任务的时候会选择最晚的&lt;code&gt;suspendedTime&lt;/code&gt;，而&lt;code&gt;expirationTime&lt;/code&gt;会选择最早的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;expirationTime&lt;/code&gt;的变化：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;scheduleWork&lt;/code&gt;的时候通过&lt;code&gt;markPendingExpirationTime&lt;/code&gt;设置&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;beginWork&lt;/code&gt;的时候被设置为&lt;code&gt;NoWork&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;onUncaughtError&lt;/code&gt;的时候设置为&lt;code&gt;NoWork&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onSuspend&lt;/code&gt;的时候又会设置回当次更新的&lt;code&gt;expirationTime&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;8-schedulework&#34;&gt;8.scheduleWork&lt;/h2&gt;

&lt;p&gt;上面说的在创建完更新队列后，就会调用&lt;code&gt;scheduleWork&lt;/code&gt;调度了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function scheduleWork(fiber: Fiber, expirationTime: ExpirationTime) {
  const root = scheduleWorkToRoot(fiber, expirationTime);
  if (root === null) {
    if (__DEV__) {
      switch (fiber.tag) {
        case ClassComponent:
          warnAboutUpdateOnUnmounted(fiber, true);
          break;
        case FunctionComponent:
        case ForwardRef:
        case MemoComponent:
        case SimpleMemoComponent:
          warnAboutUpdateOnUnmounted(fiber, false);
          break;
      }
    }
    return;
  }
	
  // 此条件的意思是当前处理空闲阶段，没有render或者commit，并且下一次任务不为空，还有当前过期时间(优先级)高于下次的过期时间
  // 则清空队列
  // 例如上一个任务是异步任务（优先级很低，超时时间是 502ms），并且在上一个时间片（初始是 33ms）任务没有执行完，而且等待下一次requestIdleCallback的时候新的任务进来了，并且超时时间很短（52ms 或者 22ms 甚至是 Sync），那么优先级就变成了先执行当前任务，也就意味着上一个任务被打断了（interrupted）
  if (
    !isWorking &amp;amp;&amp;amp;
    nextRenderExpirationTime !== NoWork &amp;amp;&amp;amp;
    expirationTime &amp;gt; nextRenderExpirationTime
  ) {
    interruptedBy = fiber;
    resetStack();
  }
  // 记录所有子节点的任务时间区间
  markPendingPriorityLevel(root, expirationTime);
  // 要么处于没有 work 的状态，要么只能在 render 阶段，要么有两个不同的root
  if (
    !isWorking ||
    isCommitting ||
    nextRoot !== root
  ) {
    const rootExpirationTime = root.expirationTime;
    requestWork(root, rootExpirationTime);
  }
  if (nestedUpdateCount &amp;gt; NESTED_UPDATE_LIMIT) {
    // Reset this back to zero so subsequent updates don&#39;t throw.
    nestedUpdateCount = 0;
    invariant(
      false,
      &#39;Maximum update depth exceeded. This can happen when a &#39; +
        &#39;component repeatedly calls setState inside &#39; +
        &#39;componentWillUpdate or componentDidUpdate. React limits &#39; +
        &#39;the number of nested updates to prevent infinite loops.&#39;,
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先是调用&lt;code&gt;scheduleWorkToRoot&lt;/code&gt;，这个方法的主要是更新当前任务对应&lt;code&gt;Filber&lt;/code&gt;的到期时间&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function scheduleWorkToRoot(fiber: Fiber, expirationTime): FiberRoot | null {
  recordScheduleUpdate();

  if (__DEV__) {
    if (fiber.tag === ClassComponent) {
      const instance = fiber.stateNode;
      warnAboutInvalidUpdates(instance);
    }
  }

  // 如果filber上的过期时间小于当前的过期时间，更新
  if (fiber.expirationTime &amp;lt; expirationTime) {
    fiber.expirationTime = expirationTime;
  }
  let alternate = fiber.alternate;
  if (alternate !== null &amp;amp;&amp;amp; alternate.expirationTime &amp;lt; expirationTime) {
    alternate.expirationTime = expirationTime;
  }
  // fiber.return 返回当前fiber的父节点
  let node = fiber.return;
  let root = null;
  if (node === null &amp;amp;&amp;amp; fiber.tag === HostRoot) {
    // 如果filber.return的值为null，设置root的值为根节点(fiber.stateNode)
    root = fiber.stateNode;
  } else {
    // 循环向上遍历，更新每个子节点的过期时间
    // 如果子节点的过期时间小于当前过期时间，则更新
    while (node !== null) {
      alternate = node.alternate;
      if (node.childExpirationTime &amp;lt; expirationTime) {
        node.childExpirationTime = expirationTime;
        if (
          alternate !== null &amp;amp;&amp;amp;
          alternate.childExpirationTime &amp;lt; expirationTime
        ) {
          alternate.childExpirationTime = expirationTime;
        }
      } else if (
        alternate !== null &amp;amp;&amp;amp;
        alternate.childExpirationTime &amp;lt; expirationTime
      ) {
        alternate.childExpirationTime = expirationTime;
      }
      if (node.return === null &amp;amp;&amp;amp; node.tag === HostRoot) {
        root = node.stateNode;
        break;
      }
      node = node.return;
    }
  }
  ......
  return root;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;requestWork&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function requestWork(root: FiberRoot, expirationTime: ExpirationTime) {
  // 将root加入调度队列中，不会存在两个相同的 root 前后出现在队列中
  addRootToSchedule(root, expirationTime)
  if (isRendering) {
    return
  }

  if (isBatchingUpdates) {
    if (isUnbatchingUpdates) {
      nextFlushedRoot = root
      nextFlushedExpirationTime = Sync
      performWorkOnRoot(root, Sync, true)
    }
    return
  }

  // 根据expirationTime调用performSyncWork还是scheduleCallbackWithExpirationTime

  if (expirationTime === Sync) {
    performSyncWork()
  } else {
    // 异步调度，并且当前已经有异步任务，如果当前传入的任务优先级高，取消之前的调度，异步调度当前任务
    // 无异步任务，生成一个到期时间，调度
    scheduleCallbackWithExpirationTime(root, expirationTime)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;9-performwork&#34;&gt;9.performWork&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;performAsyncWork&lt;/code&gt; 为异步调用，一开始的&lt;code&gt;shouldYieldToRenderer&lt;/code&gt;代表是否当前调度中有没有时间执行异步任务，若&lt;code&gt;shouldYieldToRenderer&lt;/code&gt;返回&lt;code&gt;false&lt;/code&gt;，则代表有，那么重新计算当前的&lt;code&gt;expirationTime&lt;/code&gt;，更新所有的已过期的&lt;code&gt;root&lt;/code&gt;任务的&lt;code&gt;nextExpirationTimeToWorkOn&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;let didYield: boolean = false;
function shouldYieldToRenderer() {
  if (didYield) {
    return true;
  }
  if (shouldYield()) {
    didYield = true;
    return true;
  }
  return false;
}

function performAsyncWork() {
  try {
    if (!shouldYieldToRenderer()) {
      // 如果当前还有调度的链表
      if (firstScheduledRoot !== null) {
        // 重新计算当前的一个expirationTime
        recomputeCurrentRendererTime();
        let root: FiberRoot = firstScheduledRoot;
        do {
          // 设置所有的已过期的root任务的nextExpirationTimeToWorkOn为当前计算出的expirationTime
          didExpireAtExpirationTime(root, currentRendererTime);
          root = (root.nextScheduledRoot: any);
        } while (root !== firstScheduledRoot);
      }
    }
    performWork(NoWork, true);
  } finally {
    didYield = false;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;performSyncWork&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;同步调度任务，方法很简单，直接调用&lt;code&gt;performWork&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function performSyncWork() {
  performWork(Sync, false);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;performWork&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;此方法为真正的调度方法，首先会调用&lt;code&gt;findHighestPriorityRoot&lt;/code&gt;，找到当前队列优先级最高的&lt;code&gt;root&lt;/code&gt;任务，命名为&lt;code&gt;nextFlushedRoot&lt;/code&gt;，已经其对应的&lt;code&gt;expirationTime&lt;/code&gt;，命名为&lt;code&gt;nextFlushedExpirationTime&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function performWork(minExpirationTime: ExpirationTime, isYieldy: boolean) {
  findHighestPriorityRoot();

  if (isYieldy) {
    recomputeCurrentRendererTime();
    currentSchedulerTime = currentRendererTime;
		
    if (enableUserTimingAPI) {
      const didExpire = nextFlushedExpirationTime &amp;gt; currentRendererTime;
      const timeout = expirationTimeToMs(nextFlushedExpirationTime);
      stopRequestCallbackTimer(didExpire, timeout);
    }

    while (
      nextFlushedRoot !== null &amp;amp;&amp;amp;
      nextFlushedExpirationTime !== NoWork &amp;amp;&amp;amp;
      minExpirationTime &amp;lt;= nextFlushedExpirationTime &amp;amp;&amp;amp;
      !(didYield &amp;amp;&amp;amp; currentRendererTime &amp;gt; nextFlushedExpirationTime)
    ) {
      performWorkOnRoot(
        nextFlushedRoot,
        nextFlushedExpirationTime,
        currentRendererTime &amp;gt; nextFlushedExpirationTime,
      );
      findHighestPriorityRoot();
      recomputeCurrentRendererTime();
      currentSchedulerTime = currentRendererTime;
    }
  } else {
    while (
      nextFlushedRoot !== null &amp;amp;&amp;amp;
      nextFlushedExpirationTime !== NoWork &amp;amp;&amp;amp;
      minExpirationTime &amp;lt;= nextFlushedExpirationTime
    ) {
      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);
      findHighestPriorityRoot();
    }
  }
  if (isYieldy) {
    callbackExpirationTime = NoWork;
    callbackID = null;
  }
  if (nextFlushedExpirationTime !== NoWork) {
    scheduleCallbackWithExpirationTime(
      ((nextFlushedRoot: any): FiberRoot),
      nextFlushedExpirationTime,
    );
  }
  finishRendering();
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，不管同步异步，都有&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;while(
 nextFlushedRoot !== null &amp;amp;&amp;amp;
 nextFlushedExpirationTime !== NoWork &amp;amp;&amp;amp;
 minExpirationTime &amp;lt;= nextFlushedExpirationTime
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个循环调度&lt;code&gt;root&lt;/code&gt;任务的过程，判断条件为调度队列不为空，并且当前传入的任务优先级小于优先级最高的任务。异步调用时还有个额外的条件&lt;code&gt;!(didYield &amp;amp;&amp;amp; currentRendererTime &amp;gt; nextFlushedExpirationTime)&lt;/code&gt;，翻译过来就是当前传入的异步任务没过期，并且当前的渲染时间也没超过优先级最高的任务。然后这个循环就会在每次循环中调用&lt;code&gt;performWorkOnRoot&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;10-performworkonroot&#34;&gt;10.performWorkOnRoot&lt;/h2&gt;

&lt;p&gt;这里是整个调度过程的提交、render过程。不同的是，在异步任务中有个判断&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;if (!shouldYieldToRenderer()) {
  completeRoot(root, finishedWork, expirationTime);
} else {
  root.finishedWork = finishedWork;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;意思就是说如果当前没有时间处理异步任务，直接&lt;code&gt;completeRoot&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function performWorkOnRoot(
  root: FiberRoot,
  expirationTime: ExpirationTime,
  isYieldy: boolean,
) {
  invariant(
    !isRendering,
    &#39;performWorkOnRoot was called recursively. This error is likely caused &#39; +
      &#39;by a bug in React. Please file an issue.&#39;,
  );

  isRendering = true;

  if (!isYieldy) {

    let finishedWork = root.finishedWork;
    if (finishedWork !== null) {
      completeRoot(root, finishedWork, expirationTime);
    } else {
      root.finishedWork = null;
      const timeoutHandle = root.timeoutHandle;
      if (timeoutHandle !== noTimeout) {
        root.timeoutHandle = noTimeout;
        cancelTimeout(timeoutHandle);
      }
      renderRoot(root, isYieldy);
      finishedWork = root.finishedWork;
      if (finishedWork !== null) {
        completeRoot(root, finishedWork, expirationTime);
      }
    }
  } else {
    let finishedWork = root.finishedWork;
    if (finishedWork !== null) {
      completeRoot(root, finishedWork, expirationTime);
    } else {
      root.finishedWork = null;
      const timeoutHandle = root.timeoutHandle;
      if (timeoutHandle !== noTimeout) {
        root.timeoutHandle = noTimeout;
        cancelTimeout(timeoutHandle);
      }
      renderRoot(root, isYieldy);
      finishedWork = root.finishedWork;
      if (finishedWork !== null) {
        if (!shouldYieldToRenderer()) {
          completeRoot(root, finishedWork, expirationTime);
        } else {
          root.finishedWork = finishedWork;
        }
      }
    }
  }
  isRendering = false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;11-renderroot&#34;&gt;11.renderRoot&lt;/h2&gt;

&lt;p&gt;这个判断的意思就是如果当前没有其他的任务，那么就进行一些初始化的工作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;if (
    expirationTime !== nextRenderExpirationTime ||
    root !== nextRoot ||
    nextUnitOfWork === null
  ) {
    resetStack();
    nextRoot = root;
    nextRenderExpirationTime = expirationTime;
    nextUnitOfWork = createWorkInProgress(
      nextRoot.current,
      null,
      nextRenderExpirationTime,
    );
		root.pendingCommitExpirationTime = NoWork;
		......
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后调用&lt;code&gt;workLoop&lt;/code&gt;，对于异步任务，仍要判断是否有剩余时间处理此任务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;  do {
    try {
      workLoop(isYieldy);
    } catch (thrownValue) {
      
    }
    break;
  } while (true);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function workLoop(isYieldy) {
  if (!isYieldy) {
    while (nextUnitOfWork !== null) {
      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    }
  } else {
    while (nextUnitOfWork !== null &amp;amp;&amp;amp; !shouldYieldToRenderer()) {
      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果在这过程中会有报错，则停止调度，会在上面的&lt;code&gt;catch中&lt;/code&gt;处理，并且设置&lt;code&gt;finishedWork&lt;/code&gt;为&lt;code&gt;null&lt;/code&gt;，从而结束这一次的&lt;code&gt;render&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;performUnitOfWork&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function performUnitOfWork(workInProgress: Fiber): Fiber | null {
  const current = workInProgress.alternate;

  startWorkTimer(workInProgress);
  let next;
  ......
  if (enableProfilerTimer) {
    if (workInProgress.mode &amp;amp; ProfileMode) {
      startProfilerTimer(workInProgress);
    }

    next = beginWork(current, workInProgress, nextRenderExpirationTime);
    workInProgress.memoizedProps = workInProgress.pendingProps;

    if (workInProgress.mode &amp;amp; ProfileMode) {
      stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);
    }
  } else {
    next = beginWork(current, workInProgress, nextRenderExpirationTime);
    workInProgress.memoizedProps = workInProgress.pendingProps;
  }
  if (next === null) {
    next = completeUnitOfWork(workInProgress);
  }
	
  ......
  ReactCurrentOwner.current = null;

  return next;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先执行&lt;code&gt;next = beginWork(current, workInProgress, nextRenderExpirationTime)&lt;/code&gt;对节点进行操作，其内部会针对不同类型的节点进行创建，返回的结果即会赋值给&lt;code&gt;next&lt;/code&gt;，&lt;code&gt;return next&lt;/code&gt;。 如果&lt;code&gt;next === null&lt;/code&gt;，说明子节点已经处理完，调用&lt;code&gt;next = completeUnitOfWork(workInProgress)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;completeUnitOfWork&lt;/code&gt;会从下往上遍历，处理&lt;code&gt;effact tag&lt;/code&gt;，如果到&lt;code&gt;root&lt;/code&gt;节点返回的是&lt;code&gt;null&lt;/code&gt;，代表整棵树的遍历已经结束了，如果找到了其他兄弟节点，就返回这个节点，重新走一遍&lt;code&gt;workLoop&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;12-updateclasscomponent&#34;&gt;12.updateClassComponent&lt;/h2&gt;

&lt;p&gt;在&lt;code&gt;beginWork&lt;/code&gt;中，会针对不同的节点类型来调用不同的方法处理，这里以&lt;code&gt;ClassComponent&lt;/code&gt;为例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function updateClassComponent(
  current: Fiber | null,
  workInProgress: Fiber,
  Component: any,
  nextProps,
  renderExpirationTime: ExpirationTime,
) {
	......
  // 对context进行处理
  let hasContext;
  // 如果当前组件是context provider
  // 设置hasContext标记
  if (isLegacyContextProvider(Component)) {
    hasContext = true;
    pushLegacyContextProvider(workInProgress);
  } else {
    hasContext = false;
  }
  prepareToReadContext(workInProgress, renderExpirationTime);

  const instance = workInProgress.stateNode;
  let shouldUpdate;
  // 如果实例为空
  if (instance === null) {
    if (current !== null) {
      current.alternate = null;
      workInProgress.alternate = null;
      workInProgress.effectTag |= Placement;
    }
    constructClassInstance(
      workInProgress,
      Component,
      nextProps,
      renderExpirationTime,
    );
    // 挂载这个实例
    mountClassInstance(
      workInProgress,
      Component,
      nextProps,
      renderExpirationTime,
    );
    shouldUpdate = true;
  } else if (current === null) {
    // 第一次渲染时，current为null
    // 重新挂载实例
    shouldUpdate = resumeMountClassInstance(
      workInProgress,
      Component,
      nextProps,
      renderExpirationTime,
    );
  } else {
    // 更新类组件的时候
    // 调用updateClassInstance
    shouldUpdate = updateClassInstance(
      current,
      workInProgress,
      Component,
      nextProps,
      renderExpirationTime,
    );
  }
  ......
  // 调用finishClassComponent
  // 如果需要更新，调用reconcileChildren，返回更新后的workInProgress
  const nextUnitOfWork = finishClassComponent(
    current,
    workInProgress,
    Component,
    shouldUpdate,
    hasContext,
    renderExpirationTime,
  );
  return nextUnitOfWork;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;constructClassInstance&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function constructClassInstance(
  workInProgress: Fiber,
  ctor: any,
  props: any,
  renderExpirationTime: ExpirationTime,
): any {
  .......
  adoptClassInstance(workInProgress, instance);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;adoptClassInstance&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function adoptClassInstance(workInProgress: Fiber, instance: any): void {
  instance.updater = classComponentUpdater;
  workInProgress.stateNode = instance;
  setInstance(instance, workInProgress);
	......
}
  
const classComponentUpdater = {
  isMounted,
  enqueueSetState(inst, payload, callback) {
  },
  enqueueReplaceState(inst, payload, callback) {
  },
  enqueueForceUpdate(inst, callback) {
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;classComponentUpdater&lt;/code&gt;里面几个方法，即对应着&lt;code&gt;setState&lt;/code&gt;、&lt;code&gt;replaceState&lt;/code&gt;、&lt;code&gt;forceUpdate&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mountClassInstance&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-react&#34;&gt;function mountClassInstance(
  workInProgress: Fiber,
  ctor: any,
  newProps: any,
  renderExpirationTime: ExpirationTime,
): void {
  if (__DEV__) {
    checkClassInstance(workInProgress, ctor, newProps);
  }

  const instance = workInProgress.stateNode;
  // 初始化 props、state 等实例属性
  instance.props = newProps;
  instance.state = workInProgress.memoizedState;
  instance.refs = emptyRefsObject;

  const contextType = ctor.contextType;
  if (typeof contextType === &#39;object&#39; &amp;amp;&amp;amp; contextType !== null) {
    instance.context = readContext(contextType);
  } else {
    const unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
    instance.context = getMaskedContext(workInProgress, unmaskedContext);
  }
	.......
	// 如果有updateQueue就更新
  let updateQueue = workInProgress.updateQueue;
  if (updateQueue !== null) {
    processUpdateQueue(
      workInProgress,
      updateQueue,
      newProps,
      instance,
      renderExpirationTime,
    );
    instance.state = workInProgress.memoizedState;
  }
	
	// 如果定义了getDerivedStateFromProps周期函数，则调用
  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  if (typeof getDerivedStateFromProps === &#39;function&#39;) {
    applyDerivedStateFromProps(
      workInProgress,
      ctor,
      getDerivedStateFromProps,
      newProps,
    );
    instance.state = workInProgress.memoizedState;
  }

  if (
    typeof ctor.getDerivedStateFromProps !== &#39;function&#39; &amp;amp;&amp;amp;
    typeof instance.getSnapshotBeforeUpdate !== &#39;function&#39; &amp;amp;&amp;amp;
    (typeof instance.UNSAFE_componentWillMount === &#39;function&#39; ||
      typeof instance.componentWillMount === &#39;function&#39;)
  ) {
    callComponentWillMount(workInProgress, instance);
    updateQueue = workInProgress.updateQueue;
    if (updateQueue !== null) {
      processUpdateQueue(
        workInProgress,
        updateQueue,
        newProps,
        instance,
        renderExpirationTime,
      );
      instance.state = workInProgress.memoizedState;
    }
  }

  // 判断是否有componentDidMount，
	// componentDidMount要在真正渲染进DOM之后才调用，也就是commit之后
  if (typeof instance.componentDidMount === &#39;function&#39;) {
    workInProgress.effectTag |= Update;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;13-commitroot&#34;&gt;13.commitRoot&lt;/h2&gt;

&lt;p&gt;调用完&lt;code&gt;renderRoot&lt;/code&gt;之后，&lt;code&gt;fiber&lt;/code&gt;中对应的每个节点都执行了&lt;code&gt;render&lt;/code&gt;之前所有的生命周期函数，并创建了对应的DOM元素，放在&lt;code&gt;workInProgress.stateNode&lt;/code&gt;中。然后调用&lt;code&gt;commitRoot&lt;/code&gt;，提交子树中优先级最高的任务，更新DOM元素的属性后，挂载组件，调用&lt;code&gt;componentDidMount&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;参考链接&#34;&gt;参考链接&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://react.jokcy.me/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;react源码解析&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Flutter各种踩坑心得</title>
      <link>https://xtid.github.io/2020/flutter%E5%90%84%E7%A7%8D%E8%B8%A9%E5%9D%91%E5%BF%83%E5%BE%97/</link>
      <pubDate>Sat, 05 Dec 2020 16:06:56 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/flutter%E5%90%84%E7%A7%8D%E8%B8%A9%E5%9D%91%E5%BF%83%E5%BE%97/</guid>
      <description>

&lt;h2 id=&#34;1-安卓开发环境的基本配置&#34;&gt;1.安卓开发环境的基本配置&lt;/h2&gt;

&lt;p&gt;首先修改你创建的项目中的&lt;code&gt;/android/build.gradle&lt;/code&gt;文件，修改&lt;code&gt;buildscript&lt;/code&gt;以及&lt;code&gt;allprojects&lt;/code&gt;的仓库地址，否则编译打包会卡住不动，其次就是&lt;code&gt;package get&lt;/code&gt;会卡住，原因是因为连接不上谷歌的服务，有点蛋疼&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;buildscript {
    repositories {
        // google()
        // jcenter()
        maven { url &#39;https://maven.aliyun.com/repository/google&#39; }
        maven { url &#39;https://maven.aliyun.com/repository/jcenter&#39; }
        maven { url &#39;https://maven.aliyun.com/nexus/content/groups/public&#39; }
    }
}

allprojects {
    repositories {
        // google()
        // jcenter()
        maven { url &#39;https://maven.aliyun.com/repository/google&#39; }
        maven { url &#39;https://maven.aliyun.com/repository/jcenter&#39; }
        maven { url &#39;https://maven.aliyun.com/nexus/content/groups/public&#39; }
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-signlechildscrollview页面不满一屏无法撑满全屏&#34;&gt;2.SignleChildScrollView页面不满一屏无法撑满全屏&lt;/h2&gt;

&lt;p&gt;可以换个布局组件或者将其设置为&lt;code&gt;Container&lt;/code&gt;子组件，设置&lt;code&gt;alignment&lt;/code&gt;，如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;Container(
  alignment: Alignment.topLeft,
  child: SingleChildScrollView(),
),
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-自定义appbar&#34;&gt;3.自定义AppBar&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;AppBar&lt;/code&gt;这个组件可拓展性还是比较低的，尤其是它的高度都是写死的，这种情况可以换&lt;code&gt;SliverAppBar&lt;/code&gt;或者自定义&lt;code&gt;AppBar&lt;/code&gt;，换句话说自定义组件，这里就不详诉&lt;/p&gt;

&lt;h2 id=&#34;4-push页面返回-保持上一次的页面位置状态&#34;&gt;4.push页面返回，保持上一次的页面位置状态&lt;/h2&gt;

&lt;p&gt;使用 &lt;code&gt;StatefulWidget&lt;/code&gt; 混入 &lt;code&gt;AutomaticKeepAliveClientMixin&lt;/code&gt;，覆盖&lt;code&gt;wantKeepAlive&lt;/code&gt;属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class TesPage extends StatefulWidget {
  @override
  createState() =&amp;gt; TesPageState();
}

class TesPageState extends State&amp;lt;TesPage&amp;gt; with AutomaticKeepAliveClientMixin {
  
  @override
  bool get wantKeepAlive =&amp;gt; true;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-路由跳转方式的选择&#34;&gt;5.路由跳转方式的选择&lt;/h2&gt;

&lt;p&gt;通常路由跳转会用到&lt;code&gt;Navigator.push&lt;/code&gt;推入路由栈，&lt;code&gt;Navigator.pop&lt;/code&gt;就移出、返回上一个的状态。如果在页面上全部用这两个方法，你会发现你的页面间的跳转仿佛乱了一样，原因就是&lt;code&gt;Navigator.push&lt;/code&gt;是每次将你的路由推入栈，也就是你可以一直做返回操作、手势来获取之前的页面状态。这个时候就要考虑用其他方式，如&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pushAndRemoveUntil&lt;/code&gt;：跳转到指定路由，删除先前的路由栈
&lt;code&gt;pushNamed&lt;/code&gt;：跳转到指定命名路由，路由栈不会删除。这种方式需要配合命名路由使用，即在入口文件&lt;code&gt;MaterialApp&lt;/code&gt;配置好&lt;code&gt;routes&lt;/code&gt;
&lt;code&gt;pushNamedAndRemoveUntil&lt;/code&gt;：跳转到指定路由，删除先前的路由栈
&lt;code&gt;pushReplacement&lt;/code&gt;：路由替换
&lt;code&gt;pushReplacementNamed&lt;/code&gt;：跳转到指定命名路由，并删除最后的路由&lt;/p&gt;

&lt;h2 id=&#34;6-页面初始化时拿到context&#34;&gt;6.页面初始化时拿到context&lt;/h2&gt;

&lt;p&gt;有时候，可能会在页面初始化使用&lt;code&gt;context&lt;/code&gt;，比如说路由相关的&lt;code&gt;Navigator.of(context)&lt;/code&gt;。解决方法很简单，在&lt;code&gt;initState&lt;/code&gt;方法中，&lt;code&gt;this&lt;/code&gt;指向上下文，即使用&lt;code&gt;this.context&lt;/code&gt;即可以保存页面初始的&lt;code&gt;context&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;7-键盘弹出时将布局打乱-或者说将元素顶起来了&#34;&gt;7.键盘弹出时将布局打乱，或者说将元素顶起来了&lt;/h2&gt;

&lt;p&gt;在 &lt;code&gt;Scafold&lt;/code&gt; 里设置 &lt;code&gt;resizeToAvoidBottomInset: false&lt;/code&gt;，键盘会遮住布局，而不是顶起布局。&lt;/p&gt;

&lt;h2 id=&#34;8-无法设置虚线边框&#34;&gt;8.无法设置虚线边框&lt;/h2&gt;

&lt;p&gt;说实话当时发现&lt;code&gt;Flutter&lt;/code&gt;无法设置虚线边框的时候我是很震惊的，我感觉这算是基本的不能在基本的属性了，解决方法，参考官方&lt;code&gt;issues&lt;/code&gt;中大佬的解法，目前只能自己实现&lt;code&gt;paint&lt;/code&gt;方法，自己用&lt;code&gt;Canvas&lt;/code&gt;画&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;import &#39;package:flutter/material.dart&#39;;
import &#39;package:path_drawing/path_drawing.dart&#39;;

void main() =&amp;gt; runApp(MyApp());

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: &#39;Flutter Demo&#39;,
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: MyHomePage(title: &#39;Flutter Demo Home Page&#39;),
    );
  }
}

class MyHomePage extends StatefulWidget {
  MyHomePage({Key key, this.title}) : super(key: key);
  final String title;

  @override
  _MyHomePageState createState() =&amp;gt; _MyHomePageState();
}

class _MyHomePageState extends State&amp;lt;MyHomePage&amp;gt; {
  int _counter = 0;

  void _incrementCounter() {
    setState(() {
      _counter++;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: &amp;lt;Widget&amp;gt;[
            Container(
              decoration: BoxDecoration(
                border: DashPathBorder.all(
                  dashArray: CircularIntervalList&amp;lt;double&amp;gt;(&amp;lt;double&amp;gt;[5.0, 2.5]),
                ),
              ),
              padding: const EdgeInsets.all(20.0),
              child: const Text(&#39;You have pushed the button this many times:&#39;),
            ),
            Text(
              &#39;$_counter&#39;,
              style: Theme.of(context).textTheme.display1,
            ),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _incrementCounter,
        tooltip: &#39;Increment&#39;,
        child: Icon(Icons.add),
      ),
    );
  }
}

class DashPathBorder extends Border {
  DashPathBorder({
    @required this.dashArray,
    BorderSide top = BorderSide.none,
    BorderSide left = BorderSide.none,
    BorderSide right = BorderSide.none,
    BorderSide bottom = BorderSide.none,
  }) : super(
          top: top,
          left: left,
          right: right,
          bottom: bottom,
        );

  factory DashPathBorder.all({
    BorderSide borderSide = const BorderSide(),
    @required CircularIntervalList&amp;lt;double&amp;gt; dashArray,
  }) {
    return DashPathBorder(
      dashArray: dashArray,
      top: borderSide,
      right: borderSide,
      left: borderSide,
      bottom: borderSide,
    );
  }
  final CircularIntervalList&amp;lt;double&amp;gt; dashArray;

  @override
  void paint(
    Canvas canvas,
    Rect rect, {
    TextDirection textDirection,
    BoxShape shape = BoxShape.rectangle,
    BorderRadius borderRadius,
  }) {
    if (isUniform) {
      switch (top.style) {
        case BorderStyle.none:
          return;
        case BorderStyle.solid:
          switch (shape) {
            case BoxShape.circle:
              assert(borderRadius == null,
                  &#39;A borderRadius can only be given for rectangular boxes.&#39;);
              canvas.drawPath(
                dashPath(Path()..addOval(rect), dashArray: dashArray),
                top.toPaint(),
              );
              break;
            case BoxShape.rectangle:
              if (borderRadius != null) {
                final RRect rrect =
                    RRect.fromRectAndRadius(rect, borderRadius.topLeft);
                canvas.drawPath(
                  dashPath(Path()..addRRect(rrect), dashArray: dashArray),
                  top.toPaint(),
                );
                return;
              }
              canvas.drawPath(
                dashPath(Path()..addRect(rect), dashArray: dashArray),
                top.toPaint(),
              );

              break;
          }
          return;
      }
    }

    assert(borderRadius == null,
        &#39;A borderRadius can only be given for uniform borders.&#39;);
    assert(shape == BoxShape.rectangle,
        &#39;A border can only be drawn as a circle if it is uniform.&#39;);

    // TODO(dnfield): implement when borders are not uniform.
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;9-使用dio时-设置相应数据的媒体类型&#34;&gt;9.使用Dio时，设置相应数据的媒体类型&lt;/h2&gt;

&lt;p&gt;使用&lt;code&gt;Dio&lt;/code&gt;封装网络请求，普通的请求最好设置相应类型&lt;code&gt;dio.options.responseType = ResponseType.json&lt;/code&gt;，否则可能接收到的响应可能是字符串。&lt;/p&gt;

&lt;h2 id=&#34;10-build配置&#34;&gt;10.build配置&lt;/h2&gt;

&lt;h3 id=&#34;1-安卓的sha1码获取方式&#34;&gt;1.安卓的SHA1码获取方式&lt;/h3&gt;

&lt;p&gt;很多第三方应用都需要用到安卓的SHA1码，在&lt;code&gt;Flutter&lt;/code&gt;应用中，首先用&lt;code&gt;Andriod Studio&lt;/code&gt;打开项目，随意选择一个文件，点击右上角&lt;code&gt;Open for Editing in Android Studio&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/12/05/KrYUhiXpHu3cLBs.png&#34; alt=&#34;1.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;打开&lt;code&gt;Terminal&lt;/code&gt;，输入&lt;code&gt;gradlew signingReport&lt;/code&gt;，mac环境需要指定当前目录&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/12/05/BxEfHGOAtQcLSn7.png&#34; alt=&#34;2.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后控制台会打印出应用的各种签名信息，复制&lt;code&gt;SHA1&lt;/code&gt;码即可&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/12/05/6cKCEUzuBRS5Ohw.jpg&#34; alt=&#34;3.jpg&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-安卓打包-release-配置&#34;&gt;2.安卓打包&lt;code&gt;release&lt;/code&gt;配置&lt;/h3&gt;

&lt;p&gt;首先打开&lt;code&gt;/android/build.gradle&lt;/code&gt;文件，在&lt;code&gt;buildscript&lt;/code&gt;中指定&lt;code&gt;kotlin_version&lt;/code&gt;，否则&lt;code&gt;debug&lt;/code&gt;、&lt;code&gt;release&lt;/code&gt;编译会不通过&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;buildscript {
    ext.kotlin_version = &#39;1.3.50&#39;
    repositories {
        // google()
        // jcenter()
        maven { url &#39;https://maven.aliyun.com/repository/google&#39; }
        maven { url &#39;https://maven.aliyun.com/repository/jcenter&#39; }
        maven { url &#39;https://maven.aliyun.com/nexus/content/groups/public&#39; }
    }

    dependencies {
        classpath &#39;com.android.tools.build:gradle:3.5.0&#39;
        classpath &amp;quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后生成&lt;code&gt;key&lt;/code&gt;，同样打开&lt;code&gt;Andriod Studio&lt;/code&gt;，打开&lt;code&gt;Terminal&lt;/code&gt;，输入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;keytool -genkey -v -keystore ~/key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成过程中会让你输入存储密码和文件密码，生成完&lt;code&gt;key&lt;/code&gt;后记住文件地址&lt;/p&gt;

&lt;p&gt;然后在在&lt;code&gt;android&lt;/code&gt;目录中创建一个文件，文件名为：&lt;code&gt;key.properties&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/12/05/MuVAtUaI3TojQi6.jpg&#34; alt=&#34;05D6800C-27E4-4550-A7CD-88C691BC8202.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;添加内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;storePassword = // 和生成key输入的存储密码一致
keyPassword = // 和生成key输入的密码一致
keyAlias = key // 
storeFile = // key文件的存储路径
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;找到&lt;code&gt;android/app/build.gradle&lt;/code&gt;文件，添加签名配置&lt;code&gt;singingConfig&lt;/code&gt;以及打包配置&lt;code&gt;buildTypes&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;android {
		.....
    signingConfigs {
        release {
            keyAlias keystoreProperties[&#39;keyAlias&#39;]
            keyPassword keystoreProperties[&#39;keyPassword&#39;]
            storeFile file(keystoreProperties[&#39;storeFile&#39;])
            storePassword keystoreProperties[&#39;storePassword&#39;]
        }
    }

    buildTypes {
        release {
            signingConfig signingConfigs.release
            ndk {
                abiFilters &#39;armeabi-v7a&#39;,&#39;x86&#39; // 指定打包平台
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后进入项目根目录，执行&lt;code&gt;flutter build apk&lt;/code&gt;，即可以打包一个安卓apk包&lt;/p&gt;

&lt;h3 id=&#34;3-ios调试打包注意事项&#34;&gt;3.iOS调试打包注意事项&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;iOS&lt;/code&gt;模拟器调试体验比安卓好的多，但是真机调试，首先你得有个苹果ID，然后用&lt;code&gt;Xcode&lt;/code&gt;打开项目，点击&lt;code&gt;Signing &amp;amp; Capabilities&lt;/code&gt;，找到&lt;code&gt;Team&lt;/code&gt;设置，设置一个开发账号，可以是未付费注册的苹果ID，设置好开发者证书&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/12/05/IM1z4KEkUxPFAvl.jpg&#34; alt=&#34;4.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后&lt;code&gt;flutter run&lt;/code&gt;的时候，选择一个真机设备，即可在真机上调试&lt;code&gt;app&lt;/code&gt;了，但是未付费注册的苹果ID证书有效期只有七天，七天后你手机上的&lt;code&gt;app&lt;/code&gt;就不可用了。&lt;/p&gt;

&lt;p&gt;未付费注册的账号也无法打包上传&lt;code&gt;App Store&lt;/code&gt;，不过配置完了开发团队、账号后、开发证书后，可以直接&lt;code&gt;flutter build ios&lt;/code&gt;，这样会生成一个文件。这时候创建一个名为&lt;code&gt;Payload&lt;/code&gt;的文件夹，将打包生成的文件放进去、压缩，然后将压缩文件后缀改为&lt;code&gt;ipa&lt;/code&gt;，即可以生成一个&lt;code&gt;ipa&lt;/code&gt;文件了。然后借助第三方工具，如&lt;code&gt;itunes(貌似已经不能用)、xxx助手&lt;/code&gt;即可将这个文件安装在终端上运行。&lt;/p&gt;

&lt;h2 id=&#34;11-总结&#34;&gt;11.总结&lt;/h2&gt;

&lt;p&gt;断断续续做这个小项目已经有几个月了，因为平常很忙，所以拖了这么久。&lt;code&gt;Flutter&lt;/code&gt;给我的感觉优点就是流程、动画较为细腻，相对于其它跨平台方案，使用&lt;code&gt;JsBrigde&lt;/code&gt;与&lt;code&gt;native&lt;/code&gt;端通信，有较大的优势，毕竟它是自己的引擎绘制的页面。但是它的官方组件太少，自定义组件所需精力较多(可能是我不熟悉)，&lt;code&gt;iOS&lt;/code&gt;风格组件虽然样式和原生的差不多，但具体效果还是有差距。这种跨平台框架终于还是得要和原生开发人员一起操作才玩的溜。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Flutter自定义组件</title>
      <link>https://xtid.github.io/2020/flutter%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Sat, 28 Nov 2020 16:23:05 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/flutter%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/</guid>
      <description>

&lt;h3 id=&#34;简言&#34;&gt;简言&lt;/h3&gt;

&lt;p&gt;在使用&lt;code&gt;Flutter&lt;/code&gt;开发app的时候，是使用各种各样的&lt;code&gt;Widget&lt;/code&gt; 组合绘制出的页面，一些最基础的如&lt;code&gt;Container&lt;/code&gt;、&lt;code&gt;Padding&lt;/code&gt;、&lt;code&gt;Text&lt;/code&gt; 等等，由官方封装好的比较复杂的组件如&lt;code&gt;AppBar&lt;/code&gt;、&lt;code&gt;日历选择器&lt;/code&gt;等等。仅仅使用这些组件也确实能写出一些app，但是官方封装好的拓展性我觉得不太好，有些属性根本无法改变；另外一旦和设计稿出入比较大，那根不就玩不了了，所以这就涉及到自定义组件。&lt;code&gt;Flutter&lt;/code&gt;自定义组件的方式我了解到有三种，一是通过组合其它组件来达到你想要的效果；二是自绘，这块牵扯到&lt;code&gt;Canvas&lt;/code&gt;；三是实现&lt;code&gt;RenderObject&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;1-原理基本介绍&#34;&gt;1.原理基本介绍&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Flutter&lt;/code&gt;引擎会将我们所写组件生成一个&lt;code&gt;Widget Tree&lt;/code&gt;，而实际渲染出来的结果又有一个&lt;code&gt;RenderObject Tree&lt;/code&gt;，&lt;code&gt;RenderObject&lt;/code&gt;是继承&lt;code&gt;Widget&lt;/code&gt;的。在项目运行中&lt;code&gt;Widget Tree&lt;/code&gt;是不断变化的，如果每次变化都要导致整个&lt;code&gt;RenderObject Tree&lt;/code&gt;变化，这对性能来说是一个很大的消耗，于是就有了一个&lt;code&gt;Element Trre&lt;/code&gt;，这就相当于一个中间层，由&lt;code&gt;Widget&lt;/code&gt;→&lt;code&gt;Elment&lt;/code&gt;→&lt;code&gt;RenderObject&lt;/code&gt;。每次&lt;code&gt;Widget&lt;/code&gt;变化时，与&lt;code&gt;Element&lt;/code&gt;做对比，找出最小最优的变化，作用于&lt;code&gt;RenderObject&lt;/code&gt;。我们创建的&lt;code&gt;Widget&lt;/code&gt;基本继承于&lt;code&gt;StatelessWidget&lt;/code&gt;、&lt;code&gt;StatefulWidget&lt;/code&gt;，他们仅负责属性、生命周期等的管理，最终也还是会继承于&lt;code&gt;RenderObjectWidget&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RenderObjectWidget&lt;/code&gt;下面又有三个子类&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SngleChildRenderObjectWidget&lt;/code&gt;：&lt;code&gt;RenderObject&lt;/code&gt;只有一个 &lt;code&gt;child&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MultiChildRenderObjectWidget&lt;/code&gt;：可以有多个 &lt;code&gt;child&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LeafRenderObjectWidget&lt;/code&gt; ：&lt;code&gt;RenderObject&lt;/code&gt;是一个叶子节点，没有&lt;code&gt;child&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;官方所提供的组件很多都是继承&lt;code&gt;singleChildRenderObjectWidget&lt;/code&gt;，所以我们通常只能传一个&lt;code&gt;child&lt;/code&gt;，找到&lt;code&gt;singleChildRenderObjectWidget&lt;/code&gt;定义&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;abstract class SingleChildRenderObjectWidget extends RenderObjectWidget {
  const SingleChildRenderObjectWidget({ Key key, this.child }) : super(key: key);
  final Widget child;

  @override
  SingleChildRenderObjectElement createElement() =&amp;gt; SingleChildRenderObjectElement(this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到每次创建一个&lt;code&gt;SingleChildRenderObjectWidget&lt;/code&gt;就会调用`&lt;code&gt;CreateElement&lt;/code&gt;生成一个对应的&lt;code&gt;Elment&lt;/code&gt;，当然&lt;code&gt;MultiChildRenderObjectWidget&lt;/code&gt;也是类似，这也就说明了他们一对一的关系。所以我们实现自定义组件必须得继承&lt;code&gt;SingleChildRenderObjectWidget&lt;/code&gt;或者&lt;code&gt;MultiChildRenderObjectWidget&lt;/code&gt;或者调用官方实现好的自绘类，这也是&lt;code&gt;Flutter&lt;/code&gt;引擎渲染的基本结构。&lt;/p&gt;

&lt;h4 id=&#34;2-组合其它组件&#34;&gt;2..组合其它组件&lt;/h4&gt;

&lt;p&gt;这种方式是最基本最简单的方式，说白了就是将一些原有的、封装好的组件合并再封装一次。&lt;code&gt;Flutter&lt;/code&gt;本身就有很多组合组件，比如常用的&lt;code&gt;Container&lt;/code&gt;，查看它的源码就知道，它是由&lt;code&gt;DecoratedBox&lt;/code&gt;、&lt;code&gt;ConstrainedBox&lt;/code&gt;、&lt;code&gt;Transform&lt;/code&gt;、&lt;code&gt;Padding&lt;/code&gt;、&lt;code&gt;Align&lt;/code&gt;等组件组成，其内部做了很多判断处理。这里实现一个自定义宽度的&lt;code&gt;drawer&lt;/code&gt;组件，创建一个类&lt;code&gt;SmartDrawer&lt;/code&gt;继承&lt;code&gt;StatelessWidget&lt;/code&gt;，并实现其具体方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class SmartDrawer extends StatelessWidget {
  final double elevation;
  final Widget child;
  final String semanticLabel;
  final double widthPercent;
  const SmartDrawer({
    Key key,
    this.elevation = 16.0,
    this.child,
    this.semanticLabel,
    this.widthPercent = 0.7,
  }) : 
   assert(widthPercent != null &amp;amp;&amp;amp; widthPercent &amp;lt; 1.0 &amp;amp;&amp;amp; widthPercent&amp;gt; 0.0)
   ,super(key: key);

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasMaterialLocalizations(context));
    String label = semanticLabel;
    final double _width = MediaQuery.of(context).size.width * widthPercent;
    
    return Semantics(
      scopesRoute: true,
      namesRoute: true,
      explicitChildNodes: true,
      label: label,
      child: ConstrainedBox(
        constraints: BoxConstraints.expand(width: _width),
        child: Material(
          elevation: elevation,
          child: child,
        ),
      ),
    );
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，上述组件就是将&lt;code&gt;ConstrainedBox&lt;/code&gt;以及传入的&lt;code&gt;child&lt;/code&gt;组合成一个新的组件，其他属性则是来控制样式的。这里需要特别说明的，最后返回的&lt;code&gt;Semantics&lt;/code&gt;，它继承&lt;code&gt;SingleChildRenderObjectWidget&lt;/code&gt;，它上面定义的属性有点带有语义化的意思，而它上面定义的&lt;code&gt;child&lt;/code&gt;属性则是返回的组件，这样&lt;code&gt;return Semantices{}&lt;/code&gt;实际就表示返回了带有一些语义的组件。&lt;/p&gt;

&lt;h4 id=&#34;4-自绘组件&#34;&gt;4.自绘组件&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Flutter&lt;/code&gt;跨平台的实现方式就是在不同操作系统的上层绘制一个中间的UI系统，对不同的操作系统的&lt;code&gt;API&lt;/code&gt;进行适配，风格统一，这样就能实现一个跨平台应用了，这也是和&lt;code&gt;React Native&lt;/code&gt;的最大的差异以及优于&lt;code&gt;React Native&lt;/code&gt;的地方。当你无法用现有的组件来描绘你所需要UI时，可以考虑使用自绘组件来实现。下面是一个自绘的验证码组件示例&lt;/p&gt;

&lt;p&gt;首先创建一个名为&lt;code&gt;CodeReview&lt;/code&gt;的&lt;code&gt;StatefulWidget&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class CodeReview extends StatefulWidget {

  final String text;
  final callback;

  CodeReview({Key key, this.text, this.callback}) : super(key: key);

  _CodeReviewState createState() =&amp;gt; _CodeReviewState();

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后实现具体代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class _CodeReviewState extends State&amp;lt;CodeReview&amp;gt; {
	
  // 存放每个验证码字符上的横线的位置
  List&amp;lt;Offset&amp;gt; _lineOffsets = &amp;lt;Offset&amp;gt;[];

  // 验证码的长度，由外部传入
  int _textLength;
  // 验证码宽度
  double _width;
  // 验证码高度
  double _height;

  // 生成验证码上的横线遮挡物的位置
  void _randLines() {
    _lineOffsets.clear();
    for (var i = 0; i &amp;lt; _textLength; i++) {
      double fromX = randomBetween(10, 20).toDouble();
      double fromY = randomBetween(3, 33).toDouble();
      Offset from = Offset(fromX, fromY);
      _lineOffsets.add(from);

      double endX = randomBetween(60, _width.toInt() - 10).toDouble();
      double endY = randomBetween(3, 33).toDouble();
      Offset end = Offset(endX, endY);
      _lineOffsets.add(end);
    }
  }

  @override
  void initState() {
    super.initState();
    _textLength = widget.text.length ?? 4;
    _width = _textLength.toDouble() * 22;
    _height = 36;
    _randLines();
  }

  void _changeCode() {
    setState(() {
      _randLines();
    });
  }
	
  // 对每个字符进行随机rotate操作
  Container _subString(index) {
    return Container(
      padding: EdgeInsets.only(left: 2, right: 2, top: randomBetween(0, 14).toDouble()),
      child: Transform.rotate(
        angle: pi / randomBetween(3, 30) * randomBetween(0, 1),
        child: Text(widget.text[index], style: TextStyle(fontSize: randomBetween(20, 22).toDouble(), color: Color(0xFF4abdcc))),
      ),
    );
  }
	
 	// 描绘验证码上横线遮挡物
  Container _backLines() {
    return Container(
      width: _width,
      height: _height,
      child: CustomPaint(
        painter: CodePaint(_lineOffsets, Tool.randomColor()),
        foregroundPainter: CodePaint(_lineOffsets, Tool.randomColor()),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      width: _width,
      height: _height,
      color: Colors.grey[200],
      child: Stack(
        alignment: Alignment.center,
        children: &amp;lt;Widget&amp;gt;[
          _backLines(),
          _backLines(),
          GestureDetector(
            behavior: HitTestBehavior.opaque,
            onTap: () {
              _changeCode();
              widget.callback();
            },
            child: Container(
              width: _width,
              height: _height,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: List.generate(_textLength, (int index) {
                  return _subString(index);
                }),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到上面用到了&lt;code&gt;CustomPaint&lt;/code&gt;，这个类继承&lt;code&gt;SingleChildRenderObjectWidget&lt;/code&gt;，这让我们直接能使用&lt;code&gt;Canvas&lt;/code&gt;来绘制你所需要的UI&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class CustomPaint extends SingleChildRenderObjectWidget {
  /// Creates a widget that delegates its painting.
  const CustomPaint({
    Key key,
    this.painter,
    this.foregroundPainter,
    this.size = Size.zero,
    this.isComplex = false,
    this.willChange = false,
    Widget child,
  })......
    ......
    ......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传入&lt;code&gt;painter&lt;/code&gt; 、&lt;code&gt;foregroundPainter&lt;/code&gt;对应类，在上述代码中，是创建一个类的&lt;code&gt;CodePaint&lt;/code&gt;继承&lt;code&gt;CustomPainer&lt;/code&gt;，重写&lt;code&gt;paint&lt;/code&gt;方法，然后设置画笔的属性，最后调用对应的&lt;code&gt;Canvas&lt;/code&gt;api即可，这里使用的是&lt;code&gt;drawPoints&lt;/code&gt;，还有其他的，如&lt;code&gt;drawCircle&lt;/code&gt;、&lt;code&gt;drawLine&lt;/code&gt;等等。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class CodePaint extends CustomPainter {
  final List&amp;lt;Offset&amp;gt; lineOffsets;
  final Color ranColor;
  CodePaint(this.lineOffsets, this.ranColor);

  @override
  void paint(Canvas canvas, Size size) {
    // debugPrint(canvas.runtimeType.toString());
    canvas.save();
    Paint _paint = Paint()
      ..color = ranColor // 画笔颜色
      ..strokeCap = StrokeCap.round // 画笔笔触类型
      ..isAntiAlias = true // 是否启动抗锯齿
      ..blendMode = BlendMode.exclusion // 颜色混合模式
      ..style = PaintingStyle.fill // 绘画风格，默认为填充
      ..colorFilter = ColorFilter.mode(ranColor, BlendMode.exclusion) // 颜色渲染模式，一般是矩阵效果来改变的,但是flutter中只能使用颜色混合模式
      ..maskFilter = MaskFilter.blur(BlurStyle.inner, 1.0) // 模糊遮罩效果
      ..filterQuality = FilterQuality.high // 颜色渲染模式的质量
      // ..strokeWidth = randomBetween(1, 3).toDouble(); // 暂时固定
      ..strokeWidth = 1;

    final pointMode = PointMode.lines;
    canvas.drawPoints(pointMode, lineOffsets, _paint);
    canvas.restore();
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) {
    return false;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;综上，自绘逐渐的核心是继承&lt;code&gt;CustomPaint&lt;/code&gt;，然后使用&lt;code&gt;Canvas&lt;/code&gt;实现UI的绘制&lt;/p&gt;

&lt;h4 id=&#34;5-实现renderobject&#34;&gt;5.实现RenderObject&lt;/h4&gt;

&lt;p&gt;实现&lt;code&gt;RenderObject&lt;/code&gt;即是自己重写一整套渲染树，首先得继承一个&lt;code&gt;RenderObject&lt;/code&gt;，实现其内置仿佛，还得继承&lt;code&gt;Element&lt;/code&gt;，实现其内置方法，复杂的自定义组件最终也是通过&lt;code&gt;Canvas&lt;/code&gt; API来绘制的，而上面说的&lt;code&gt;CustomPaint&lt;/code&gt;只是为了方便开发者封装的一个代理类，它直接继承自&lt;code&gt;SingleChildRenderObjectWidget&lt;/code&gt;，通过&lt;code&gt;RenderCustomPaint&lt;/code&gt;的&lt;code&gt;paint&lt;/code&gt;方法将&lt;code&gt;Canvas&lt;/code&gt;和画笔&lt;code&gt;Painter&lt;/code&gt;连接起来实现自绘组件。这种方式操作起来实在比较麻烦，我也没怎么用过，所以就不提供示例展示了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>输入一个URL到页面呈现的过程</title>
      <link>https://xtid.github.io/2020/%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAurl%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0%E7%9A%84%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Sun, 15 Nov 2020 15:21:34 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAurl%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0%E7%9A%84%E8%BF%87%E7%A8%8B/</guid>
      <description>

&lt;h4 id=&#34;1-dns解析&#34;&gt;1.DNS解析&lt;/h4&gt;

&lt;p&gt;平时在浏览器中输入的域名并非是网址或资源真实所在的服务器地址或资源，域名只是与&lt;code&gt;ip&lt;/code&gt;地址的一个映射。在进行正式的请求之前，就会先有这个过程：&lt;code&gt;DNS&lt;/code&gt;服务将域名解析成对应的&lt;code&gt;ip&lt;/code&gt;地址。其解析过程：&lt;/p&gt;

&lt;p&gt;1.检查本机&lt;code&gt;host&lt;/code&gt;中是否有配置相应的&lt;code&gt;ip&lt;/code&gt;映射关系，如果有则使用这个&lt;code&gt;ip&lt;/code&gt;地址，完成域名解析
2.检查浏览器缓存中是否缓存过该域名对应的&lt;code&gt;ip&lt;/code&gt;地址
3.检查找本机系统中是否缓存过&lt;code&gt;ip&lt;/code&gt;
4.向本地域名解析服务发起域名解析的请求
5.向根域名解析服务器发起域名解析请求
6.按照根域名&lt;code&gt;(.)&lt;/code&gt; -&amp;gt; 顶级域&lt;code&gt;(如：.com)&lt;/code&gt; -&amp;gt; 第二层域&lt;code&gt;(如：xxx.com)&lt;/code&gt; -&amp;gt; 子域&lt;code&gt;(如：www.xxx.com)&lt;/code&gt;的顺序查找到ip地址
8.返回解析结果给用户&lt;/p&gt;

&lt;h4 id=&#34;2-建立-tcp-连接&#34;&gt;2.建立&lt;code&gt;TCP&lt;/code&gt;连接&lt;/h4&gt;

&lt;p&gt;经典的三次握手&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;第一次握手： 建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；&lt;/p&gt;

&lt;p&gt;第二次握手： 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；&lt;/p&gt;

&lt;p&gt;第三次握手： 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单来说其步骤就是，客户端发送数据包告诉服务端连接请求，服务端返回数据包响应表示可以收到建立连接请求并且返回数据包通知客户端，客服端再次发送数据包确认并建立&lt;code&gt;TCP&lt;/code&gt;连接&lt;/p&gt;

&lt;h4 id=&#34;3-发送-http-请求&#34;&gt;3.发送&lt;code&gt;HTTP&lt;/code&gt;请求&lt;/h4&gt;

&lt;p&gt;一个&lt;code&gt;HTTP&lt;/code&gt;请求包含请求行，请求头，请求主体&lt;/p&gt;

&lt;h5 id=&#34;3-1请求行&#34;&gt;3.1请求行&lt;/h5&gt;

&lt;p&gt;常见的信息有请求地址、请求方法&lt;code&gt;GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE&lt;/code&gt;、&lt;code&gt;Http&lt;/code&gt;协议信息&lt;/p&gt;

&lt;h5 id=&#34;3-2请求头&#34;&gt;3.2请求头&lt;/h5&gt;

&lt;p&gt;常见的请求头信息有&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Host&lt;/code&gt;：主机名
&lt;code&gt;Connection&lt;/code&gt;：&lt;code&gt;HTTP/1.1&lt;/code&gt;增加的，使用&lt;code&gt;keepalive&lt;/code&gt;，一个连接可以发多个请求
&lt;code&gt;User-Agent&lt;/code&gt;：客户端程序的信息，就是发送请求的浏览器信息，可根据这个信息来对不同设备进行处理
&lt;code&gt;Accept&lt;/code&gt;：浏览器可以接收的媒体数据类型
&lt;code&gt;Accept-Encoding&lt;/code&gt;：是浏览器用来告知服务器它能够支持的内容编码及内容编码的优先级顺序，可一次性指定多种内容编码
&lt;code&gt;Accept-Language&lt;/code&gt;：告诉服务器浏览器能够处理的自然语言集
&lt;code&gt;Content-Type&lt;/code&gt;：请求中的数据的媒体类型
&lt;code&gt;Cookie&lt;/code&gt;：浏览器记录的用户相关信息&lt;/p&gt;

&lt;p&gt;当然还有很多其他的，这里就不罗列完了，另外还可以自己添加一些自定义请求头，在服务端手动获取处理就行了&lt;/p&gt;

&lt;h5 id=&#34;3-3请求主体&#34;&gt;3.3请求主体&lt;/h5&gt;

&lt;p&gt;主要是请求所带的一些参数信息，这里就不多赘述&lt;/p&gt;

&lt;h4 id=&#34;4-使用浏览器缓存&#34;&gt;4.使用浏览器缓存&lt;/h4&gt;

&lt;p&gt;浏览器缓存主要&lt;code&gt;强缓存&lt;/code&gt;和&lt;code&gt;协商缓存&lt;/code&gt;，具体使用哪一种缓存，强缓存的优先级比协商缓存高，怎么设置还是得从实际出发&lt;/p&gt;

&lt;h5 id=&#34;4-1强缓存&#34;&gt;4.1强缓存&lt;/h5&gt;

&lt;p&gt;强缓存可以用&lt;code&gt;Expires&lt;/code&gt;和&lt;code&gt;Cache-Control&lt;/code&gt;来控制，强缓存最大的特点就是通过服务器返回的过期时间来判断缓存是否过期，不会再去和服务端做校验看资源是否真正更新了&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Expires&lt;/code&gt;：主由服务端返给客户端，在过期时间内，浏览器可直接使用缓存而不需要重新请求，但它也有不少局限，首先它只能精确到秒，对于那种毫秒级更新的资源它没办法判断，其次它受限于本地时间，如果修改了本地时间，可能会造成缓存失效。&lt;code&gt;Expires&lt;/code&gt;是&lt;code&gt;Http/1&lt;/code&gt;时候的请求头，现在这样设置通常也是为了兼容&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Cache-Control&lt;/code&gt;：是现在主要使用的方式，可以在请求头以及响应头中设置，常见设置有&lt;code&gt;max-age(表示缓存在多少秒后过期)&lt;/code&gt;，&lt;code&gt;no-cache(表示使用Etag或者Last-Modified字段来控制缓存，即协商缓存)&lt;/code&gt;，通常来讲，&lt;code&gt;Cache-control&lt;/code&gt;的优先级是要高于&lt;code&gt;Expires&lt;/code&gt;的&lt;/p&gt;

&lt;h5 id=&#34;4-2协商缓存&#34;&gt;4.2协商缓存&lt;/h5&gt;

&lt;p&gt;在强缓存失效后就会用协商缓存，协商缓存主要使用&lt;code&gt;Last-Modified 和 ETag&lt;/code&gt;请求头控制，这两个字段都是由服务端返回的。如果说缓存还生效，那么这次请求的状态码会返回&lt;code&gt;304&lt;/code&gt;，表示资源未改动，如果缓存失效，返回新的资源并设置缓存，返回&lt;code&gt;200&lt;/code&gt;状态码&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Last-Modified&lt;/code&gt;：在设置&lt;code&gt;Last-Modified&lt;/code&gt;后，下次请求时请求头会带上&lt;code&gt;If-Modified-Since&lt;/code&gt;这个字段，然后服务器会用这个时间与资源修改时间做对比，然后就是返回&lt;code&gt;304&lt;/code&gt;还是&lt;code&gt;200&lt;/code&gt;的问题了，同样它也只能精确到秒，所以一些需要毫秒级更新的资源使用这个并不准确&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ETag&lt;/code&gt;：通常与&lt;code&gt;If-None-Match&lt;/code&gt;配合使用，&lt;code&gt;Etag&lt;/code&gt;为服务端为这资源生成的唯一标识，下次客户端请求的时候，带上这个值，由服务端再做校验，如果资源未改动，返回&lt;code&gt;304&lt;/code&gt;，使用原来的缓存，反之返回&lt;code&gt;200&lt;/code&gt;，设置缓存&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/10/28/O2gaJWm8jYPeI7c.png&#34; alt=&#34;浏览器缓存.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图出自&lt;a href=&#34;https://github.com/ljianshu/Blog&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;博客&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;5-浏览器接收响应&#34;&gt;5.浏览器接收响应&lt;/h4&gt;

&lt;p&gt;响应分为状态码，响应头，响应主体组成，响应主体通常是一些文件&lt;code&gt;如(HTML、JS、CSS文件)&lt;/code&gt;或者说是一些响应数据&lt;code&gt;(请求的响应数据)&lt;/code&gt;，状态码和响应头这里就不罗列了。有个特别的通常为了提升响应的效率，服务端会将一些进行&lt;code&gt;gzip&lt;/code&gt;压缩，然后响应头里面会有个响应头&lt;code&gt;content-encoding:gzip&lt;/code&gt;，然后浏览器会再进行解压&lt;/p&gt;

&lt;h4 id=&#34;6-页面渲染&#34;&gt;6.页面渲染&lt;/h4&gt;

&lt;p&gt;在接收响应成功之后，浏览器就开始渲染页面了。其步骤包括：1.解析&lt;code&gt;HTML&lt;/code&gt;为&lt;code&gt;DOM&lt;/code&gt;树、2.解析&lt;code&gt;CSS&lt;/code&gt;为&lt;code&gt;CSS&lt;/code&gt;树、3.合并&lt;code&gt;DOM&lt;/code&gt;树已经&lt;code&gt;CSS&lt;/code&gt;树、4.遍历整个节点、5.按照&lt;code&gt;CSS&lt;/code&gt;的优先级渲染每个节点的样式，呈现在屏幕上。当浏览器遇到一个&lt;code&gt;script&lt;/code&gt;标记时，&lt;code&gt;DOM&lt;/code&gt;构建将暂停，直至脚本完成执行，然后继续构建&lt;code&gt;DOM&lt;/code&gt;。每次去执行&lt;code&gt;JS&lt;/code&gt;脚本都会严重阻塞&lt;code&gt;DOM&lt;/code&gt;树的构建，如果&lt;code&gt;JS&lt;/code&gt;脚本还操作的&lt;code&gt;CSSOM&lt;/code&gt;，而正好这个&lt;code&gt;CSSOM&lt;/code&gt;还没有下载和构建，浏览器甚至会延迟脚本执行和构建&lt;code&gt;DOM&lt;/code&gt;，直至完成其&lt;code&gt;CSSOM&lt;/code&gt;的下载和构建。所以这里通常会有个常见的小优化，&lt;code&gt;CSS&lt;/code&gt;放在顶部，&lt;code&gt;JS&lt;/code&gt;放在底部，并且减少使用在加载的过程中操作&lt;code&gt;DOM&lt;/code&gt;，当然这也是比较老的做法了。在页面加载的过程中，所写的&lt;code&gt;CSS&lt;/code&gt;和&lt;code&gt;JS&lt;/code&gt;也要尽量避免重绘和回流&lt;/p&gt;

&lt;h4 id=&#34;7-四次握手&#34;&gt;7.四次握手&lt;/h4&gt;

&lt;p&gt;四次握手用于断开&lt;code&gt;Tcp&lt;/code&gt;连接，客户端发送请求表示要断开连接，服务接受到请求后响应，客户端收到响应准备断开连接，服务端将其余数据或没响应的数据全部返给客户端(即又一次握手)，客户端收到后响应后再发送请求确认关闭，服务端收到后断开连接&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&#34;参考链接&#34;&gt;参考链接&lt;/h6&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ljianshu/Blog&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;博客&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>浅谈前端统计</title>
      <link>https://xtid.github.io/2020/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E7%BB%9F%E8%AE%A1/</link>
      <pubDate>Wed, 28 Oct 2020 21:45:40 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E7%BB%9F%E8%AE%A1/</guid>
      <description>&lt;p&gt;监控系统在现在的项目中是必不可少的，它具有性能监控、错误监控以及数据上报等功能。通过对的错误监控、用户正常行为的收集，从而指定对应的优化方案、营销策略以及项目的迭代。 试想，如果没有这些监控系统，那么线上的运行的项目出问题了，定位是比较困难的，这时候修复起来就比较劳神了。我记录下我所了解的，常见的方式。&lt;/p&gt;

&lt;p&gt;1.错误监控&lt;/p&gt;

&lt;p&gt;我们对于错误的处理，在&lt;code&gt;js&lt;/code&gt;中很常见的错误捕获&lt;code&gt;try catch&lt;/code&gt;、&lt;code&gt;promise中的catch&lt;/code&gt;等等。在window对象上有一个方法&lt;code&gt;onerror&lt;/code&gt;，可以拿到当前报错的信息，我们就可以将这个信息拿到然后提交到我们自己的监控系统，还有个很重要的原因，不处理这些错误，导致页面挂了停止加载，那损失可就大了。对于抛出的错误，它有几个属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 定义一个错误对象
const defaults = {
  msg: &#39;&#39;, // 错误的具体信息
  url: &#39;&#39;, // 错误所在的url
  line: &#39;&#39;, // 错误所在的行
  col: &#39;&#39;, // 错误所在的列
  nowTime: &#39;&#39; // 时间
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后实现&lt;code&gt;window.onerror&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;window.onerror = function (msg, url, line, col, error) {
  col = col || (window.event &amp;amp;&amp;amp; window.event.errorCharacter) || 0

  defaults.url = url
  defaults.line = line
  defaults.col = col
  defaults.nowTime = new Date().getTime()

  if (error &amp;amp;&amp;amp; error.stack) {
    // 如果浏览器有错误堆栈信息，直接使用
    defaults.msg = error.stack.toString()
  } else if (arguments.callee) {
    // 通过callee拿堆栈信息
    let ext = []
    let fn = arguments.callee.caller
    // 最多拿到三层
    let floor = 3
    while (fn &amp;amp;&amp;amp; (--floor &amp;gt; 0)) {
      ext.push(fn.toString())
      if (fn === fn.caller) {
        break
      }
      fn = fn.caller
    }
    ext = ext.join(&#39;,&#39;)
    defaults.msg = error &amp;amp;&amp;amp; error.stack &amp;amp;&amp;amp; error.stack.toString()
  }
  let str = &#39;&#39;
  // 格式化这些错误信息
  for (const i in defaults) {
    if (!defaults[i]) {
      defaults[i] = &#39;null&#39;
    }
    str += &#39;&amp;amp;&#39; + i + &#39;=&#39; + defaults[i].toString()
  }
  // 确定错误是由哪位用户引起的，这一步有些时候可以不用
  let userinfo = // 拿到用户信息
  if (typeof userinfo === &#39;object&#39;) {
    userinfo = JSON.stringify(userinfo)
  }
  if (userinfo) userinfo = encodeURIComponent(userinfo)
  str = encodeURIComponent(str.replace(&#39;&amp;amp;&#39;, &#39;&#39;).replace(&#39;\n&#39;, &#39;&#39;).replace(/\s/g, &#39;&#39;))
	
  // 避免出现跨域错误
  new Image().src = &#39;api地址?msg=&#39; + str + &#39;&amp;amp;userinfo=&#39; + userinfo
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方式的缺陷在于，没办法处理&lt;code&gt;promise&lt;/code&gt;中未处理的错误，对于&lt;code&gt;promise&lt;/code&gt;，推荐使用&lt;code&gt;unhandledrejection&lt;/code&gt;事情处理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;window.addEventListener(&#39;unhandledrejection&#39;, event =&amp;gt; {
  let error = event.reason &amp;amp;&amp;amp; event.reason.message
  if (!error) {
    error = typeof event.reason === &#39;object&#39; ? JSON.stringify(event.reason) : event.reason
  }

  (new Image()).src = &#39;api地址?msg=&#39; + encodeURIComponent(error)
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.埋点&lt;/p&gt;

&lt;p&gt;埋点是一种常见的统计用户行为的方式或工具。通过在页面设置埋点，来统计用户对于某个页面、广告、功能的使用频率、喜好，然后通过对埋点的数据统计，确定好页面或功能的迭代。简单的做法，设置一个全局方法用来提交埋点点击的行为，在需要的地方调用这个方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 定义一个全局方法
// 传入的point为埋点数据
function clickPoint(point = {}) {
  const { id, name } = point
  cosnt userInfo = // 通过对应的操作拿到用户信息
  // 基础参数
  const basicParams = {
    id: id || &#39;&#39;,
    name: name || &#39;&#39;
  }
  // 用户信息
 	const userParams = {
  	name: userInfo.name || &#39;&#39;
    ......
 	}
  // 合并参数
  const params = {
    ...basicParams,
    ...userParams
  }
  let str = &#39;&#39;
  for (const i in params) {
    if (!params[i]) {
      params[i] = &#39;null&#39;
    }
    str += &#39;&amp;amp;&#39; + i + &#39;=&#39; + params[i].toString()
  }
  new Image().src = &#39;api地址?msg=&#39; + str
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常这样来统计页面上某个功能、某个广告的点击量，获取对应的统计数据。还有一种比较常见的方式，为需要添加埋点的&lt;code&gt;html&lt;/code&gt;标签上加上某个约定好的自定义属性，如&lt;code&gt;&amp;lt;div data-link=&amp;quot;111&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;，这个&lt;code&gt;111&lt;/code&gt;就是就是实现生成好或者规划好的埋点。然后给这种属性添加全局的点击事件，点击后同样的将对应的数据提交到自己的后台系统去。有些时候为了方便查阅或者直观的观看统计数据，还可以在页面渲染的时候，为含有&lt;code&gt;data-link&lt;/code&gt;属性的标签生成对应的一些图标或者文字标签，使用&lt;code&gt;absolute&lt;/code&gt;定位显示在对应的元素上，当然这种方式在你添加买点埋点属性的时候，需要给这个元素设置相应的&lt;code&gt;position css&lt;/code&gt;属性；当然也可能设置一些热力图啊等其它形式，反正都是实现同一个效果的。&lt;/p&gt;

&lt;p&gt;3.白屏时间&lt;/p&gt;

&lt;p&gt;这个之前说过，就不说废话了，白屏时间的统计是非常重要的。比如有些时候，只有某个用户的某个设备出现了页面加载过长，页面没内容，发现这个问题后，通过判断错误日志和白屏时间才能更快的定位问题。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;window.logInfo = {}
window.logInfo.openTime = window.performance &amp;amp;&amp;amp; window.performance.timing.navigationStart || 0
window.logInfo.whiteScreenTime = +new Date() - window.logInfo.openTime
window.logInfo.mobile = mobileType()

// 使用 DOMContentLoaded 统计页面有内容的时间
document.addEventListener(&#39;DOMContentLoaded&#39;, function () {
  window.logInfo.readyTime = +new Date() - window.logInfo.openTime
})
window.onload = function () {
  window.logInfo.allloadTime = +new Date() - window.logInfo.openTime
  window.logInfo.nowTime = new Date().getTime()
  let timname = {
    whiteScreenTime: &#39;白屏时间&#39;,
    readyTime: &#39;用户可操作时间&#39;,
    allloadTime: &#39;总下载时间&#39;,
    mobile: &#39;使用设备&#39;,
    nowTime: &#39;时间&#39;,
  }
  let logStr = &#39;&#39;
  for (const i in timname) {
    if (i === &#39;mobile&#39;) {
      logStr += &#39;&amp;amp;&#39; + i + &#39;=&#39; + window.logInfo[i]
    } else {
      logStr += &#39;&amp;amp;&#39; + i + &#39;=&#39; + window.logInfo[i]
    }
  }
  // 这里如果需要的话，还可以把用户的一些信息收集出来
  (new Image()).src = &#39;api地址?msg=&#39; + logStr
}

function mobileType() {
  const u = navigator.userAgent
  // 移动终端浏览器版本信息
  const type = {
    ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), // ios终端
    iPad: u.indexOf(&#39;iPad&#39;) &amp;gt; -1, // 是否iPad
    android: u.indexOf(&#39;Android&#39;) &amp;gt; -1 || u.indexOf(&#39;Linux&#39;) &amp;gt; -1, // android终端或者uc浏览器
    iPhone: u.indexOf(&#39;iPhone&#39;) &amp;gt; -1 || u.indexOf(&#39;Mac&#39;) &amp;gt; -1, // 是否为iPhone或者QQHD浏览器
    trident: u.indexOf(&#39;Trident&#39;) &amp;gt; -1, // IE内核
    presto: u.indexOf(&#39;Presto&#39;) &amp;gt; -1, // opera内核
    webKit: u.indexOf(&#39;AppleWebKit&#39;) &amp;gt; -1, // 苹果、谷歌内核
    gecko: u.indexOf(&#39;Gecko&#39;) &amp;gt; -1 &amp;amp;&amp;amp; u.indexOf(&#39;KHTML&#39;) === -1, // 火狐内核
    mobile: !!u.match(/AppleWebKit.*Mobile/i) || !!u.match(/MIDP|SymbianOS|NOKIA|SAMSUNG|LG|NEC|TCL|Alcatel|BIRD|DBTEL|Dopod|PHILIPS|HAIER|LENOVO|MOT-|Nokia|SonyEricsson|SIE-|Amoi|ZTE/), // 是否为移动终端
    webApp: u.indexOf(&#39;Safari&#39;) === -1 // 是否web应该程序，没有头部与底部
  }
  const lists = Object.keys(type)
  for (const i = 0; i &amp;lt; lists.length; i++) {
    if (type[lists[i]]) {
      return lists[i]
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>白屏时间</title>
      <link>https://xtid.github.io/2020/%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4/</link>
      <pubDate>Sat, 24 Oct 2020 23:45:12 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4/</guid>
      <description>&lt;p&gt;白屏时间指的是从用户进入网站，一直到页面有内容展示出来的时间节点，在这期间用户什么东西都看不到，这个过程包括dns查询、建立tcp连接、发送首个http请求、返回html文档、html文档head解析完毕。白屏时间的长短，影响着用户的体验，白屏时间过长，用户失去了耐心等待，也许就关闭了网页&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一份是 &lt;a href=&#34;http://www.akamai.com/html/about/press/releases/2009/press_091409.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Akamai&lt;/a&gt; 的研究报告，当时总共采访了大约 1048 名网上购物者，得出了这样的结论：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;大约有 47% 的用户期望他们的页面在两秒之内加载完成。&lt;/li&gt;
&lt;li&gt;如果页面加载时间超过 3s，大约有 40% 的用户选择离开或关闭页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;白屏时间的计算就如上诉定义说的那样，只需要记录用户进入页面的开始时间，记录head加载完成的时间，记录两者的差值，这就是所说的白屏时间。计算的时候可以分别获取两个时间，计算他们的差，也可以使用&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/mark&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;performance.mark&lt;/a&gt;，在开始地点标记或者说打点，在结束地点获取这个&lt;code&gt;entry&lt;/code&gt;，拿到它的&lt;code&gt;duration&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
	&amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
	&amp;lt;title&amp;gt;白屏时间&amp;lt;/title&amp;gt;
	&amp;lt;script&amp;gt;
		window.startTime = Date.now();
    // performance.mark(&amp;quot;timeStr&amp;quot;);
	&amp;lt;/script&amp;gt;
	&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;&amp;quot;&amp;gt;
	&amp;lt;script src=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
	&amp;lt;script&amp;gt;
		window.endTime = Date.now()
    // const timeStrEntries = performance.getEntriesByName(&amp;quot;timeStrEntries&amp;quot;);
    // console.log(timeStrEntries[0].duration)
	&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外还有一种方式，使用&lt;code&gt;window.performance&lt;/code&gt;，在&lt;code&gt;timing&lt;/code&gt;对象中，包含了各种时间相关的属性，其中&lt;code&gt;domLoading&lt;/code&gt;属性代表开始解析&lt;code&gt;DOM&lt;/code&gt;元素的时间，&lt;code&gt;fetchStart&lt;/code&gt;属性代表发送请求前的时间，两者之差也可以计算白屏时间&lt;/p&gt;

&lt;p&gt;对于具体的时间优化，可以针对整个页面渲染的过程来处理。这里说一下：&lt;code&gt;预渲染&lt;/code&gt;、&lt;code&gt;服务端渲染&lt;/code&gt;、&lt;code&gt;使用骨架屏&lt;/code&gt;，这也可以说是用户的体验优化&lt;/p&gt;

&lt;p&gt;首先预渲染，主要是用&lt;code&gt;prerender-spa-plugin&lt;/code&gt;来实现这个功能。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;prerender-spa-plugin 利用了 Puppeteer 的爬取页面的功能。 Puppeteer 是 Google Chrome 团队官方的无界面（Headless）Chrome 工具，它是一个 Node 库，提供了一个高级的 API 来控制 DevTools 协议上的无头版 Chrome 。prerender-spa-plugin 原理是在 Webpack 构建阶段的最后，在本地启动一个 Puppeteer 的服务，访问配置了预渲染的路由，然后将 Puppeteer 中渲染的页面输出到 HTML 文件中，并建立路由对应的目录。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先请求到对应的路由或者页面之后，&lt;code&gt;Puppeteer&lt;/code&gt;会获取渲染的页面的静态部分内容并替换打包出来的&lt;code&gt;html&lt;/code&gt;文件，达到预渲染的目的，页面加载完成之前呈现给用户部分内容，给用户一个相对好的体验。但是缺点是预渲染出的内容往往与最终渲染的页面内容不同，因为页面会有相应的交互或者数据的变化，所以最好对于一些静态页面才用这种方式处理。&lt;/p&gt;

&lt;p&gt;首先在对应的&lt;code&gt;webpack&lt;/code&gt;配置文件中添加这个插件的配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const PrerenderSPAPlugin = require(&#39;prerender-spa-plugin&#39;);
const Renderer = PrerenderSPAPlugin.PuppeteerRenderer;
const path = require(&#39;path&#39;);

module.exports = {
  plugins: [new PrerenderSPAPlugin({
    staticDir: path.join(__dirname, &#39;dist&#39;),
    routes: [ &#39;/&#39; ], // 需要预渲染的路由,
    renderer: new Renderer({
        headless: true, // 开启无头浏览器
        renderAfterDocumentEvent: &#39;render-event&#39;, 
    }),
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在页面触发&lt;code&gt;render-event&lt;/code&gt;事件，告诉&lt;code&gt;Puppeteer&lt;/code&gt;去爬取这个页面，这里以&lt;code&gt;vue&lt;/code&gt;为例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export default {
  mounted() {
    document.dispatchEvent(new Event(&#39;render-event&#39;));
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后访问对应的&lt;code&gt;route&lt;/code&gt;，在&lt;code&gt;index.html&lt;/code&gt;中就可以看到相应的内容了。实际应用中在静态页面中的时候，应当另外指定对应的&lt;code&gt;html&lt;/code&gt;文件，如果配置了&lt;code&gt;CDN&lt;/code&gt;，那么在本地开发的时候，应该将&lt;code&gt;CDN&lt;/code&gt;地址替换为本地地址，这个插件也提供了&lt;code&gt;server&lt;/code&gt;选项&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;server: {
  port: 80,
  proxy: {
    ......
    target: &#39;http://localhost&#39;,
    changeOrigin: true,
    ......
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务端渲染&lt;/p&gt;

&lt;p&gt;服务端渲染是由服务端将渲染好的&lt;code&gt;html&lt;/code&gt;字符串直接返给客户端，客户端接受到对应的&lt;code&gt;html&lt;/code&gt;字符串后，解析渲染呈现出相应的页面。客户端渲染时，客户端需要去请求相应的接口取得相应的数据然后渲染出&lt;code&gt;html&lt;/code&gt;页面，因此，服务端渲染白屏时间相对较短。还有个额外的好处当然是利于SEO，这个作用恐怕还在白屏优化之上。客户端渲染一开始的页面为空，在某些爬虫来爬的时候什么东西都获取不到，所以不利于SEO，当然这是后话了。现在我们这用的比较多的，一般是以&lt;code&gt;nodejs&lt;/code&gt;为中间层，接受到客户端的请求后，发送真正的请求到后台，随后在&lt;code&gt;nodejs&lt;/code&gt;中处理完对应的数据，渲染页面。现在以&lt;code&gt;react&lt;/code&gt;、&lt;code&gt;vue&lt;/code&gt;为基础，也有各自对应的服务端渲染方案，如&lt;code&gt;next.js&lt;/code&gt;、&lt;code&gt;nuxt.js&lt;/code&gt;这里就不介绍了&lt;/p&gt;

&lt;p&gt;骨架屏&lt;/p&gt;

&lt;p&gt;骨架屏可以看做用来代替页面&lt;code&gt;loading&lt;/code&gt;效果的一种方案，在页面加载完成之前，呈现出页面的一个大致结构，给用户一个良好的体验，让他觉得这个页面正在缓慢加载，这种效果看起来也比单纯的放一张菊花图、一张加载动画好一些。这个方案更多的是带来更好的用户体验。手写骨架屏，首先确定页面的基本结构，然后按照这个结构写一个类似的加载页面，这个由设计来定。以下介绍使用&lt;code&gt;webpack(4.0+)&lt;/code&gt;来写一个简单的骨架屏插件。&lt;/p&gt;

&lt;p&gt;首先定义一个骨架屏插件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)

let Skeleton = function (options) {
  // 接收传入的参数
}

Skeleton.prototype.apply = function (compiler) {
  compiler.plugin(&#39;compilation&#39;, compilation =&amp;gt; {
    HtmlWebpackPlugin.getHooks(compilation).beforeEmit.tapAsync(
      &#39;Skeleton&#39;,
      (htmlData, cb) =&amp;gt; {
        htmlData.html = htmlData.html.replace(&#39;&amp;lt;div id=&amp;quot;root&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#39;, `骨架屏代码`)
        cb(null, htmlData)
      }
    )
  })
}

module.exports = Skeleton
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后&lt;code&gt;webpack&lt;/code&gt;配置文件中引入即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;...
new HtmlWebPackPlugin({
  template: &#39;public/index.html&#39;,
  filename: &#39;index.html&#39;,
  inject: true
}),
new Skeleton({
  template: &#39;public/index.html&#39;
})
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.以上首先定义一个插件对象&lt;code&gt;Skeleton&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2.引入&lt;code&gt;html-webpack-plugin&lt;/code&gt;，在&lt;code&gt;html-webpack-plugin&lt;/code&gt;的钩子函数&lt;code&gt;beforeEmit&lt;/code&gt;中，调用这个&lt;code&gt;Skeleton&lt;/code&gt;对象，&lt;/p&gt;

&lt;p&gt;&lt;code&gt;beforeEmit&lt;/code&gt;这个钩子函数的作用在于&lt;code&gt;html-webpack-plugin&lt;/code&gt;插件将生成的&lt;code&gt;html&lt;/code&gt;插入模板文件前进行的操作。这里就相当于在生成真正的&lt;code&gt;html&lt;/code&gt;代码之前调用生成骨架屏页面。&lt;/p&gt;

&lt;p&gt;3.调用&lt;code&gt;cb&lt;/code&gt;，传回&lt;code&gt;html&lt;/code&gt;内容&lt;/p&gt;

&lt;p&gt;4.需要注意的是，&lt;code&gt;replace&lt;/code&gt;中的需要替换的根元素、类名不要搞错了。&lt;/p&gt;

&lt;p&gt;其余的，根据不同的路径，入口可以将参数传入这个构造函数中，然后判断显示不同的骨架屏。最大的缺点就是复用性不强，也许会随着页面的迭代而经常变动，维护起来也很麻烦。&lt;/p&gt;

&lt;p&gt;还有些其他自动生成骨架屏的开源方案。比如饿了么开源的&lt;code&gt;page-skeleton-webpack-plugin&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;通过 &lt;a href=&#34;https://link.zhihu.com/?target=https%3A//github.com/GoogleChrome/puppeteer&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;puppeteer&lt;/a&gt; 在服务端操控 &lt;a href=&#34;https://link.zhihu.com/?target=https%3A//developers.google.com/web/updates/2017/04/headless-chrome&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;headless Chrome&lt;/a&gt; 打开开发中的需要生成骨架屏的页面，在等待页面加载渲染完成之后，在保留页面布局样式的前提下，通过对页面中元素进行删减或增添，对已有元素通过层叠样式进行覆盖，这样达到在不改变页面布局下，隐藏图片和文字，通过样式覆盖，使得其展示为灰色块。然后将修改后的 HTML 和 CSS 样式提取出来，这样就是骨架屏了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;它的大致原理，就是利用&lt;code&gt;puppeteer&lt;/code&gt;获取页面结构，将不同的节点分类处理，展现不同的&amp;rsquo;骨架效果&amp;rsquo;，最后实际渲染的时候，进行相应的替换。但是就针对于这个项目&lt;code&gt;page-skeleton-webpack-plugin&lt;/code&gt;来说，坑比较多，而且不支持&lt;code&gt;webpack4&lt;/code&gt;，慎重使用。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Webpack打包优化</title>
      <link>https://xtid.github.io/2020/webpack%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 07 Sep 2020 22:03:34 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/webpack%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/</guid>
      <description>&lt;p&gt;之前了解了&lt;code&gt;webpack&lt;/code&gt;的基本打包流程或者说原理，如果只是配置一个基本的&lt;code&gt;webpack&lt;/code&gt;打包配置，
打包后的文件会变得很大，当你项目部署后，用户打开对应的界面，也许会很长时间才加载完(当然和网络环境或硬件设备也有关系)，尤其是单页面应用效果很明显，这样的用户体验自然是不好的，所以此文章主要是对&lt;code&gt;webpack&lt;/code&gt;打包优化的一个小小总结&lt;/p&gt;

&lt;p&gt;首先搭建好一个基本的项目，目录结构&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;├── dist // 打包目录
│   ├── bundle.js // 打包后的js
│   └── index.html // 入口html文件
├── package-lock.json
├── package.json
├── public
│   └── index.html // html模板文件
├── src
│   ├── actions // redux actions文件
│   │   └── index.js
│   ├── app.js // webpack打包入口文件，也是项目的入口文件
│   ├── assets // scss
│   │   ├── about.scss
│   │   ├── title.scss
│   │   └── user.scss
│   ├── dev.js // 开发时的一些配置
│   ├── pages // page页面
│   │   ├── about.jsx
│   │   ├── index.jsx
│   │   ├── title.jsx
│   │   └── user.jsx
│   ├── reducers // redux中的reducer
│   │   └── index.js
│   └── store.js
└── webpack.config.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt;基本配置如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const path = require(&#39;path&#39;)
const HtmlWebPackPlugin = require(&#39;html-webpack-plugin&#39;)

module.exports = {
  entry: &#39;./src/app.js&#39;,
  output: {
    path: path.resolve(__dirname, &#39;./dist/&#39;),
    filename: &#39;bundle.js&#39;
  },
  resolve: {
    extensions: [&#39;.wasm&#39;, &#39;.mjs&#39;, &#39;.js&#39;, &#39;.json&#39;, &#39;.jsx&#39;]
  },

  devServer: {
    contentBase: path.join(__dirname, &#39;./src/&#39;),
    publicPath: &#39;/&#39;,
    host: &#39;127.0.0.1&#39;,
    port: 3000,
    hot: true,
    stats: {
      colors: true
    }
  },
  module: {
    rules: [{
      test: /\.jsx?$/,
      exclude: /node_modules/,
      use: {
        loader: &#39;babel-loader&#39;
      }
    }, {
      test: /\.scss$/,
      use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;]
    }]
  },
  plugins: [
    new HtmlWebPackPlugin({
      template: &#39;public/index.html&#39;,
      filename: &#39;index.html&#39;,
      inject: true
    })
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优化：&lt;/p&gt;

&lt;p&gt;1.基础优化&lt;/p&gt;

&lt;p&gt;配置&lt;code&gt;loader&lt;/code&gt;，添加&lt;code&gt;exclude&lt;/code&gt;、&lt;code&gt;include&lt;/code&gt;缩小搜索范围，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  test: /\.jsx?$/,
    exclude: /node_modules/, // 过滤node_modules
    use: {
    	loader: &#39;babel-loader&#39;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.使用&lt;code&gt;DllPlugin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;将一些变动较少或者根本不会变动的库先打包生成对应的&lt;code&gt;.dll.js&lt;/code&gt;，在&lt;code&gt;webpack&lt;/code&gt;打包的时候，将这些资源引入&lt;/p&gt;

&lt;p&gt;首先新建一个&lt;code&gt;webpack.config.dll.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const path = require(&#39;path&#39;);
const DllPlugin = require(&#39;webpack/lib/DllPlugin&#39;);

module.exports = {
  entry: {
    react: [&#39;react&#39;, &#39;react-dom&#39;]
  },
  output: {
    filename: &#39;[name].dll.js&#39;,
    // 生成的文件目录
    path: path.resolve(__dirname, &#39;dist&#39;),
    // 动态链接库名称
    library: &#39;_dll_[name]&#39;
  },
  plugins: [
    new DllPlugin({
      name: &#39;_dll_[name]&#39;,
      path: path.join(__dirname, &#39;dist&#39;, &#39;[name].manifest.json&#39;),
      context: __dirname, 
    })
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在&lt;code&gt;package.json&lt;/code&gt;的&lt;code&gt;scripts&lt;/code&gt;中添加dll打包命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;webpack --config webpack.config.dll.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后运行此命令，可以看到会在&lt;code&gt;dist&lt;/code&gt;目录下面生成&lt;code&gt;react.dll&lt;/code&gt;，&lt;code&gt;react.manifest.json&lt;/code&gt;两个文件，这就是生成的&lt;code&gt;dll&lt;/code&gt;文件，然后&lt;code&gt;webpack.config.js&lt;/code&gt;里面添加配置，打包时引入这些的&lt;code&gt;dll&lt;/code&gt;文件。&lt;/p&gt;

&lt;p&gt;首先安装插件&lt;code&gt;add-asset-html-webpack-plugin&lt;/code&gt;，引入&lt;code&gt;DllReferencePlugin&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const DllReferencePlugin = require(&#39;webpack/lib/DllReferencePlugin&#39;)
const AddAssetHtmlPlugin = require(&#39;add-asset-html-webpack-plugin&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;插件里面配置(webpack4+)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;new DllReferencePlugin({
  context: __dirname,
  manifest: require(&#39;./dist/react.manifest.json&#39;),
}),
new AddAssetHtmlPlugin({
  filepath: path.resolve(__dirname, &#39;./dist/react.dll.js&#39;)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样打包时页面就会引入&lt;code&gt;react.dll.js&lt;/code&gt;资源了，从而减少重复的资源打包。这种方式可以简单的理解为，抽出公共模块打包，然后引入&lt;/p&gt;

&lt;p&gt;3.&lt;code&gt;splitChunks&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以前&lt;code&gt;webpack&lt;/code&gt;拆分模块还会用&lt;code&gt;CommonsChunkPlugin&lt;/code&gt;，在&lt;code&gt;webpack4&lt;/code&gt;后，可以直接用&lt;code&gt;splitChunks&lt;/code&gt;来代替完成这项工作，在&lt;code&gt;optimization&lt;/code&gt;里面设置了&lt;code&gt;splitChunks&lt;/code&gt;后，打包分割出来的文件是默认压缩过的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;splitChunks: {
  chunks: &amp;quot;async&amp;quot;, // &amp;quot;initial&amp;quot; | &amp;quot;all&amp;quot; | &amp;quot;async&amp;quot;，对哪种代码进行分割
  minSize: 30000, // 超过minSize的包才做代码分割
  minChunks: 1, // 一个包至少被用了多少次的时候才进行代码分割
  maxAsyncRequests: 5, // 按需加载最多能加载多少个模块
  maxInitialRequests: 3, // 对于entry里面的文件做代码分割最多能生成多少个js文件
  automaticNameDelimiter: &#39;~&#39;, // 文件生成时的连接符
  name: true, // 为true的时候，打包出来的文件名由cacheGroups里面设置的为准
  cacheGroups: {
    vendors: {
      test: /[\\/]node_modules[\\/]/, // 匹配哪些需要分割的模块
      priority: -10, // 优先级
     	filename: &#39;vendors.js&#39;// 打包到一个叫vendors.js的文件
    },
    default: {
      minChunks: 2,
      priority: -20,
      reuseExistingChunk: true
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.&lt;code&gt;catch-loader&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在一些性能开销较大的&lt;code&gt;loader&lt;/code&gt;之前添加此 &lt;code&gt;loader&lt;/code&gt;，以将结果缓存到磁盘里，不做过多介绍&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
  module: {
    rules: [
      {
        test: /\.ext$/,
        use: [
          &#39;cache-loader&#39;,
          ...loaders
        ],
        include: path.resolve(&#39;src&#39;)
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.&lt;code&gt;HappyPack&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HappyPack&lt;/code&gt;使用&lt;code&gt;node&lt;/code&gt;多线程进行构建来提升构建的速度，使用情况较少&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const HappyPack = require(&#39;happypack&#39;)
const os = require(&#39;os&#39;)
const happyThreadPool = HappyPack.ThreadPool({
  size: os.cpus().length
})

......
plugins: [
  new HtmlWebPackPlugin({
    template: &#39;public/index.html&#39;,
    filename: &#39;index.html&#39;,
    inject: true
  }),
  new HappyPack({
    id: &#39;happyBabel&#39;,
    loaders: [{
      loader: &#39;babel-loader?cacheDirectory=true&#39;,
    }],
    threadPool: happyThreadPool,
    verbose: true,
  })
],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.&lt;code&gt;css&lt;/code&gt;的压缩&lt;/p&gt;

&lt;p&gt;对于&lt;code&gt;scss&lt;/code&gt;文件，一般来讲，依次配置&lt;code&gt;sass-loader&lt;/code&gt;、&lt;code&gt;css-loader&lt;/code&gt;、&lt;code&gt;style-loader&lt;/code&gt;来进行处理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  test: /\.scss$/,
  use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后加载完后的页面&lt;code&gt;css&lt;/code&gt;会以内联样式的形式签入到页面中。在&lt;code&gt;webpack4&lt;/code&gt;中使用&lt;code&gt;mini-css-extract-plugin&lt;/code&gt;插件来提取、压缩&lt;code&gt;css&lt;/code&gt;。首先将&lt;code&gt;style-loade&lt;/code&gt;用&lt;code&gt;MiniCssExtractPlugin.loader&lt;/code&gt;代替，然后使用&lt;code&gt;MiniCssExtractPlugin&lt;/code&gt;插件，打包出对应的文件，并在页面中引入对应的&lt;code&gt;css&lt;/code&gt;文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;)

......

{
  test: /\.scss$/,
  use: [MiniCssExtractPlugin.loader, &#39;css-loader&#39;, &#39;sass-loader&#39;]
}

new MiniCssExtractPlugin({
  filename: &#39;[name].[hash:5].css&#39;,
  chunkFilename: &#39;[id].[hash:5].css&#39;
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.图片的处理&lt;/p&gt;

&lt;p&gt;同样的，先用&lt;code&gt;file-loader&lt;/code&gt;解析图片保证webpack能处理，然后可以用&lt;code&gt;image-webpack-loader&lt;/code&gt;压缩图片，或者说用&lt;code&gt;url-loader&lt;/code&gt;将图片转为&lt;code&gt;base64&lt;/code&gt;编码的形式，不多赘述&lt;/p&gt;

&lt;p&gt;8.CDN加速
通常在打包中，把不变的一些静态文件放到&lt;code&gt;CDN&lt;/code&gt;上，可以直观地减小资源包大小，比如项目中用到了&lt;code&gt;clipboard.js&lt;/code&gt;，然后在模板&lt;code&gt;html&lt;/code&gt;中引入这个文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;script src=&amp;quot;https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.6/clipboard.min.js&amp;quot; defer&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般来讲，这种方式引入js静态文件，那么全局对象(如window)里面是会有对应的对象的，就可以直接引用对应的对象。当然还可以加上&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;externals: {
  clipboard: &#39;clipboard&#39;
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就保证了打包时不打包&lt;code&gt;clipboard&lt;/code&gt;，优化打包后的文件体积&lt;/p&gt;

&lt;p&gt;还有一种方式就是把所有的静态资源，如&lt;code&gt;js&lt;/code&gt;、&lt;code&gt;css&lt;/code&gt;都放在相应的&lt;code&gt;CDN&lt;/code&gt;上，在打包的&lt;code&gt;config&lt;/code&gt;中指定对应资源的&lt;code&gt;CDN&lt;/code&gt;域名，同样配置&lt;code&gt;externals&lt;/code&gt;。但其实这种方式有个很大的缺点就是，如果全部这样做的话，万一&lt;code&gt;CDN&lt;/code&gt;挂了，整个页面也就挂了&lt;/p&gt;

&lt;p&gt;9.按需加载&lt;/p&gt;

&lt;p&gt;以&lt;code&gt;react&lt;/code&gt;为例，使用&lt;code&gt;react-loadable&lt;/code&gt;来做按需加载，以前还有些其它方法这里就不赘述。主要是针对&lt;code&gt;react-router&lt;/code&gt;做一个处理，首先安装依赖&lt;code&gt;react-loadable&lt;/code&gt;，入口文件中封装一个&lt;code&gt;loading&lt;/code&gt;组件，用于页面加载时给一个提示，然后封装一个方法，用于异步加载这些组件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import Loadable from &#39;react-loadable&#39;
const Loading = (props) =&amp;gt; {
  return &amp;lt;div&amp;gt;这是一个loading组件&amp;lt;/div&amp;gt;
};
const asyncLoad = loader =&amp;gt; Loadable({
  loader,
  loading: Loading
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下有三个页面，&lt;code&gt;index&lt;/code&gt;、&lt;code&gt;about&lt;/code&gt;、&lt;code&gt;user&lt;/code&gt;，调用&lt;code&gt;asyncLoad&lt;/code&gt;，引入这些文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const Index = asyncLoad(() =&amp;gt; import(&#39;./pages/index&#39;))
const About = asyncLoad(() =&amp;gt; import(&#39;./pages/about&#39;))
const User = asyncLoad(() =&amp;gt; import(&#39;./pages/user&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再配置好路由，这样打包出来的&lt;code&gt;js&lt;/code&gt;文件就只会在对应页面或者说对应路由命中时加载了，从而提升页面的一个加载速度，当然也把打包出来的js文件进一步的分割，减小体积，当然需要注意的是，要在&lt;code&gt;webpack.config&lt;/code&gt;里面配置好&lt;code&gt;chunFilename(按需加载的chunk名字)&lt;/code&gt;，资源的&lt;code&gt;publickPath&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;Router&amp;gt;
  &amp;lt;Switch&amp;gt;
  	&amp;lt;Route path=&amp;quot;/&amp;quot; exact component={Index} /&amp;gt;
    &amp;lt;Route path=&amp;quot;/about/&amp;quot; component={About} /&amp;gt;
    &amp;lt;Route path=&amp;quot;/users/&amp;quot; component={User} /&amp;gt;
  &amp;lt;/Switch&amp;gt;
&amp;lt;/Router&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;webpack.config.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;output: {
  path: path.resolve(__dirname, &#39;./dist/&#39;),
  filename: &#39;[name].[hash:5].bundle.js&#39;,
  chunkFilename: &#39;[name].[hash:5].bundle.js&#39;,
  publicPath: &#39;/&#39;
},
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Webpack理解</title>
      <link>https://xtid.github.io/2020/webpack%E7%90%86%E8%A7%A3/</link>
      <pubDate>Sun, 23 Aug 2020 21:36:20 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/webpack%E7%90%86%E8%A7%A3/</guid>
      <description>&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt;是一个模块打包器，老一点的还有&lt;code&gt;gulp&lt;/code&gt;、&lt;code&gt;grunt&lt;/code&gt;等等，
他最显著的特点就是将文件视为一个个模块，通过设置入口文件&lt;code&gt;entry&lt;/code&gt;，加载不同类型的文件用不同&lt;code&gt;loader&lt;/code&gt;转换文件，
然后使用不同&lt;code&gt;plugin&lt;/code&gt;对文件处理，最后输出多个打包、分割后的文件&lt;/p&gt;

&lt;p&gt;首先有几个概念
1.entry：即&lt;code&gt;webpack&lt;/code&gt;打包的入口，告诉它应该从那个文件开始进行构建
2.output：设置打包后文件的输出路径以及如何命名这些文件
3.loader：处理那些非&lt;code&gt;javaScript&lt;/code&gt;文件，通过指定对应文件所需的对应&lt;code&gt;loader&lt;/code&gt;的处理，将文件转换为&lt;code&gt;webpack&lt;/code&gt;能够处理的有效模块
4.plugins：转换某些类型的模块，功能强大，可以做到打包优化，压缩以及各种各样的其它任务&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bundle&lt;/code&gt;：视为&lt;code&gt;webpack&lt;/code&gt;打包提取的模块生成的&lt;code&gt;js&lt;/code&gt;文件，将其它具体模块的代码传入其中执行，原本独立的模块文件，通过调用&lt;code&gt;__webpack_require__&lt;/code&gt;，合并到了&lt;code&gt;bundle&lt;/code&gt;中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function(modules) {
/******/    var installedModules = {};
/******/
/******/    var installedChunks = {
/******/        2: 0
/******/    };
/******/
/******/    function __webpack_require__(moduleId) {
/******/
/******/        if(installedModules[moduleId]) {
/******/            return installedModules[moduleId].exports;
/******/        }
/******/        var module = installedModules[moduleId] = {
/******/            i: moduleId,
/******/            l: false,
/******/            exports: {}
/******/        };
/******/
/******/        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/        module.l = true;
/******/
/******/        return module.exports;
/******/    }
/******/ })
/************************************************************************/
/******/ ({
	// 传入的模块
	......
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打包后的&lt;code&gt;bundle&lt;/code&gt;是一个立即执行的匿名函数，其参数就是打包后的模块，上面&lt;code&gt;__webpack_require__&lt;/code&gt;方法会首先判断当前模块&lt;code&gt;moduleId&lt;/code&gt;是否已经存在缓存&lt;code&gt;installedModules&lt;/code&gt;中，若是存在则直接返回。若是不存在，则会构造一个对象并将其同时存到&lt;code&gt;installedModules&lt;/code&gt;中和&lt;code&gt;module&lt;/code&gt;中&lt;/p&gt;

&lt;p&gt;&lt;code&gt;modules[moduleId].call(module.exports, module, module.exports, __webpack_require__)&lt;/code&gt;
这段代码首先执行当前模块的具体代码，传入&lt;code&gt;module&lt;/code&gt;，&lt;code&gt;module.exports&lt;/code&gt;，&lt;code&gt;__webpack_require__&lt;/code&gt;，递归调用&lt;code&gt;__webpack_require__&lt;/code&gt;处理每个模块种引入的其它模块
如以下形式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/***/ 0:
/***/ (function(module, exports, __webpack_require__) {
	......
	__webpack_require__(1);
	module.exports = __webpack_require__(2);
	......

/***/ })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个简单的bundle构建过程：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 引入相关依赖，对文件进行编译转换输出处理
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);
const parse = require(&#39;@babel/parser&#39;);
const traverse = require(&#39;@babel/traverse&#39;).default;
const babel = require(&#39;@babel/core&#39;);


let ID = 0;
// 读取文件信息，并获得当前js文件的依赖关系
function createAsset(filename) {
  // 获取文件，返回值是字符串
  const content = fs.readFileSync(filename, &#39;utf-8&#39;);

  // 将字符串转为ast
  const ast = parse.parse(content, {
    sourceType: &#39;module&#39;
  });

  //用来存储 文件所依赖的模块，简单来说就是，当前js文件 import 了哪些文件，都会保存在这个数组里
  const dependencies = [];

  //遍历当前ast（抽象语法树）
  traverse(ast, {
    //找到有 import语法 的对应节点
    ImportDeclaration: ({ node }) =&amp;gt; {
      //把当前依赖的模块加入到数组中
      dependencies.push(node.source.value);
    }
  });

  //模块的id 从0开始， 相当一个js文件 可以看成一个模块
  const id = ID++;

  //这边主要把ES6 的代码转成 ES5
  const { code } = babel.transformFromAstSync(ast, null, {
    presets: [&#39;@babel/preset-env&#39;]
  });

  return {
    id,
    filename,
    dependencies,
    code
  };
}

// 从入口开始分析所有依赖项，形成依赖图，采用广度遍历
function createGraph(entry) {
  const mainAsset = createAsset(entry);
    
  const queue = [mainAsset];

  for (const asset of queue) {
    const dirname = path.dirname(asset.filename);
    // 新增一个属性来保存子依赖项的数据
    asset.mapping = {};
    asset.dependencies.forEach(relativePath =&amp;gt; {
      const absolutePath = path.join(dirname, relativePath);
      //获得子依赖（子模块）的依赖项、代码、模块id，文件名
      const child = createAsset(absolutePath);
      //给子依赖项赋值，
      asset.mapping[relativePath] = child.id;
      //将子依赖也加入队列中，广度遍历
      queue.push(child);
    });
  }
  return queue;
}

//根据生成的依赖关系图，生成对应环境能执行的代码，目前是生产浏览器可以执行的
function bundle(graph) {
  let modules = &#39;&#39;;

  //循环依赖关系，并把每个模块中的代码存在function作用域里
  graph.forEach(mod =&amp;gt; {
    modules += `${mod.id}:[
      function (require, module, exports){
        ${mod.code}
      },
      ${JSON.stringify(mod.mapping)},
    ],`;
  });

  //require, module, exports 是 cjs的标准不能再浏览器中直接使用，所以这里模拟cjs模块加载，执行，导出操作。
  const result = `
    (function(modules){
      //创建require函数， 它接受一个模块ID（这个模块id是数字0，1，2） ，它会在我们上面定义 modules 中找到对应是模块.
      function __webpack_require__(id){
        const [fn, mapping] = modules[id];
        function localRequire(relativePath){
          //根据模块的路径在mapping中找到对应的模块id
          return __webpack_require__(mapping[relativePath]);
        }
        const module = {exports:{}};
        //执行每个模块的代码。
        fn(localRequire,module,module.exports);
        return module.exports;
      }
      //执行入口文件，
      __webpack_require__(0);
    })({${modules}})
  `;

  return result;
}

// 入口文件
const graph = createGraph(&#39;./entry.js&#39;);
// 文件内容
const ret = bundle(graph);

// 打包生成文件
fs.writeFileSync(&#39;./bundle.js&#39;, ret);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;loader&lt;/code&gt;，通过设置对应的&lt;code&gt;rule&lt;/code&gt;，使用不同的&lt;code&gt;loader&lt;/code&gt;来转换、处理不同的组件，比如&lt;code&gt;css&lt;/code&gt;文件使用&lt;code&gt;css-loader&lt;/code&gt;以及&lt;code&gt;style-loader&lt;/code&gt;来处理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  test: /\.css$/,
  loader: &#39;style-loader!css-loader&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外，还有一种内联&lt;code&gt;loader&lt;/code&gt;的形式，即&lt;code&gt;import loader from &#39;......&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;两种方式处理的顺序也不同，大致流程为
1.&lt;code&gt;webpack&lt;/code&gt;启动后，创建新的&lt;code&gt;compilation&lt;/code&gt;
2.实例化&lt;code&gt;rules&lt;/code&gt;
3.解析&lt;code&gt;inline loaders&lt;/code&gt;
4.解析&lt;code&gt;config&lt;/code&gt;配置里面的&lt;code&gt;loaders&lt;/code&gt;
5.组合这两种形式的&lt;code&gt;loader&lt;/code&gt;，最终输出上诉第一种形式的配置
6.使用&lt;code&gt;Loader-runner&lt;/code&gt;按配置执行&lt;code&gt;loader&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以下简单写一个&lt;code&gt;loader&lt;/code&gt;，首先写一个方法用于加载&lt;code&gt;loader&lt;/code&gt;，并处理传入的模块，然后返回处理完了之后的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let source = ...... // source为获取到的模块的代码
function loaderModule(loaderName) {
  // 获取loader路径
  const loaderPath = path.join(process.cwd(), loaderName)
  const loader = require(loaderPath)
  source = loader.call(_this, source)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义一个规则&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;rules: [{
  test:/\.js/,
  use:[
    &#39;./loaderModule.js&#39;, // loader的路径
  ]
}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行的时候遍历&lt;code&gt;rules&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;for (let i = rules.length - 1; i &amp;gt;= 0; i--) {
  const { test, use } = rules[i]
  if (test.test(modulePath)) {
    // 使用多个loader
    if (Array.isArray(use)) {
      for (let j = use.length - 1; j &amp;gt;= 0; j--) {
        loaderModule(use[j])
      }
    } else if (typeof use === &#39;string&#39;) {
      loaderModule(use)
      // 带参数型的loader
    } else if (use instanceof Object) {
      loaderModule(use.loader, {
        query: use.options
      })
    }
  }
}

// loaderModule.js内容
// loader-utils是webpack一个工具类，用于解析loader，获取配置的一些loader参数
const loaderUtils = require(&#39;loader-utils&#39;)

// 这个简单的loader会将js文件里面的hello字符串替换成word
module.exports = function (source) {
  const optionsName = loaderUtils.getOptions(this) &amp;amp;&amp;amp; loaderUtils.getOptions(this).name || &#39;world&#39;
  return source.replace(/hello/g, optionsName)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面是一个同步的&lt;code&gt;loader&lt;/code&gt;，如果想写一个异步的&lt;code&gt;loader&lt;/code&gt;，可以在&lt;code&gt;loader&lt;/code&gt;内部调用&lt;code&gt;async&lt;/code&gt;方法，然后在处理之后调用对应的回调方法处理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = function (source) {
  const optionsName = loaderUtils.getOptions(this) &amp;amp;&amp;amp; loaderUtils.getOptions(this).name || &#39;world&#39;
  cosnt callback = this.async()

  // 操作完了之后，调用callback返回结果进入下一个loader
  asyncOperation(source, optionsName, function(err, result) {
    if（err）return callback(err)
    callback(err, result)
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不用上面的方式，返回一个&lt;code&gt;promise&lt;/code&gt;也是可以的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = function (source) {
  const optionsName = loaderUtils.getOptions(this) &amp;amp;&amp;amp; loaderUtils.getOptions(this).name || &#39;world&#39;
  return new Promise(resolve =&amp;gt; {
    asyncOperation(source, function(err, result) {
      if (err) resolve(err)
      resolve(err, result)
    })
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;plugin&lt;/code&gt;
&lt;code&gt;plugin&lt;/code&gt;进一步拓展了&lt;code&gt;webpack&lt;/code&gt;的功能，比如打包优化和压缩，清空当前项目的目录，重新定义环境变量，将代码输出到某个文件，提取功能模块等等&lt;/p&gt;

&lt;p&gt;定义一个&lt;code&gt;plugin&lt;/code&gt;的时候，首先要提供一个&lt;code&gt;apply&lt;/code&gt;方法，接受一个&lt;code&gt;compiler&lt;/code&gt;对象，然后注册对应的钩子函数，在回调里面拿到对应参数，然后处理
以下定义一个&lt;code&gt;plugin&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const path = require(&#39;path&#39;)
const fs = require(&#39;fs&#39;)
const cheerio = require(&#39;cheerio&#39;)

class BasePlugin {
  constructor(options){
    // 插件的参数，filename、template等
    this.options = options
  }
  apply(compiler) {
    // 注册afterEmit钩子函数
    compiler.hooks.afterEmit.tap(&#39;BasePlugin&#39;, (compilation) =&amp;gt; {
      // 2. 根据模板读取html文件内容
      const result = fs.readFileSync(this.options.template, &#39;utf-8&#39;)
      
      // 3. 使用 cheerio 来分析 HTML
      let $ = cheerio.load(result)
    
      // 4. 创建 script 标签后插入HTML中
      // compilation.assets代表所有输出的资源文件
      Object.keys(compilation.assets).forEach(item =&amp;gt; {
        $(`&amp;lt;script src=&amp;quot;/${item}&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;`).appendTo(&#39;body&#39;)
      })
    
      // 5. 转换成新的HTML并写入到 dist 目录中
      fs.writeFileSync(path.join(process.cwd(), &#39;dist&#39;, this.options.filename), $.html())
    })
  } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;compiler&lt;/code&gt;对象包含了&lt;code&gt;webpack&lt;/code&gt;环境所有的的配置信息，包含&lt;code&gt;options&lt;/code&gt;，&lt;code&gt;loaders&lt;/code&gt;，&lt;code&gt;plugins&lt;/code&gt;这些信息，这个对象在&lt;code&gt;webpack&lt;/code&gt;启动时候被实例化，它是全局唯一的，可以简单地把它理解为&lt;code&gt;webpack&lt;/code&gt;实例，&lt;code&gt;compilation&lt;/code&gt;对象包含了当前的模块资源、编译生成资源、变化的文件等。当&lt;code&gt;webpack&lt;/code&gt;以开发模式运行时，每当检测到一个文件变化，&lt;code&gt;compilation&lt;/code&gt;就会被重新构建，其它的一些&lt;a href=&#34;https://www.webpackjs.com/api/compiler-hooks/#hooks&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;钩子函数&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;顺便总结一下，实现一个简单的&lt;code&gt;webpack&lt;/code&gt;的步骤
1.定一个基础对象，构造方法里面传入&lt;code&gt;entry&lt;/code&gt;、&lt;code&gt;output&lt;/code&gt;、&lt;code&gt;rules&lt;/code&gt;、&lt;code&gt;plugins&lt;/code&gt;等属性
2.然后定义一系列钩子函数，在&lt;code&gt;webpack&lt;/code&gt;执行中可以调用这些钩子函数做处理，
3.开始执行，初始化对应的钩子函数，传入&lt;code&gt;entry&lt;/code&gt;等相关信息
4.拿到文件源码信息，使用&lt;code&gt;loader&lt;/code&gt;处理，将代码转换成&lt;code&gt;ast&lt;/code&gt;形式
5.&lt;code&gt;traverse&lt;/code&gt;将&lt;code&gt;ast&lt;/code&gt;代码中的&lt;code&gt;require&lt;/code&gt;替换为&lt;code&gt;__webpack_require__&lt;/code&gt;，添加新的&lt;code&gt;module&lt;/code&gt;信息
6.递归处理每一个依赖，重复上面的步骤
7.初始化&lt;code&gt;plugin&lt;/code&gt;，并对文件做处理
8.输入到指定目录
9.客户端/浏览器运行时执行&lt;/p&gt;

&lt;p&gt;参考链接&lt;/p&gt;

&lt;p&gt;1.&lt;a href=&#34;https://juejin.im/post/6844903957769224206&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;webpack原理&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&#34;https://www.webpackjs.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;webpack官方文档&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Babel简介</title>
      <link>https://xtid.github.io/2020/babel%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sun, 23 Aug 2020 21:32:52 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/babel%E7%AE%80%E4%BB%8B/</guid>
      <description>

&lt;h3 id=&#34;1-babel-简介&#34;&gt;1.babel 简介&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Babel是现代JavaScript语法转换器，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中，包括不限于: eslint jsx vue-template等等。他能为你做的：语法转换、通过 Polyfill 方式在目标环境中添加缺失的特性、源码转换。可以说，通过babel，我们可以使用最新的语法或者特性专注的开发业务，而不用将精力花在代码的兼容上&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;2-babel的解析流程&#34;&gt;2.babel的解析流程&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/xtid/blog/blob/master/static/img/deal_process.png&#34; alt=&#34;babel处理流程&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-1词法解析&#34;&gt;2.1词法解析&lt;/h4&gt;

&lt;p&gt;首先由入口文件&lt;code&gt;@babel/core&lt;/code&gt;引入各种配置文件以及解析的模块，其中负责解析基本语法的为&lt;code&gt;parse&lt;/code&gt;模块，其中就定义了&lt;code&gt;词法解析器Tokenizer&lt;/code&gt;，可以看出初始化时会有一个&lt;code&gt;tokens&lt;/code&gt;数组，在这个阶段会把字符串形式的代码转换为一个数组，&lt;code&gt;tokens可以视为由拆分为各个片段组成的数组&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Tokenizer extends LocationParser {
  constructor(options, input) {
    super();
    this.tokens = [];
    this.state = new State();
    this.state.init(options);
    this.input = input;
    this.length = input.length;
    this.isLookahead = false;
  }
	
  ....
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;Tokenizer&lt;/code&gt;定义中还有一些其它的方法，他们会对各种语法字符串进行一个遍历过滤，比如跳过空格字符串，比如跳过注释等等&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;skipSpace() {
  loop: while (this.state.pos &amp;lt; this.length) {
    const ch = this.input.charCodeAt(this.state.pos);
    .
    .
    .
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后会把符合规则的语法字符串加入到&lt;code&gt;tokens&lt;/code&gt;数组中，也就生成代码拆分为各个片段组成的数组&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;pushToken(token) {
  this.tokens.length = this.state.tokensLength;
  this.tokens.push(token);
  ++this.state.tokensLength;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.log(&#39;我是一段语法&#39;) =&amp;gt; [&#39;console&#39;, &#39;log&#39;, &#39;(&#39;, &#39;&amp;quot;我是一段语法&amp;quot;&#39;, &#39;)&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-2语法解析&#34;&gt;2.2语法解析&lt;/h4&gt;

&lt;p&gt;当生成完&lt;code&gt;tokens&lt;/code&gt;，则进入到语法解析阶段，同样可以看见在&lt;code&gt;parse&lt;/code&gt;模块中定一个了一个&lt;code&gt;Node&lt;/code&gt;对象，这个对象定义了一些属性，当然还有个私有的&lt;code&gt;_clone&lt;/code&gt;方法，用于表示将要生成的&lt;code&gt;AST&lt;/code&gt;中节点的位置、名称、类型等等信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Node {
  constructor(parser, pos, loc) {
    this.type = &amp;quot;&amp;quot;;
    this.start = pos;
    this.end = 0;
    this.loc = new SourceLocation(loc);
    if (parser &amp;amp;&amp;amp; parser.options.ranges) this.range = [pos, 0];
    if (parser &amp;amp;&amp;amp; parser.filename) this.loc.filename = parser.filename;
  }

  __clone() {
    .
    .
    .
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后会定义相应的&lt;code&gt;Parse&lt;/code&gt;，遍历处理不同的&lt;code&gt;tokens&lt;/code&gt;字段，比如&lt;code&gt;ImportDeclaration&lt;/code&gt;用于import语法，导入模块；&lt;code&gt;VariableDeclarator&lt;/code&gt;用于处理表示是什么类型的变量声明，比如&lt;code&gt;var、let、const&lt;/code&gt;；&lt;code&gt;FunctionDeclaration&lt;/code&gt;用于处理函数声明，非函数表达式，其它的就不多赘述。最后则会将这个词法数组转换为&lt;code&gt;AST(抽象语法树)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var add = function(a, b) {
  return  a + b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后生成的&lt;code&gt;AST&lt;/code&gt;简易版本如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  &amp;quot;type&amp;quot;: &amp;quot;Program&amp;quot;,
  &amp;quot;body&amp;quot;: [{
    &amp;quot;type&amp;quot;: &amp;quot;VariableDeclaration&amp;quot;,
    &amp;quot;identifierName&amp;quot;: &amp;quot;add&amp;quot;,
    &amp;quot;init&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;ArrowFunctionExpression&amp;quot;,
      &amp;quot;params&amp;quot;: [{
          &amp;quot;type&amp;quot;: &amp;quot;identifier&amp;quot;,
          &amp;quot;identifierName&amp;quot;: &amp;quot;a&amp;quot;
        },
        {
          &amp;quot;type&amp;quot;: &amp;quot;identifier&amp;quot;,
          &amp;quot;identifierName&amp;quot;: &amp;quot;b&amp;quot;
        }
      ],
      &amp;quot;body&amp;quot;: {
        &amp;quot;type&amp;quot;: &amp;quot;BinaryExpression&amp;quot;,
        &amp;quot;left&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;identifier&amp;quot;,
          &amp;quot;identifierName&amp;quot;: &amp;quot;a&amp;quot;
        },
        &amp;quot;operator&amp;quot;: &amp;quot;+&amp;quot;,
        &amp;quot;right&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;identifier&amp;quot;,
          &amp;quot;identifierName&amp;quot;: &amp;quot;b&amp;quot;
        }
      }
    }
  }]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出这个语法树包含了整个语法的一个层级关系，并且标注了他们的名称、类型以及位置&lt;/p&gt;

&lt;h4 id=&#34;2-3traverser&#34;&gt;2.3Traverser&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Traverser&lt;/code&gt;会对生成好&lt;code&gt;AST&lt;/code&gt;进行一个遍历，在此过程中对节点进行添加、删除等等操作，这也是其他插件将要处理的地方，通过这些插件，也可以处理不同的&lt;code&gt;AST&lt;/code&gt;语法树，然后转换符合相应规则的代码，比如&lt;code&gt;Taro&lt;/code&gt;，就可以视为将&lt;code&gt;React&lt;/code&gt;代码转换成小程序对应代码的一个插件。&lt;code&gt;Traverser&lt;/code&gt;中会引入&lt;code&gt;visitors&lt;/code&gt;，用它来进行一个深度遍历操作；&lt;code&gt;Path&lt;/code&gt;用于关联各个节点，这样使得节点操作简单，例如：&lt;/p&gt;

&lt;p&gt;例如，如果有下面这样一个节点及其子节点︰&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  type: &amp;quot;ArrowFunctionExpression&amp;quot;,
  id: {
    type: &amp;quot;Identifier&amp;quot;,
    name: &amp;quot;a&amp;quot;
  },
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将子节点 &lt;code&gt;Identifier&lt;/code&gt; 表示为一个路径（Path）的话，看起来是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  &amp;quot;parent&amp;quot;: {
    &amp;quot;type&amp;quot;: &amp;quot;ArrowFunctionExpression&amp;quot;,
    &amp;quot;id&amp;quot;: {...},
    ....
  },
  &amp;quot;node&amp;quot;: {
    &amp;quot;type&amp;quot;: &amp;quot;Identifier&amp;quot;,
    &amp;quot;name&amp;quot;: &amp;quot;a&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Scope&lt;/code&gt;用来表示树中各个节点的一个作用域关系，就好像&lt;code&gt;js&lt;/code&gt;语法中，创建变量、函数时所呈现的一个作用域效果，在&lt;code&gt;babel&lt;/code&gt;中，新添加的引用或者变量名，&lt;code&gt;Scope&lt;/code&gt;表示的时候需要体现出节点的路径，节点间的关系，如以下形式:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  path: path,
  block: path.node,
  parentBlock: path.parent,
  parent: parentScope,
  bindings: [...]
  .
  .
  .
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有个很重要的概念&lt;code&gt;Bindings&lt;/code&gt;，&lt;code&gt;Bindings&lt;/code&gt;可以获取当前作用域下所有的标识符，其返回的信息包括节点的&lt;code&gt;标识符&lt;/code&gt;、&lt;code&gt;scope&lt;/code&gt;、&lt;code&gt;path&lt;/code&gt;、&lt;code&gt;引用&lt;/code&gt;等等信息，通过对这些属性的操作，达到对节点信息的一个更改&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export class Binding {
  identifier: t.Identifier;
  scope: Scope;
  path: NodePath;
  kind: &amp;quot;var&amp;quot; | &amp;quot;let&amp;quot; | &amp;quot;const&amp;quot; | &amp;quot;module&amp;quot;;
  referenced: boolean;
  references: number;              // 被引用的数量
  referencePaths: NodePath[];      // 获取所有应用该标识符的节点路径
  constant: boolean;               // 是否是常量
  constantViolations: NodePath[];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-4transform&#34;&gt;2.4Transform&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;transform&lt;/code&gt;会对抽象语法树进行又一次遍历，针对已经处理好的&lt;code&gt;AST&lt;/code&gt;做进一步处理，如对代码的更改，对节点的操作、节点的增删改查、压缩代码、删除注释等等。得到最终的一个&lt;code&gt;AST&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-5生成代码&#34;&gt;2.5生成代码&lt;/h4&gt;

&lt;p&gt;得到上一步生成的&lt;code&gt;AST&lt;/code&gt;之后，会调用对应的代码生成器代码，通过递归遍历生成最终的代码，其中遇到不同的节点类型时，会做不同的处理，比如函数类型、参数定义类型、代码块类型等等&lt;/p&gt;

&lt;h3 id=&#34;3-babel里面的一些依赖包&#34;&gt;3.babel里面的一些依赖包&lt;/h3&gt;

&lt;h4 id=&#34;3-1-babel-core&#34;&gt;3.1@babel/core&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;@babel/core&lt;/code&gt;整个&lt;code&gt;babel&lt;/code&gt;的一个核心，也算是&lt;code&gt;babel&lt;/code&gt;的一个入口，它会加载和处理用户定义的配置，加载各种各样的插件；调用&lt;code&gt;Parser&lt;/code&gt;进行语法解析，生成&lt;code&gt;Tokens&lt;/code&gt;以及&lt;code&gt;AST&lt;/code&gt;；调用&lt;code&gt;Traverser&lt;/code&gt;遍历&lt;code&gt;AST&lt;/code&gt;，进行一个转换；最后&lt;code&gt;generator&lt;/code&gt;生成源代码&lt;/p&gt;

&lt;h4 id=&#34;3-2插件&#34;&gt;3.2插件&lt;/h4&gt;

&lt;p&gt;语法插件：&lt;code&gt;babel&lt;/code&gt;有很多语法插件，用于支持&lt;code&gt;JavaScript&lt;/code&gt;的各种语法特性，在解析的时候会用的到，通常其形式为&lt;code&gt;@babel/plugin-syntax-*&lt;/code&gt;，比如&lt;code&gt;babel-plugin-syntax-dynamic-import&lt;/code&gt;就是用来处理&lt;code&gt;import&lt;/code&gt;语法的一个插件&lt;/p&gt;

&lt;p&gt;转换插件： 用于对 &lt;code&gt;AST&lt;/code&gt; 进行转换, 实现转换为&lt;code&gt;ES5&lt;/code&gt;代码、压缩、功能增强等目的，&lt;code&gt;babel&lt;/code&gt;仓库将转换插件划分为两种(只是命名上的区别)：&lt;/p&gt;

&lt;p&gt;如&lt;code&gt;@babel/plugin-transform-*&lt;/code&gt;： &lt;code&gt;babel&lt;/code&gt;中的一个转换插件&lt;/p&gt;

&lt;p&gt;预定义的插件：插件集合或者分组，可设置项目内所用插件的使用场景，主要方便用户对插件进行管理和使用。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@babel/preset-env&lt;/code&gt;：&lt;code&gt;preset-env&lt;/code&gt;是ES语法插件的合集，在根目录下创建&lt;code&gt;.babelrc&lt;/code&gt;配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt; {
   &amp;quot;presets&amp;quot;: [
     [&amp;quot;@babel/preset-env&amp;quot;, {
       &amp;quot;modules&amp;quot;: false,
       &amp;quot;targets&amp;quot;: {
         &amp;quot;browsers&amp;quot;: [&amp;quot;&amp;gt; 1%&amp;quot;, &amp;quot;last 2 versions&amp;quot;, &amp;quot;not ie &amp;lt;= 8&amp;quot;]
       },
       &amp;quot;useBuiltIns&amp;quot;: false,
       &amp;quot;corejs&amp;quot;: false
     }]
   ]
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;targets&lt;/code&gt;生成指定环境的代码，&lt;code&gt;useBuiltIns&lt;/code&gt;配合&lt;code&gt;@babel/polyfill&lt;/code&gt;使用，当然最新版的&lt;code&gt;babel&lt;/code&gt;可直接使用&lt;code&gt;corejs&lt;/code&gt;，填上对应的数值就行，&lt;code&gt;modules&lt;/code&gt;表示是否将代码ES6的模块语法转换为另一种类型或标准，比如&lt;code&gt;amd&lt;/code&gt;、&lt;code&gt;commonjs&lt;/code&gt;等&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@babel/polyfill&lt;/code&gt;顾名思义，在&lt;code&gt;babel&lt;/code&gt;转化的过程中，对于一些无法处理的特性或者属性，使用&lt;code&gt;@babel/polyfill&lt;/code&gt;来对这些功能进行处理；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@babel/runtime&lt;/code&gt;一般应用于两种场景：开发类库/工具（生成不污染全局空间和内置对象原型的代码）、借助 &lt;code&gt;@babel/runtime&lt;/code&gt; 中帮助函数（helper function）移除冗余工具函数，在最新的版本中，完全可以用&lt;code&gt;@babel/runtime&lt;/code&gt;代替&lt;code&gt;@babel/polyfill&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;3-3辅助开发工具&#34;&gt;3.3辅助开发工具&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;@babel/template&lt;/code&gt;： 某些场景直接操作&lt;code&gt;AST&lt;/code&gt;太麻烦，就比如我们直接操作&lt;code&gt;DOM&lt;/code&gt;一样，所以&lt;code&gt;babel&lt;/code&gt;实现了这么一个简单的模板引擎，可以将字符串代码转换为&lt;code&gt;AST&lt;/code&gt;。比如在生成一些辅助代码&lt;code&gt;(helper)&lt;/code&gt;时会用到这个库&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@babel/types&lt;/code&gt;： 主要用途是在创建&lt;code&gt;AST&lt;/code&gt;的过程中判断各种语法的类型。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@babel/helper-*&lt;/code&gt;： 一些辅助器，用于辅助插件开发，例如简化&lt;code&gt;AST&lt;/code&gt;操作&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@babel/helper&lt;/code&gt;： 辅助代码，单纯的语法转换可能无法让代码运行起来，比如低版本浏览器无法识别&lt;code&gt;class&lt;/code&gt;关键字，这时候需要添加辅助代码，对&lt;code&gt;class&lt;/code&gt;进行模拟。&lt;/p&gt;

&lt;h4 id=&#34;4-参考链接&#34;&gt;4.参考链接&lt;/h4&gt;

&lt;p&gt;1.&lt;a href=&#34;https://juejin.im/post/5d94bfbf5188256db95589be&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;深入浅出Babel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&#34;https://www.babeljs.cn/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;babel中文网&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.&lt;a href=&#34;https://github.com/jamiebuilds/babel-handbook&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;babel-handbook&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Vue的初始化渲染过程简介</title>
      <link>https://xtid.github.io/2020/vue2.x%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 27 Jul 2020 22:25:56 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/vue2.x%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/</guid>
      <description>&lt;p&gt;首先进入到&lt;code&gt;src/core/instance/index.js&lt;/code&gt;，可以看到定义了一个&lt;code&gt;Vue&lt;/code&gt;构造函数，内容很简单，如果不是生产环境并且不是通过&lt;code&gt;new&lt;/code&gt;关键字创建对象的话，就在控制台打印一个&lt;code&gt;warn&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Vue (options) {
  if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp;
    !(this instanceof Vue)
  ) {
    warn(&#39;Vue is a constructor and should be called with the `new` keyword&#39;)
  }
  this._init(options)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后面调用了几个函数，用来在&lt;code&gt;Vue&lt;/code&gt;对象上创建各种属性或者方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;1.initMixin&lt;/h2&gt;

&lt;p&gt;初始化方法，首先为当前&lt;code&gt;vm&lt;/code&gt;设置一个&lt;code&gt;_uid&lt;/code&gt;，然后添加属性&lt;code&gt;_isVue&lt;/code&gt;，其目的在于监听数据变化时过滤&lt;code&gt;vm&lt;/code&gt;，&lt;code&gt;_isComponent&lt;/code&gt;是内部创建子组件时才会添加为&lt;code&gt;true&lt;/code&gt;的属性，然后走到&lt;code&gt;else&lt;/code&gt;分支，调用&lt;code&gt;resolveConstructorOptions&lt;/code&gt;会获取构造器父级的&lt;code&gt;options&lt;/code&gt;，然后调用&lt;code&gt;mergeOptions&lt;/code&gt;合并父级的&lt;code&gt;options&lt;/code&gt;以及本身传入的&lt;code&gt;options&lt;/code&gt;，最后生成的&lt;code&gt;options&lt;/code&gt;包含&lt;code&gt;components、directives&lt;/code&gt;等属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function initMixin (Vue: Class&amp;lt;Component&amp;gt;) {
  Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
    // a uid
    vm._uid = uid++

    let startTag, endTag
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; config.performance &amp;amp;&amp;amp; mark) {
      startTag = `vue-perf-start:${vm._uid}`
      endTag = `vue-perf-end:${vm._uid}`
      mark(startTag)
    }

    // a flag to avoid this being observed
    vm._isVue = true
    // merge options
    if (options &amp;amp;&amp;amp; options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options)
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== &#39;production&#39;) {
      initProxy(vm)
    } else {
      vm._renderProxy = vm
    }
    // expose real self
    vm._self = vm
    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    callHook(vm, &#39;beforeCreate&#39;)
    initInjections(vm) // resolve injections before data/props
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    callHook(vm, &#39;created&#39;)

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; config.performance &amp;amp;&amp;amp; mark) {
      vm._name = formatComponentName(vm, false)
      mark(endTag)
      measure(`vue ${vm._name} init`, startTag, endTag)
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt; 1.1initLifecycle &lt;/h3&gt;

&lt;p&gt;这个方法首先会设置&lt;code&gt;vm&lt;/code&gt;的一个父子节点、根节点信息，然后会定义一些生命周期相关的属性，比如&lt;code&gt;_isMounted、_isDestroyed、_isBeingDestroyed&lt;/code&gt;等&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function initLifecycle (vm: Component) {
  const options = vm.$options

  // locate first non-abstract parent
  let parent = options.parent
  if (parent &amp;amp;&amp;amp; !options.abstract) {
    while (parent.$options.abstract &amp;amp;&amp;amp; parent.$parent) {
      parent = parent.$parent
    }
    parent.$children.push(vm)
  }

  vm.$parent = parent
  vm.$root = parent ? parent.$root : vm

  vm.$children = []
  vm.$refs = {}

  vm._watcher = null
  vm._inactive = null
  vm._directInactive = false
  vm._isMounted = false
  vm._isDestroyed = false
  vm._isBeingDestroyed = false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt; 1.2initEvents &lt;/h3&gt;

&lt;p&gt;通过名字可以看出是一个初始化事件相关的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function initEvents (vm: Component) {
  // events表示父组件绑定在当前组件上的事件
  vm._events = Object.create(null)
  // 属性表示父组件是否通过&amp;quot;@hook:&amp;quot;把钩子函数绑定在当前组件上
  vm._hasHookEvent = false
  // init parent attached events
  // 同样是来表示父组件绑定在当前组件上的事件
  const listeners = vm.$options._parentListeners
  if (listeners) {
    updateComponentListeners(vm, listeners)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果&lt;code&gt;listeners&lt;/code&gt;有值，则调用&lt;code&gt;updateComponentListeners&lt;/code&gt;这个方法，其内部调用了&lt;code&gt;updateListeners&lt;/code&gt;，其中的&lt;code&gt;add&lt;/code&gt;方法会调用&lt;code&gt;vm.$on&lt;/code&gt;，&lt;code&gt;vm.$on&lt;/code&gt;会监听当前实例上的自定义事件，&lt;code&gt;remove&lt;/code&gt;会调用&lt;code&gt;vm.$off&lt;/code&gt;，移出这个事件监听&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function add (event, fn) {
  target.$on(event, fn)
}

function remove (event, fn) {
  target.$off(event, fn)
}

export function updateComponentListeners (
  vm: Component,
  listeners: Object,
  oldListeners: ?Object
) {
  // 保存当前的vm引用
  target = vm
  // 传入listeners，父组件绑定在当前组件上的事件，oldListeners同理，不过在第一次初始化的时候为空
  // 其内部会遍历listeners调用add方法添加监听事件，同时移出oldListeners
  updateListeners(listeners, oldListeners || {}, add, remove, createOnceHandler, vm)
  target = undefined
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt; 1.3initRender &lt;/h3&gt;

&lt;p&gt;主要是添加了一些虚拟dom、&lt;code&gt;slot&lt;/code&gt;等相关的属性和方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function initRender (vm: Component) {
  // 表示虚拟dom节点
  vm._vnode = null 
  // 表示当前实例render得到的Vnode
  vm._staticTrees = null 
  const options = vm.$options
  const parentVnode = vm.$vnode = options._parentVnode  tree
  const renderContext = parentVnode &amp;amp;&amp;amp; parentVnode.context
  // 生成插槽内容
  vm.$slots = resolveSlots(options._renderChildren, renderContext)
  // 作用域插槽，此时为空
  vm.$scopedSlots = emptyObject
  vm._c = (a, b, c, d) =&amp;gt; createElement(vm, a, b, c, d, false)
  vm.$createElement = (a, b, c, d) =&amp;gt; createElement(vm, a, b, c, d, true)
  const parentData = parentVnode &amp;amp;&amp;amp; parentVnode.data
	......
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;resolveSlots&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function resolveSlots (
  children: ?Array&amp;lt;VNode&amp;gt;,
  context: ?Component
): { [key: string]: Array&amp;lt;VNode&amp;gt; } {
  if (!children || !children.length) {
    return {}
  }
  const slots = {}
  // 遍历当前节点chilren
  for (let i = 0, l = children.length; i &amp;lt; l; i++) {
    const child = children[i]
    // 获取data
    const data = child.data
    if (data &amp;amp;&amp;amp; data.attrs &amp;amp;&amp;amp; data.attrs.slot) {
      delete data.attrs.slot
    }
    if ((child.context === context || child.fnContext === context) &amp;amp;&amp;amp;
      data &amp;amp;&amp;amp; data.slot != null
    ) {
      // 拿到插槽名称
      const name = data.slot
      const slot = (slots[name] || (slots[name] = []))
      if (child.tag === &#39;template&#39;) {
        slot.push.apply(slot, child.children || [])
      } else {
        slot.push(child)
      }
    } else {
      // 如果 data.slot 不存在，则是默认插槽的内容，则把对应的 child 添加到 slots.defaults 中
      (slots.default || (slots.default = [])).push(child)
    }
  }
  // 最后过滤一些空内容
  for (const name in slots) {
    if (slots[name].every(isWhitespace)) {
      delete slots[name]
    }
  }
  return slots
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用钩子函数&lt;code&gt;beforeCreate&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt; 1.4initProvide和initInjection &lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === &#39;function&#39;
      ? provide.call(vm)
    : provide;
  }
}
function initInjections (vm) {
  // 获取当前节点上的inject属性
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    toggleObserving(false);
    // 遍历这些属性，defineReactive，将这些属性变成响应式的
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      {
        defineReactive$$1(vm, key, result[key], function () {
          warn(
            &amp;quot;Avoid mutating an injected value directly since the changes will be &amp;quot; +
            &amp;quot;overwritten whenever the provided component re-renders. &amp;quot; +
            &amp;quot;injection being mutated: \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot;&amp;quot;,
            vm
          );
        });
      }
    });
    toggleObserving(true);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt; 1.5initState &lt;/h3&gt;

&lt;p&gt;主要是初始化一些数据和属性，比如&lt;code&gt;props&lt;/code&gt;、&lt;code&gt;methods&lt;/code&gt;、&lt;code&gt;data&lt;/code&gt;、&lt;code&gt;computed&lt;/code&gt;、&lt;code&gt;watch&lt;/code&gt;,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch &amp;amp;&amp;amp; opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化&lt;code&gt;props&lt;/code&gt;属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function initProps (vm, propsOptions) {
  // 获取当前节点的props属性值
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  var isRoot = !vm.$parent;
  // 用于保存当前组件的props里的key，以便之后在父组件更新props时可以直接使用数组迭代
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  if (!isRoot) {
    toggleObserving(false);
  }
  var loop = function ( key ) {
    keys.push(key);
    // validateProp验证当前prop[key]是否propsOptions定义的要求
    var value = validateProp(key, propsOptions, propsData, vm);
    {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          (&amp;quot;\&amp;quot;&amp;quot; + hyphenatedKey + &amp;quot;\&amp;quot; is a reserved attribute and cannot be used as component prop.&amp;quot;),
          vm
        );
      }
      // 添加响应式属性，这样props里面的值改变之后，组件会自动更新视图
      defineReactive$$1(props, key, value, function () {
        if (!isRoot &amp;amp;&amp;amp; !isUpdatingChildComponent) {
          warn(
            &amp;quot;Avoid mutating a prop directly since the value will be &amp;quot; +
            &amp;quot;overwritten whenever the parent component re-renders. &amp;quot; +
            &amp;quot;Instead, use a data or computed property based on the prop&#39;s &amp;quot; +
            &amp;quot;value. Prop being mutated: \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot;&amp;quot;,
            vm
          );
        }
      });
    }
    // static props are already proxied on the component&#39;s prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, &amp;quot;_props&amp;quot;, key);
    }
  };
	// 循环遍历key
  for (var key in propsOptions) loop( key );
  toggleObserving(true);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化&lt;code&gt;methods&lt;/code&gt;属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function initMethods (vm, methods) {
  // props属性用于判断methods中的方法名是否和props的属性重名
  var props = vm.$options.props;
  for (var key in methods) {
    {
      if (typeof methods[key] !== &#39;function&#39;) {
        warn(
          &amp;quot;Method \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot; has type \&amp;quot;&amp;quot; + (typeof methods[key]) + &amp;quot;\&amp;quot; in the component definition. &amp;quot; +
          &amp;quot;Did you reference the function correctly?&amp;quot;,
          vm
        );
      }
      // 如果props中有同名属性，则报错
      if (props &amp;amp;&amp;amp; hasOwn(props, key)) {
        warn(
          (&amp;quot;Method \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot; has already been defined as a prop.&amp;quot;),
          vm
        );
      }
      // 如果key是以$或_开头则，也报错
      if ((key in vm) &amp;amp;&amp;amp; isReserved(key)) {
        warn(
          &amp;quot;Method \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot; conflicts with an existing Vue instance method. &amp;quot; +
          &amp;quot;Avoid defining component methods that start with _ or $.&amp;quot;
        );
      }
    }
    vm[key] = typeof methods[key] !== &#39;function&#39; ? noop : bind(methods[key], vm);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化&lt;code&gt;data&lt;/code&gt;属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function initData (vm) {
  // 获取data属性
  var data = vm.$options.data;
  // 如果data是一个function，则调用getData返回里面的值，否则直接将data属性赋给_data
  data = vm._data = typeof data === &#39;function&#39;
    ? getData(data, vm)
  : data || {};
  // 如果data属性不是一个对象，设置data为空对象，并打印一个warn
  if (!isPlainObject(data)) {
    data = {};
    warn(
      &#39;data functions should return an object:\n&#39; +
      &#39;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#39;,
      vm
    );
  }
  // 获取data keys，props属性，methods属性
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    {
      // 当前data的key如果和methods中的方法重名，抛出警告
      if (methods &amp;amp;&amp;amp; hasOwn(methods, key)) {
        warn(
          (&amp;quot;Method \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot; has already been defined as a data property.&amp;quot;),
          vm
        );
      }
    }
    // 当前data的key如果和props中的属性重名，抛出警告
    if (props &amp;amp;&amp;amp; hasOwn(props, key)) {
      warn(
        &amp;quot;The data property \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot; is already declared as a prop. &amp;quot; +
        &amp;quot;Use prop default value instead.&amp;quot;,
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, &amp;quot;_data&amp;quot;, key);
    }
  }
  // 双向数据绑定data
  observe(data, true /* asRootData */);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化&lt;code&gt;computed&lt;/code&gt;属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function initComputed (vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    // 每个computed key所定义的方法
    var userDef = computed[key];
    // 将该方法赋值给getter变量
    var getter = typeof userDef === &#39;function&#39; ? userDef : userDef.get;
    if (getter == null) {
			// 如果为空，打印错误
      warn(
        (&amp;quot;Getter is missing for computed property \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot;.&amp;quot;),
        vm
      );
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }

    // 如果当前节点computed上未有key这个方法
    if (!(key in vm)) {
      // defineComputed方法主要是为当前节点的computed属性添加响应式更新方法
      // 可以在defineComputed定义最后看到 Object.defineProperty(target, key, sharedPropertyDefinition) 
      defineComputed(vm, key, userDef);
    } else {
      if (key in vm.$data) {
        warn((&amp;quot;The computed property \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot; is already defined in data.&amp;quot;), vm);
      } else if (vm.$options.props &amp;amp;&amp;amp; key in vm.$options.props) {
        warn((&amp;quot;The computed property \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot; is already defined as a prop.&amp;quot;), vm);
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化&lt;code&gt;watch&lt;/code&gt;属性比较简单，在做了相应的判断后直接添加一个响应式更新属性，这里不多赘述，调用完&lt;code&gt;initState&lt;/code&gt;之后，会调用&lt;code&gt;created&lt;/code&gt;钩子函数，此时&lt;code&gt;vm&lt;/code&gt;上的属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// _init
vm._uid = 0
vm._isVue = true
vm.$options = {
  components: {
    KeepAlive,
    Transition,
    TransitionGroup
  },
  directives: {
    model,
    show
  },
  methods: {},
  computed: {},
  watch: {},
  filters: {},
  _base: Vue,
  el: &#39;#app&#39;,
  data: function mergedInstanceDataFn(){}
}
vm._renderProxy = vm
vm._self = vm

// initLifecycle
vm.$parent = parent
vm.$root = parent ? parent.$root : vm

vm.$children = []
vm.$refs = {}

vm._watcher = null
vm._inactive = null
vm._directInactive = false
vm._isMounted = false
vm._isDestroyed = false
vm._isBeingDestroyed = false

// initEvents	
vm._events = Object.create(null)
vm._hasHookEvent = false

// initRender
vm.$vnode = null  
vm._vnode = null
vm._staticTrees = null
vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext)
vm.$scopedSlots = emptyObject

vm._c = (a, b, c, d) =&amp;gt; createElement(vm, a, b, c, d, false)

vm.$createElement = (a, b, c, d) =&amp;gt; createElement(vm, a, b, c, d, true)
// 在 initState 中添加的属性
vm._watchers = []
vm._data
vm.message
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行完上面步骤后，会调用&lt;code&gt;vm.$mount&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 保存之前定义的$mount方法，然后重写Vue.prototype.$mount
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  // 查找当前节点
  el = el &amp;amp;&amp;amp; query(el)

 	// 如果事body元素或者documentElement元素则抛错
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; warn(
      `Do not mount Vue to &amp;lt;html&amp;gt; or &amp;lt;body&amp;gt; - mount to normal elements instead.`
    )
    return this
  }
	
  // 拿到options
  const options = this.$options
  // 如果节点上没有render函数
  if (!options.render) {
    // 获取template，template可以是#id、模板字符串、dom元素
    let template = options.template
    if (template) {
      if (typeof template === &#39;string&#39;) {
        if (template.charAt(0) === &#39;#&#39;) {
          // 获取templatge innerHTML
          template = idToTemplate(template)
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) {
        // 如果不是#id、模板字符串，直接获取其innerHTML
        template = template.innerHTML
      } else {
        if (process.env.NODE_ENV !== &#39;production&#39;) {
          warn(&#39;invalid template option:&#39; + template, this)
        }
        return this
      }
    } else if (el) {
      // 如果没有template，则获取el以及其子内容作为模板
      template = getOuterHTML(el)
    }
    if (template) {
      ......
    }
  }
  // 有render函数，直接执行mount.call(this, el, hydrating)
  return mount.call(this, el, hydrating)
}

function getOuterHTML (el: Element): string {
  if (el.outerHTML) {
    return el.outerHTML
  } else {
    const container = document.createElement(&#39;div&#39;)
    container.appendChild(el.cloneNode(true))
    return container.innerHTML
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面最后调用了&lt;code&gt;mount.call(this, el, hydrating)&lt;/code&gt;，其方法对应于&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el &amp;amp;&amp;amp; inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}

  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el
	......
  // 调用beforeMount钩子函数
  callHook(vm, &#39;beforeMount&#39;)

  let updateComponent
	
  ......
  
  // 更新当前节点的方法
  updateComponent = () =&amp;gt; {
    // vm._render会返回一个render字符串，_update其内部会调用patch方法来进行节点的增删改
    vm._update(vm._render(), hydrating)
  }

	// 创建一个watch对象，在调用updateComponent之前会先调用before方法
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted &amp;amp;&amp;amp; !vm._isDestroyed) {
        // 如果是更新节点，调用beforeUpdate钩子函数
        callHook(vm, &#39;beforeUpdate&#39;)
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

   // 当页面渲染完成后，调用钩子函数mounted
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, &#39;mounted&#39;)
  }
  return vm
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>about</title>
      <link>https://xtid.github.io/about/</link>
      <pubDate>Wed, 24 Jun 2020 00:08:20 +0800</pubDate>
      
      <guid>https://xtid.github.io/about/</guid>
      <description>&lt;p&gt;小小码农可笑可笑&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用Canvas实现一个红包雨的效果</title>
      <link>https://xtid.github.io/2020/%E4%BD%BF%E7%94%A8canvas%E5%81%9A%E4%B8%80%E4%B8%AA%E7%BA%A2%E5%8C%85%E9%9B%A8%E7%9A%84%E6%95%88%E6%9E%9C/</link>
      <pubDate>Mon, 15 Jun 2020 18:12:19 +0700</pubDate>
      
      <guid>https://xtid.github.io/2020/%E4%BD%BF%E7%94%A8canvas%E5%81%9A%E4%B8%80%E4%B8%AA%E7%BA%A2%E5%8C%85%E9%9B%A8%E7%9A%84%E6%95%88%E6%9E%9C/</guid>
      <description>

&lt;p&gt;之前使用jQuery做了一个红包雨的效果，感觉不是很理想，创建过多DOM元素造成性能上的浪费，整个页面也不够丝滑流畅，这次该用Canvas做一个红包雨的效果&lt;/p&gt;

&lt;h3 id=&#34;1-核心原理&#34;&gt;1.核心原理&lt;/h3&gt;

&lt;p&gt;1.生成红包，设置好默认的背景图像，传入页面上所需的红包数量&lt;/p&gt;

&lt;p&gt;2.保存状态，利用Canvas的原生API实现页面的渲染，每次移动各个红包到不同位置，利用&lt;code&gt;window.requestAnimationFrame&lt;/code&gt;实现每一帧的动画绘制，使整个页面不会卡顿&lt;/p&gt;

&lt;p&gt;3.点击红包，计算是否点中红包，如果点中，则进行相应的事件处理&lt;/p&gt;

&lt;h3 id=&#34;2-具体实现&#34;&gt;2.具体实现&lt;/h3&gt;

&lt;p&gt;2.1定义一些基本变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;redEnvelopeArr: [], // 当前整个红包对象数组
itemSpeed: [], // 每个红包对象对应的一些属性，如下落速度，页面上所在的位置
count: 0, // 加载好的红包图片的数量
ctx: null, // Canvas context对象
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.2加载红包图片&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;loadImgs(totalCount) {
  const self = this
  const canvas = document.getElementById(&#39;canvas&#39;)
  if (canvas.width &amp;lt; window.innerWidth) {
    canvas.width = window.innerWidth
  }
  if (canvas.height &amp;lt; window.innerHeight) {
    canvas.height = window.innerHeight
  }
  return new Promise(resolve =&amp;gt; {
    for (let index = 0; index &amp;lt; totalCount; index++) {
      const image = new Image()
      image.src = &#39;&#39; // 图片地址
      image.onload = () =&amp;gt; {
        self.count++
        self.itemSpeed.push({
          speed: 0, // 开始下落的位置
          step: self.randomFloat(2, 6) // 每个红包下落的速度
        })
        self.redEnvelopeArr.push({
          x: self.randomFloat(0, window.innerWidth - 100),
          y: 0,
          img: image
        })
        if (self.count === totalCount) resolve() // 所有图片加载完成跳出
      }
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.2生成随机数的一个方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;randomFloat(low, high) {
  return low + Math.random() * (high - low)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.3绘制红包图片下落，这里做了一个旋转下落的效果，主要原理是利用&lt;code&gt;translate&lt;/code&gt;移动context位置，旋转一定角度后，将原点移动到之前位置，做一个旋转的效果，每次操作的时候记得&lt;code&gt;sava&lt;/code&gt;、&lt;code&gt;restore&lt;/code&gt;。当然如果不想做旋转效果，那直接用&lt;code&gt;drawImage&lt;/code&gt;每次画不同位置的红包就行了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;drawRedEnvelope() {
  const self = this
  self.ctx.width = 100 // 红包的宽度
  self.ctx.height = 120 // 红包的高度
  self.redEnvelopeArr.forEach((item, index) =&amp;gt; {
    const newRedEnvelope = {
      x: item.x, // 红包所在的x轴位置
      y: item.y + self.itemSpeed[index].step, // 红包所在的y轴位置，主要由下落速度决定
      img: item.img,
      speed: item.speed
    }
    self.ctx.save()
    self.redEnvelopeArr.splice(index, 1, newRedEnvelope)
    self.ctx.translate(item.x + 50, 60 + self.itemSpeed[index].speed)
    self.ctx.rotate(self.itemSpeed[index].speed * Math.PI / 180)
    self.ctx.translate(-item.x - 50, -60 - self.itemSpeed[index].speed)
    self.ctx.drawImage(item.img, item.x, self.itemSpeed[index].speed)
    self.ctx.restore()
    self.itemSpeed[index].speed += self.itemSpeed[index].step
    // self.ctx.drawImage(item.img, item.x, item.y, self.ctx.width, self.ctx.height)
  })
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.4使用&lt;code&gt;clearRect&lt;/code&gt;清除上一帧的效果，在调用&lt;code&gt;drawRedEnvelope&lt;/code&gt;绘制新一帧的效果，使用&lt;code&gt;requestAnimationFrame&lt;/code&gt;重复执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;moveRedEnvelope() {
  const self = this
  self.ctx.clearRect(0, 0, window.innerWidth, window.innerHeight)
  self.drawRedEnvelope()
  window.requestAnimationFrame(self.moveRedEnvelope.bind(this))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.5点击红包时，循环遍历判断当前点击位置是否在某个红包内，如果遇到多个红包重叠的情况，只需取最上面一个就行了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;redEnvelopeClick() {
  const self = this
  const canvas = document.getElementById(&#39;canvas&#39;)
  canvas.addEventListener(&#39;click&#39;, e =&amp;gt; {
    let result = {}
    this.redEnvelopeArr.forEach((item, index) =&amp;gt; {
      const distanceX = e.clientX - item.x
      const distanceY = e.clientY - item.y
      const withinX = distanceX &amp;gt; 0
      const withinY = distanceY &amp;gt; 0
      if (withinX &amp;amp;&amp;amp; withinY) {
        result = item // 最后的result返回，然后做一些处理
      }
    })
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;后言&#34;&gt;后言&lt;/h3&gt;

&lt;p&gt;以上就是主要内容，需要特别注意的是，点击完了某个红包需要找个时间点清空整个页面上的动画，还有就是具体的点击实现的业务逻辑需自己去处理&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>