<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>👨🏻‍💻 on 👨🏻‍💻</title>
    <link>https://xtid.github.io/</link>
    <description>Recent content in 👨🏻‍💻 on 👨🏻‍💻</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 28 Nov 2020 16:23:05 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Flutter自定义组件</title>
      <link>https://xtid.github.io/2020/flutter%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Sat, 28 Nov 2020 16:23:05 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/flutter%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/</guid>
      <description>

&lt;h3 id=&#34;简言&#34;&gt;简言&lt;/h3&gt;

&lt;p&gt;在使用&lt;code&gt;Flutter&lt;/code&gt;开发app的时候，是使用各种各样的&lt;code&gt;Widget&lt;/code&gt; 组合绘制出的页面，一些最基础的如&lt;code&gt;Container&lt;/code&gt;、&lt;code&gt;Padding&lt;/code&gt;、&lt;code&gt;Text&lt;/code&gt; 等等，由官方封装好的比较复杂的组件如&lt;code&gt;AppBar&lt;/code&gt;、&lt;code&gt;日历选择器&lt;/code&gt;等等。仅仅使用这些组件也确实能写出一些app，但是官方封装好的拓展性我觉得不太好，有些属性根本无法改变；另外一旦和设计稿出入比较大，那根不就玩不了了，所以这就涉及到自定义组件。&lt;code&gt;Flutter&lt;/code&gt;自定义组件的方式我了解到有三种，一是通过组合其它组件来达到你想要的效果；二是自绘，这块牵扯到&lt;code&gt;Canvas&lt;/code&gt;；三是实现&lt;code&gt;RenderObject&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;1-原理基本介绍&#34;&gt;1.原理基本介绍&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Flutter&lt;/code&gt;引擎会将我们所写组件生成一个&lt;code&gt;Widget Tree&lt;/code&gt;，而实际渲染出来的结果又有一个&lt;code&gt;RenderObject Tree&lt;/code&gt;，&lt;code&gt;RenderObject&lt;/code&gt;是继承&lt;code&gt;Widget&lt;/code&gt;的。在项目运行中`&lt;code&gt;Widget Tree&lt;/code&gt;是不断变化的，如果每次变化都要导致整个&lt;code&gt;RenderObject Tree&lt;/code&gt;变化，这对性能来说是一个很大的消耗，于是就有了一个&lt;code&gt;Element Trre&lt;/code&gt;，这就相当于一个中间层，由&lt;code&gt;Widget&lt;/code&gt;→&lt;code&gt;Elment&lt;/code&gt;→&lt;code&gt;RenderObject&lt;/code&gt;。每次&lt;code&gt;Widget&lt;/code&gt;变化时，与&lt;code&gt;Element&lt;/code&gt;做对比，找出最小最优的变化，作用于&lt;code&gt;RenderObject&lt;/code&gt;。我们创建的&lt;code&gt;Widget&lt;/code&gt;基本继承于&lt;code&gt;StatelessWidget&lt;/code&gt;、&lt;code&gt;StatefulWidget&lt;/code&gt;，他们仅负责属性、生命周期等的管理，最终也还是会继承于&lt;code&gt;RenderObjectWidget&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RenderObjectWidget&lt;/code&gt;下面又有三个子类&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SngleChildRenderObjectWidget&lt;/code&gt;：&lt;code&gt;RenderObject&lt;/code&gt;只有一个 &lt;code&gt;child&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MultiChildRenderObjectWidget&lt;/code&gt;：可以有多个 &lt;code&gt;child&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LeafRenderObjectWidget&lt;/code&gt; ：&lt;code&gt;RenderObject&lt;/code&gt;是一个叶子节点，没有&lt;code&gt;child&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;官方所提供的组件很多都是继承&lt;code&gt;singleChildRenderObjectWidget&lt;/code&gt;，所以我们通常只能传一个&lt;code&gt;child&lt;/code&gt;，找到&lt;code&gt;singleChildRenderObjectWidget&lt;/code&gt;定义&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;abstract class SingleChildRenderObjectWidget extends RenderObjectWidget {
  const SingleChildRenderObjectWidget({ Key key, this.child }) : super(key: key);
  final Widget child;

  @override
  SingleChildRenderObjectElement createElement() =&amp;gt; SingleChildRenderObjectElement(this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到每次创建一个&lt;code&gt;SingleChildRenderObjectWidget&lt;/code&gt;就会调用`&lt;code&gt;CreateElement&lt;/code&gt;生成一个对应的&lt;code&gt;Elment&lt;/code&gt;，当然&lt;code&gt;MultiChildRenderObjectWidget&lt;/code&gt;也是类似，这也就说明了他们一对一的关系。所以我们实现自定义组件必须得继承&lt;code&gt;SingleChildRenderObjectWidget&lt;/code&gt;或者&lt;code&gt;MultiChildRenderObjectWidget&lt;/code&gt;或者调用官方实现好的自绘类，这也是&lt;code&gt;Flutter&lt;/code&gt;引擎渲染的基本结构。&lt;/p&gt;

&lt;h4 id=&#34;2-组合其它组件&#34;&gt;2..组合其它组件&lt;/h4&gt;

&lt;p&gt;这种方式是最基本最简单的方式，说白了就是将一些原有的、封装好的组件合并再封装一次。&lt;code&gt;Flutter&lt;/code&gt;本身就有很多组合组件，比如常用的&lt;code&gt;Container&lt;/code&gt;，查看它的源码就知道，它是由&lt;code&gt;DecoratedBox&lt;/code&gt;、&lt;code&gt;ConstrainedBox&lt;/code&gt;、&lt;code&gt;Transform&lt;/code&gt;、&lt;code&gt;Padding&lt;/code&gt;、&lt;code&gt;Align&lt;/code&gt;等组件组成，其内部做了很多判断处理。这里实现一个自定义宽度的&lt;code&gt;drawer&lt;/code&gt;组件，创建一个类&lt;code&gt;SmartDrawer&lt;/code&gt;继承&lt;code&gt;StatelessWidget&lt;/code&gt;，并实现其具体方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class SmartDrawer extends StatelessWidget {
  final double elevation;
  final Widget child;
  final String semanticLabel;
  final double widthPercent;
  const SmartDrawer({
    Key key,
    this.elevation = 16.0,
    this.child,
    this.semanticLabel,
    this.widthPercent = 0.7,
  }) : 
   assert(widthPercent != null &amp;amp;&amp;amp; widthPercent &amp;lt; 1.0 &amp;amp;&amp;amp; widthPercent&amp;gt; 0.0)
   ,super(key: key);

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasMaterialLocalizations(context));
    String label = semanticLabel;
    final double _width = MediaQuery.of(context).size.width * widthPercent;
    
    return Semantics(
      scopesRoute: true,
      namesRoute: true,
      explicitChildNodes: true,
      label: label,
      child: ConstrainedBox(
        constraints: BoxConstraints.expand(width: _width),
        child: Material(
          elevation: elevation,
          child: child,
        ),
      ),
    );
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，上述组件就是将&lt;code&gt;ConstrainedBox&lt;/code&gt;以及传入的&lt;code&gt;child&lt;/code&gt;组合成一个新的组件，其他属性则是来控制样式的。这里需要特别说明的，最后返回的&lt;code&gt;Semantics&lt;/code&gt;，它继承&lt;code&gt;SingleChildRenderObjectWidget&lt;/code&gt;，它上面定义的属性有点带有语义化的意思，而它上面定义的&lt;code&gt;child&lt;/code&gt;属性则是返回的组件，这样&lt;code&gt;return Semantices{}&lt;/code&gt;实际就表示返回了带有一些语义的组件。&lt;/p&gt;

&lt;h4 id=&#34;4-自绘组件&#34;&gt;4.自绘组件&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Flutter&lt;/code&gt;跨平台的实现方式就是在不同操作系统的上层绘制一个中间的UI系统，对不同的操作系统的&lt;code&gt;API&lt;/code&gt;进行适配，风格统一，这样就能实现一个跨平台应用了，这也是和&lt;code&gt;React Native&lt;/code&gt;的最大的差异以及优于&lt;code&gt;React Native&lt;/code&gt;的地方。当你无法用现有的组件来描绘你所需要UI时，可以考虑使用自绘组件来实现。下面是一个自绘的验证码组件示例&lt;/p&gt;

&lt;p&gt;首先创建一个名为&lt;code&gt;CodeReview&lt;/code&gt;的&lt;code&gt;StatefulWidget&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class CodeReview extends StatefulWidget {

  final String text;
  final callback;

  CodeReview({Key key, this.text, this.callback}) : super(key: key);

  _CodeReviewState createState() =&amp;gt; _CodeReviewState();

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后实现具体代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class _CodeReviewState extends State&amp;lt;CodeReview&amp;gt; {
	
  // 存放每个验证码字符上的横线的位置
  List&amp;lt;Offset&amp;gt; _lineOffsets = &amp;lt;Offset&amp;gt;[];

  // 验证码的长度，由外部传入
  int _textLength;
  // 验证码宽度
  double _width;
  // 验证码高度
  double _height;

  // 生成验证码上的横线遮挡物的位置
  void _randLines() {
    _lineOffsets.clear();
    for (var i = 0; i &amp;lt; _textLength; i++) {
      double fromX = randomBetween(10, 20).toDouble();
      double fromY = randomBetween(3, 33).toDouble();
      Offset from = Offset(fromX, fromY);
      _lineOffsets.add(from);

      double endX = randomBetween(60, _width.toInt() - 10).toDouble();
      double endY = randomBetween(3, 33).toDouble();
      Offset end = Offset(endX, endY);
      _lineOffsets.add(end);
    }
  }

  @override
  void initState() {
    super.initState();
    _textLength = widget.text.length ?? 4;
    _width = _textLength.toDouble() * 22;
    _height = 36;
    _randLines();
  }

  void _changeCode() {
    setState(() {
      _randLines();
    });
  }
	
  // 对每个字符进行随机rotate操作
  Container _subString(index) {
    return Container(
      padding: EdgeInsets.only(left: 2, right: 2, top: randomBetween(0, 14).toDouble()),
      child: Transform.rotate(
        angle: pi / randomBetween(3, 30) * randomBetween(0, 1),
        child: Text(widget.text[index], style: TextStyle(fontSize: randomBetween(20, 22).toDouble(), color: Color(0xFF4abdcc))),
      ),
    );
  }
	
 	// 描绘验证码上横线遮挡物
  Container _backLines() {
    return Container(
      width: _width,
      height: _height,
      child: CustomPaint(
        painter: CodePaint(_lineOffsets, Tool.randomColor()),
        foregroundPainter: CodePaint(_lineOffsets, Tool.randomColor()),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      width: _width,
      height: _height,
      color: Colors.grey[200],
      child: Stack(
        alignment: Alignment.center,
        children: &amp;lt;Widget&amp;gt;[
          _backLines(),
          _backLines(),
          GestureDetector(
            behavior: HitTestBehavior.opaque,
            onTap: () {
              _changeCode();
              widget.callback();
            },
            child: Container(
              width: _width,
              height: _height,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: List.generate(_textLength, (int index) {
                  return _subString(index);
                }),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到上面用到了&lt;code&gt;CustomPaint&lt;/code&gt;，这个类继承&lt;code&gt;SingleChildRenderObjectWidget&lt;/code&gt;，这让我们直接能使用&lt;code&gt;Canvas&lt;/code&gt;来绘制你所需要的UI&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class CustomPaint extends SingleChildRenderObjectWidget {
  /// Creates a widget that delegates its painting.
  const CustomPaint({
    Key key,
    this.painter,
    this.foregroundPainter,
    this.size = Size.zero,
    this.isComplex = false,
    this.willChange = false,
    Widget child,
  })......
    ......
    ......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传入&lt;code&gt;painter&lt;/code&gt; 、&lt;code&gt;foregroundPainter&lt;/code&gt;对应类，在上述代码中，是创建一个类的&lt;code&gt;CodePaint&lt;/code&gt;继承&lt;code&gt;CustomPainer&lt;/code&gt;，重写&lt;code&gt;paint&lt;/code&gt;方法，然后设置画笔的属性，最后调用对应的&lt;code&gt;Canvas&lt;/code&gt;api即可，这里使用的是&lt;code&gt;drawPoints&lt;/code&gt;，还有其他的，如&lt;code&gt;drawCircle&lt;/code&gt;、&lt;code&gt;drawLine&lt;/code&gt;等等。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class CodePaint extends CustomPainter {
  final List&amp;lt;Offset&amp;gt; lineOffsets;
  final Color ranColor;
  CodePaint(this.lineOffsets, this.ranColor);

  @override
  void paint(Canvas canvas, Size size) {
    // debugPrint(canvas.runtimeType.toString());
    canvas.save();
    Paint _paint = Paint()
      ..color = ranColor // 画笔颜色
      ..strokeCap = StrokeCap.round // 画笔笔触类型
      ..isAntiAlias = true // 是否启动抗锯齿
      ..blendMode = BlendMode.exclusion // 颜色混合模式
      ..style = PaintingStyle.fill // 绘画风格，默认为填充
      ..colorFilter = ColorFilter.mode(ranColor, BlendMode.exclusion) // 颜色渲染模式，一般是矩阵效果来改变的,但是flutter中只能使用颜色混合模式
      ..maskFilter = MaskFilter.blur(BlurStyle.inner, 1.0) // 模糊遮罩效果
      ..filterQuality = FilterQuality.high // 颜色渲染模式的质量
      // ..strokeWidth = randomBetween(1, 3).toDouble(); // 暂时固定
      ..strokeWidth = 1;

    final pointMode = PointMode.lines;
    canvas.drawPoints(pointMode, lineOffsets, _paint);
    canvas.restore();
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) {
    return false;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;综上，自绘逐渐的核心是继承&lt;code&gt;CustomPaint&lt;/code&gt;，然后使用&lt;code&gt;Canvas&lt;/code&gt;实现UI的绘制&lt;/p&gt;

&lt;h4 id=&#34;5-实现renderobject&#34;&gt;5.实现RenderObject&lt;/h4&gt;

&lt;p&gt;实现&lt;code&gt;RenderObject&lt;/code&gt;即是自己重写一整套渲染树，首先得继承一个&lt;code&gt;RenderObject&lt;/code&gt;，实现其内置仿佛，还得继承&lt;code&gt;Element&lt;/code&gt;，实现其内置方法，复杂的自定义组件最终也是通过&lt;code&gt;Canvas&lt;/code&gt; API来绘制的，而上面说的&lt;code&gt;CustomPaint&lt;/code&gt;只是为了方便开发者封装的一个代理类，它直接继承自&lt;code&gt;SingleChildRenderObjectWidget&lt;/code&gt;，通过&lt;code&gt;RenderCustomPaint&lt;/code&gt;的&lt;code&gt;paint&lt;/code&gt;方法将&lt;code&gt;Canvas&lt;/code&gt;和画笔&lt;code&gt;Painter&lt;/code&gt;连接起来实现自绘组件。这种方式操作起来实在比较麻烦，我也没怎么用过，所以就不提供示例展示了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>输入一个URL到页面呈现的过程</title>
      <link>https://xtid.github.io/2020/%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAurl%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0%E7%9A%84%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Sun, 15 Nov 2020 15:21:34 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAurl%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0%E7%9A%84%E8%BF%87%E7%A8%8B/</guid>
      <description>

&lt;h4 id=&#34;1-dns解析&#34;&gt;1.DNS解析&lt;/h4&gt;

&lt;p&gt;平时在浏览器中输入的域名并非是网址或资源真实所在的服务器地址或资源，域名只是与&lt;code&gt;ip&lt;/code&gt;地址的一个映射。在进行正式的请求之前，就会先有这个过程：&lt;code&gt;DNS&lt;/code&gt;服务将域名解析成对应的&lt;code&gt;ip&lt;/code&gt;地址。其解析过程：&lt;/p&gt;

&lt;p&gt;1.检查本机&lt;code&gt;host&lt;/code&gt;中是否有配置相应的&lt;code&gt;ip&lt;/code&gt;映射关系，如果有则使用这个&lt;code&gt;ip&lt;/code&gt;地址，完成域名解析
2.检查浏览器缓存中是否缓存过该域名对应的&lt;code&gt;ip&lt;/code&gt;地址
3.检查找本机系统中是否缓存过&lt;code&gt;ip&lt;/code&gt;
4.向本地域名解析服务发起域名解析的请求
5.向根域名解析服务器发起域名解析请求
6.按照根域名&lt;code&gt;(.)&lt;/code&gt; -&amp;gt; 顶级域&lt;code&gt;(如：.com)&lt;/code&gt; -&amp;gt; 第二层域&lt;code&gt;(如：xxx.com)&lt;/code&gt; -&amp;gt; 子域&lt;code&gt;(如：www.xxx.com)&lt;/code&gt;的顺序查找到ip地址
8.返回解析结果给用户&lt;/p&gt;

&lt;h4 id=&#34;2-建立-tcp-连接&#34;&gt;2.建立&lt;code&gt;TCP&lt;/code&gt;连接&lt;/h4&gt;

&lt;p&gt;经典的三次握手&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;第一次握手： 建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；&lt;/p&gt;

&lt;p&gt;第二次握手： 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；&lt;/p&gt;

&lt;p&gt;第三次握手： 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单来说其步骤就是，客户端发送数据包告诉服务端连接请求，服务端返回数据包响应表示可以收到建立连接请求并且返回数据包通知客户端，客服端再次发送数据包确认并建立&lt;code&gt;TCP&lt;/code&gt;连接&lt;/p&gt;

&lt;h4 id=&#34;3-发送-http-请求&#34;&gt;3.发送&lt;code&gt;HTTP&lt;/code&gt;请求&lt;/h4&gt;

&lt;p&gt;一个&lt;code&gt;HTTP&lt;/code&gt;请求包含请求行，请求头，请求主体&lt;/p&gt;

&lt;h5 id=&#34;3-1请求行&#34;&gt;3.1请求行&lt;/h5&gt;

&lt;p&gt;常见的信息有请求地址、请求方法&lt;code&gt;GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE&lt;/code&gt;、&lt;code&gt;Http&lt;/code&gt;协议信息&lt;/p&gt;

&lt;h5 id=&#34;3-2请求头&#34;&gt;3.2请求头&lt;/h5&gt;

&lt;p&gt;常见的请求头信息有&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Host&lt;/code&gt;：主机名
&lt;code&gt;Connection&lt;/code&gt;：&lt;code&gt;HTTP/1.1&lt;/code&gt;增加的，使用&lt;code&gt;keepalive&lt;/code&gt;，一个连接可以发多个请求
&lt;code&gt;User-Agent&lt;/code&gt;：客户端程序的信息，就是发送请求的浏览器信息，可根据这个信息来对不同设备进行处理
&lt;code&gt;Accept&lt;/code&gt;：浏览器可以接收的媒体数据类型
&lt;code&gt;Accept-Encoding&lt;/code&gt;：是浏览器用来告知服务器它能够支持的内容编码及内容编码的优先级顺序，可一次性指定多种内容编码
&lt;code&gt;Accept-Language&lt;/code&gt;：告诉服务器浏览器能够处理的自然语言集
&lt;code&gt;Content-Type&lt;/code&gt;：请求中的数据的媒体类型
&lt;code&gt;Cookie&lt;/code&gt;：浏览器记录的用户相关信息&lt;/p&gt;

&lt;p&gt;当然还有很多其他的，这里就不罗列完了，另外还可以自己添加一些自定义请求头，在服务端手动获取处理就行了&lt;/p&gt;

&lt;h5 id=&#34;3-3请求主体&#34;&gt;3.3请求主体&lt;/h5&gt;

&lt;p&gt;主要是请求所带的一些参数信息，这里就不多赘述&lt;/p&gt;

&lt;h4 id=&#34;4-使用浏览器缓存&#34;&gt;4.使用浏览器缓存&lt;/h4&gt;

&lt;p&gt;浏览器缓存主要&lt;code&gt;强缓存&lt;/code&gt;和&lt;code&gt;协商缓存&lt;/code&gt;，具体使用哪一种缓存，强缓存的优先级比协商缓存高，怎么设置还是得从实际出发&lt;/p&gt;

&lt;h5 id=&#34;4-1强缓存&#34;&gt;4.1强缓存&lt;/h5&gt;

&lt;p&gt;强缓存可以用&lt;code&gt;Expires&lt;/code&gt;和&lt;code&gt;Cache-Control&lt;/code&gt;来控制，强缓存最大的特点就是通过服务器返回的过期时间来判断缓存是否过期，不会再去和服务端做校验看资源是否真正更新了&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Expires&lt;/code&gt;：主由服务端返给客户端，在过期时间内，浏览器可直接使用缓存而不需要重新请求，但它也有不少局限，首先它只能精确到秒，对于那种毫秒级更新的资源它没办法判断，其次它受限于本地时间，如果修改了本地时间，可能会造成缓存失效。&lt;code&gt;Expires&lt;/code&gt;是&lt;code&gt;Http/1&lt;/code&gt;时候的请求头，现在这样设置通常也是为了兼容&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Cache-Control&lt;/code&gt;：是现在主要使用的方式，可以在请求头以及响应头中设置，常见设置有&lt;code&gt;max-age(表示缓存在多少秒后过期)&lt;/code&gt;，&lt;code&gt;no-cache(表示使用Etag或者Last-Modified字段来控制缓存，即协商缓存)&lt;/code&gt;，通常来讲，&lt;code&gt;Cache-control&lt;/code&gt;的优先级是要高于&lt;code&gt;Expires&lt;/code&gt;的&lt;/p&gt;

&lt;h5 id=&#34;4-2协商缓存&#34;&gt;4.2协商缓存&lt;/h5&gt;

&lt;p&gt;在强缓存失效后就会用协商缓存，协商缓存主要使用&lt;code&gt;Last-Modified 和 ETag&lt;/code&gt;请求头控制，这两个字段都是由服务端返回的。如果说缓存还生效，那么这次请求的状态码会返回&lt;code&gt;304&lt;/code&gt;，表示资源未改动，如果缓存失效，返回新的资源并设置缓存，返回&lt;code&gt;200&lt;/code&gt;状态码&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Last-Modified&lt;/code&gt;：在设置&lt;code&gt;Last-Modified&lt;/code&gt;后，下次请求时请求头会带上&lt;code&gt;If-Modified-Since&lt;/code&gt;这个字段，然后服务器会用这个时间与资源修改时间做对比，然后就是返回&lt;code&gt;304&lt;/code&gt;还是&lt;code&gt;200&lt;/code&gt;的问题了，同样它也只能精确到秒，所以一些需要毫秒级更新的资源使用这个并不准确&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ETag&lt;/code&gt;：通常与&lt;code&gt;If-None-Match&lt;/code&gt;配合使用，&lt;code&gt;Etag&lt;/code&gt;为服务端为这资源生成的唯一标识，下次客户端请求的时候，带上这个值，由服务端再做校验，如果资源未改动，返回&lt;code&gt;304&lt;/code&gt;，使用原来的缓存，反之返回&lt;code&gt;200&lt;/code&gt;，设置缓存&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/10/28/O2gaJWm8jYPeI7c.png&#34; alt=&#34;浏览器缓存.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图出自&lt;a href=&#34;https://github.com/ljianshu/Blog&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;博客&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;5-浏览器接收响应&#34;&gt;5.浏览器接收响应&lt;/h4&gt;

&lt;p&gt;响应分为状态码，响应头，响应主体组成，响应主体通常是一些文件&lt;code&gt;如(HTML、JS、CSS文件)&lt;/code&gt;或者说是一些响应数据&lt;code&gt;(请求的响应数据)&lt;/code&gt;，状态码和响应头这里就不罗列了。有个特别的通常为了提升响应的效率，服务端会将一些进行&lt;code&gt;gzip&lt;/code&gt;压缩，然后响应头里面会有个响应头&lt;code&gt;content-encoding:gzip&lt;/code&gt;，然后浏览器会再进行解压&lt;/p&gt;

&lt;h4 id=&#34;6-页面渲染&#34;&gt;6.页面渲染&lt;/h4&gt;

&lt;p&gt;在接收响应成功之后，浏览器就开始渲染页面了。其步骤包括：1.解析&lt;code&gt;HTML&lt;/code&gt;为&lt;code&gt;DOM&lt;/code&gt;树、2.解析&lt;code&gt;CSS&lt;/code&gt;为&lt;code&gt;CSS&lt;/code&gt;树、3.合并&lt;code&gt;DOM&lt;/code&gt;树已经&lt;code&gt;CSS&lt;/code&gt;树、4.遍历整个节点、5.按照&lt;code&gt;CSS&lt;/code&gt;的优先级渲染每个节点的样式，呈现在屏幕上。当浏览器遇到一个&lt;code&gt;script&lt;/code&gt;标记时，&lt;code&gt;DOM&lt;/code&gt;构建将暂停，直至脚本完成执行，然后继续构建&lt;code&gt;DOM&lt;/code&gt;。每次去执行&lt;code&gt;JS&lt;/code&gt;脚本都会严重阻塞&lt;code&gt;DOM&lt;/code&gt;树的构建，如果&lt;code&gt;JS&lt;/code&gt;脚本还操作的&lt;code&gt;CSSOM&lt;/code&gt;，而正好这个&lt;code&gt;CSSOM&lt;/code&gt;还没有下载和构建，浏览器甚至会延迟脚本执行和构建&lt;code&gt;DOM&lt;/code&gt;，直至完成其&lt;code&gt;CSSOM&lt;/code&gt;的下载和构建。所以这里通常会有个常见的小优化，&lt;code&gt;CSS&lt;/code&gt;放在顶部，&lt;code&gt;JS&lt;/code&gt;放在底部，并且减少使用在加载的过程中操作&lt;code&gt;DOM&lt;/code&gt;，当然这也是比较老的做法了。在页面加载的过程中，所写的&lt;code&gt;CSS&lt;/code&gt;和&lt;code&gt;JS&lt;/code&gt;也要尽量避免重绘和回流&lt;/p&gt;

&lt;h4 id=&#34;7-四次握手&#34;&gt;7.四次握手&lt;/h4&gt;

&lt;p&gt;四次握手用于断开&lt;code&gt;Tcp&lt;/code&gt;连接，客户端发送请求表示要断开连接，服务接受到请求后响应，客户端收到响应准备断开连接，服务端将其余数据或没响应的数据全部返给客户端(即又一次握手)，客户端收到后响应后再发送请求确认关闭，服务端收到后断开连接&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&#34;参考链接&#34;&gt;参考链接&lt;/h6&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ljianshu/Blog&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;博客&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>浅谈前端统计</title>
      <link>https://xtid.github.io/2020/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E7%BB%9F%E8%AE%A1/</link>
      <pubDate>Wed, 28 Oct 2020 21:45:40 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E7%BB%9F%E8%AE%A1/</guid>
      <description>&lt;p&gt;监控系统在现在的项目中是必不可少的，它具有性能监控、错误监控以及数据上报等功能。通过对的错误监控、用户正常行为的收集，从而指定对应的优化方案、营销策略以及项目的迭代。 试想，如果没有这些监控系统，那么线上的运行的项目出问题了，定位是比较困难的，这时候修复起来就比较劳神了。我记录下我所了解的，常见的方式。&lt;/p&gt;

&lt;p&gt;1.错误监控&lt;/p&gt;

&lt;p&gt;我们对于错误的处理，在&lt;code&gt;js&lt;/code&gt;中很常见的错误捕获&lt;code&gt;try catch&lt;/code&gt;、&lt;code&gt;promise中的catch&lt;/code&gt;等等。在window对象上有一个方法&lt;code&gt;onerror&lt;/code&gt;，可以拿到当前报错的信息，我们就可以将这个信息拿到然后提交到我们自己的监控系统，还有个很重要的原因，不处理这些错误，导致页面挂了停止加载，那损失可就大了。对于抛出的错误，它有几个属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 定义一个错误对象
const defaults = {
  msg: &#39;&#39;, // 错误的具体信息
  url: &#39;&#39;, // 错误所在的url
  line: &#39;&#39;, // 错误所在的行
  col: &#39;&#39;, // 错误所在的列
  nowTime: &#39;&#39; // 时间
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后实现&lt;code&gt;window.onerror&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;window.onerror = function (msg, url, line, col, error) {
  col = col || (window.event &amp;amp;&amp;amp; window.event.errorCharacter) || 0

  defaults.url = url
  defaults.line = line
  defaults.col = col
  defaults.nowTime = new Date().getTime()

  if (error &amp;amp;&amp;amp; error.stack) {
    // 如果浏览器有错误堆栈信息，直接使用
    defaults.msg = error.stack.toString()
  } else if (arguments.callee) {
    // 通过callee拿堆栈信息
    let ext = []
    let fn = arguments.callee.caller
    // 最多拿到三层
    let floor = 3
    while (fn &amp;amp;&amp;amp; (--floor &amp;gt; 0)) {
      ext.push(fn.toString())
      if (fn === fn.caller) {
        break
      }
      fn = fn.caller
    }
    ext = ext.join(&#39;,&#39;)
    defaults.msg = error &amp;amp;&amp;amp; error.stack &amp;amp;&amp;amp; error.stack.toString()
  }
  let str = &#39;&#39;
  // 格式化这些错误信息
  for (const i in defaults) {
    if (!defaults[i]) {
      defaults[i] = &#39;null&#39;
    }
    str += &#39;&amp;amp;&#39; + i + &#39;=&#39; + defaults[i].toString()
  }
  // 确定错误是由哪位用户引起的，这一步有些时候可以不用
  let userinfo = // 拿到用户信息
  if (typeof userinfo === &#39;object&#39;) {
    userinfo = JSON.stringify(userinfo)
  }
  if (userinfo) userinfo = encodeURIComponent(userinfo)
  str = encodeURIComponent(str.replace(&#39;&amp;amp;&#39;, &#39;&#39;).replace(&#39;\n&#39;, &#39;&#39;).replace(/\s/g, &#39;&#39;))
	
  // 避免出现跨域错误
  new Image().src = &#39;api地址?msg=&#39; + str + &#39;&amp;amp;userinfo=&#39; + userinfo
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方式的缺陷在于，没办法处理&lt;code&gt;promise&lt;/code&gt;中未处理的错误，对于&lt;code&gt;promise&lt;/code&gt;，推荐使用&lt;code&gt;unhandledrejection&lt;/code&gt;事情处理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;window.addEventListener(&#39;unhandledrejection&#39;, event =&amp;gt; {
  let error = event.reason &amp;amp;&amp;amp; event.reason.message
  if (!error) {
    error = typeof event.reason === &#39;object&#39; ? JSON.stringify(event.reason) : event.reason
  }

  (new Image()).src = &#39;api地址?msg=&#39; + encodeURIComponent(error)
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.埋点&lt;/p&gt;

&lt;p&gt;埋点是一种常见的统计用户行为的方式或工具。通过在页面设置埋点，来统计用户对于某个页面、广告、功能的使用频率、喜好，然后通过对埋点的数据统计，确定好页面或功能的迭代。简单的做法，设置一个全局方法用来提交埋点点击的行为，在需要的地方调用这个方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 定义一个全局方法
// 传入的point为埋点数据
function clickPoint(point = {}) {
  const { id, name } = point
  cosnt userInfo = // 通过对应的操作拿到用户信息
  // 基础参数
  const basicParams = {
    id: id || &#39;&#39;,
    name: name || &#39;&#39;
  }
  // 用户信息
 	const userParams = {
  	name: userInfo.name || &#39;&#39;
    ......
 	}
  // 合并参数
  const params = {
    ...basicParams,
    ...userParams
  }
  let str = &#39;&#39;
  for (const i in params) {
    if (!params[i]) {
      params[i] = &#39;null&#39;
    }
    str += &#39;&amp;amp;&#39; + i + &#39;=&#39; + params[i].toString()
  }
  new Image().src = &#39;api地址?msg=&#39; + str
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常这样来统计页面上某个功能、某个广告的点击量，获取对应的统计数据。还有一种比较常见的方式，为需要添加埋点的&lt;code&gt;html&lt;/code&gt;标签上加上某个约定好的自定义属性，如&lt;code&gt;&amp;lt;div data-link=&amp;quot;111&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;，这个&lt;code&gt;111&lt;/code&gt;就是就是实现生成好或者规划好的埋点。然后给这种属性添加全局的点击事件，点击后同样的将对应的数据提交到自己的后台系统去。有些时候为了方便查阅或者直观的观看统计数据，还可以在页面渲染的时候，为含有&lt;code&gt;data-link&lt;/code&gt;属性的标签生成对应的一些图标或者文字标签，使用&lt;code&gt;absolute&lt;/code&gt;定位显示在对应的元素上，当然这种方式在你添加买点埋点属性的时候，需要给这个元素设置相应的&lt;code&gt;position css&lt;/code&gt;属性；当然也可能设置一些热力图啊等其它形式，反正都是实现同一个效果的。&lt;/p&gt;

&lt;p&gt;3.白屏时间&lt;/p&gt;

&lt;p&gt;这个之前说过，就不说废话了，白屏时间的统计是非常重要的。比如有些时候，只有某个用户的某个设备出现了页面加载过长，页面没内容，发现这个问题后，通过判断错误日志和白屏时间才能更快的定位问题。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;window.logInfo = {}
window.logInfo.openTime = window.performance &amp;amp;&amp;amp; window.performance.timing.navigationStart || 0
window.logInfo.whiteScreenTime = +new Date() - window.logInfo.openTime
window.logInfo.mobile = mobileType()

// 使用 DOMContentLoaded 统计页面有内容的时间
document.addEventListener(&#39;DOMContentLoaded&#39;, function () {
  window.logInfo.readyTime = +new Date() - window.logInfo.openTime
})
window.onload = function () {
  window.logInfo.allloadTime = +new Date() - window.logInfo.openTime
  window.logInfo.nowTime = new Date().getTime()
  let timname = {
    whiteScreenTime: &#39;白屏时间&#39;,
    readyTime: &#39;用户可操作时间&#39;,
    allloadTime: &#39;总下载时间&#39;,
    mobile: &#39;使用设备&#39;,
    nowTime: &#39;时间&#39;,
  }
  let logStr = &#39;&#39;
  for (const i in timname) {
    if (i === &#39;mobile&#39;) {
      logStr += &#39;&amp;amp;&#39; + i + &#39;=&#39; + window.logInfo[i]
    } else {
      logStr += &#39;&amp;amp;&#39; + i + &#39;=&#39; + window.logInfo[i]
    }
  }
  // 这里如果需要的话，还可以把用户的一些信息收集出来
  (new Image()).src = &#39;api地址?msg=&#39; + logStr
}

function mobileType() {
  const u = navigator.userAgent
  // 移动终端浏览器版本信息
  const type = {
    ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), // ios终端
    iPad: u.indexOf(&#39;iPad&#39;) &amp;gt; -1, // 是否iPad
    android: u.indexOf(&#39;Android&#39;) &amp;gt; -1 || u.indexOf(&#39;Linux&#39;) &amp;gt; -1, // android终端或者uc浏览器
    iPhone: u.indexOf(&#39;iPhone&#39;) &amp;gt; -1 || u.indexOf(&#39;Mac&#39;) &amp;gt; -1, // 是否为iPhone或者QQHD浏览器
    trident: u.indexOf(&#39;Trident&#39;) &amp;gt; -1, // IE内核
    presto: u.indexOf(&#39;Presto&#39;) &amp;gt; -1, // opera内核
    webKit: u.indexOf(&#39;AppleWebKit&#39;) &amp;gt; -1, // 苹果、谷歌内核
    gecko: u.indexOf(&#39;Gecko&#39;) &amp;gt; -1 &amp;amp;&amp;amp; u.indexOf(&#39;KHTML&#39;) === -1, // 火狐内核
    mobile: !!u.match(/AppleWebKit.*Mobile/i) || !!u.match(/MIDP|SymbianOS|NOKIA|SAMSUNG|LG|NEC|TCL|Alcatel|BIRD|DBTEL|Dopod|PHILIPS|HAIER|LENOVO|MOT-|Nokia|SonyEricsson|SIE-|Amoi|ZTE/), // 是否为移动终端
    webApp: u.indexOf(&#39;Safari&#39;) === -1 // 是否web应该程序，没有头部与底部
  }
  const lists = Object.keys(type)
  for (const i = 0; i &amp;lt; lists.length; i++) {
    if (type[lists[i]]) {
      return lists[i]
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>白屏时间</title>
      <link>https://xtid.github.io/2020/%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4/</link>
      <pubDate>Sat, 24 Oct 2020 23:45:12 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4/</guid>
      <description>&lt;p&gt;白屏时间指的是从用户进入网站，一直到页面有内容展示出来的时间节点，在这期间用户什么东西都看不到，这个过程包括dns查询、建立tcp连接、发送首个http请求、返回html文档、html文档head解析完毕。白屏时间的长短，影响着用户的体验，白屏时间过长，用户失去了耐心等待，也许就关闭了网页&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一份是 &lt;a href=&#34;http://www.akamai.com/html/about/press/releases/2009/press_091409.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Akamai&lt;/a&gt; 的研究报告，当时总共采访了大约 1048 名网上购物者，得出了这样的结论：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;大约有 47% 的用户期望他们的页面在两秒之内加载完成。&lt;/li&gt;
&lt;li&gt;如果页面加载时间超过 3s，大约有 40% 的用户选择离开或关闭页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;白屏时间的计算就如上诉定义说的那样，只需要记录用户进入页面的开始时间，记录head加载完成的时间，记录两者的差值，这就是所说的白屏时间。计算的时候可以分别获取两个时间，计算他们的差，也可以使用&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/mark&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;performance.mark&lt;/a&gt;，在开始地点标记或者说打点，在结束地点获取这个&lt;code&gt;entry&lt;/code&gt;，拿到它的&lt;code&gt;duration&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
	&amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
	&amp;lt;title&amp;gt;白屏时间&amp;lt;/title&amp;gt;
	&amp;lt;script&amp;gt;
		window.startTime = Date.now();
    // performance.mark(&amp;quot;timeStr&amp;quot;);
	&amp;lt;/script&amp;gt;
	&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;&amp;quot;&amp;gt;
	&amp;lt;script src=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
	&amp;lt;script&amp;gt;
		window.endTime = Date.now()
    // const timeStrEntries = performance.getEntriesByName(&amp;quot;timeStrEntries&amp;quot;);
    // console.log(timeStrEntries[0].duration)
	&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外还有一种方式，使用&lt;code&gt;window.performance&lt;/code&gt;，在&lt;code&gt;timing&lt;/code&gt;对象中，包含了各种时间相关的属性，其中&lt;code&gt;domLoading&lt;/code&gt;属性代表开始解析&lt;code&gt;DOM&lt;/code&gt;元素的时间，&lt;code&gt;fetchStart&lt;/code&gt;属性代表发送请求前的时间，两者之差也可以计算白屏时间&lt;/p&gt;

&lt;p&gt;对于具体的时间优化，可以针对整个页面渲染的过程来处理。这里说一下：&lt;code&gt;预渲染&lt;/code&gt;、&lt;code&gt;服务端渲染&lt;/code&gt;、&lt;code&gt;使用骨架屏&lt;/code&gt;，这也可以说是用户的体验优化&lt;/p&gt;

&lt;p&gt;首先预渲染，主要是用&lt;code&gt;prerender-spa-plugin&lt;/code&gt;来实现这个功能。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;prerender-spa-plugin 利用了 Puppeteer 的爬取页面的功能。 Puppeteer 是 Google Chrome 团队官方的无界面（Headless）Chrome 工具，它是一个 Node 库，提供了一个高级的 API 来控制 DevTools 协议上的无头版 Chrome 。prerender-spa-plugin 原理是在 Webpack 构建阶段的最后，在本地启动一个 Puppeteer 的服务，访问配置了预渲染的路由，然后将 Puppeteer 中渲染的页面输出到 HTML 文件中，并建立路由对应的目录。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先请求到对应的路由或者页面之后，&lt;code&gt;Puppeteer&lt;/code&gt;会获取渲染的页面的静态部分内容并替换打包出来的&lt;code&gt;html&lt;/code&gt;文件，达到预渲染的目的，页面加载完成之前呈现给用户部分内容，给用户一个相对好的体验。但是缺点是预渲染出的内容往往与最终渲染的页面内容不同，因为页面会有相应的交互或者数据的变化，所以最好对于一些静态页面才用这种方式处理。&lt;/p&gt;

&lt;p&gt;首先在对应的&lt;code&gt;webpack&lt;/code&gt;配置文件中添加这个插件的配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const PrerenderSPAPlugin = require(&#39;prerender-spa-plugin&#39;);
const Renderer = PrerenderSPAPlugin.PuppeteerRenderer;
const path = require(&#39;path&#39;);

module.exports = {
  plugins: [new PrerenderSPAPlugin({
    staticDir: path.join(__dirname, &#39;dist&#39;),
    routes: [ &#39;/&#39; ], // 需要预渲染的路由,
    renderer: new Renderer({
        headless: true, // 开启无头浏览器
        renderAfterDocumentEvent: &#39;render-event&#39;, 
    }),
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在页面触发&lt;code&gt;render-event&lt;/code&gt;事件，告诉&lt;code&gt;Puppeteer&lt;/code&gt;去爬取这个页面，这里以&lt;code&gt;vue&lt;/code&gt;为例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export default {
  mounted() {
    document.dispatchEvent(new Event(&#39;render-event&#39;));
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后访问对应的&lt;code&gt;route&lt;/code&gt;，在&lt;code&gt;index.html&lt;/code&gt;中就可以看到相应的内容了。实际应用中在静态页面中的时候，应当另外指定对应的&lt;code&gt;html&lt;/code&gt;文件，如果配置了&lt;code&gt;CDN&lt;/code&gt;，那么在本地开发的时候，应该将&lt;code&gt;CDN&lt;/code&gt;地址替换为本地地址，这个插件也提供了&lt;code&gt;server&lt;/code&gt;选项&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;server: {
  port: 80,
  proxy: {
    ......
    target: &#39;http://localhost&#39;,
    changeOrigin: true,
    ......
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务端渲染&lt;/p&gt;

&lt;p&gt;服务端渲染是由服务端将渲染好的&lt;code&gt;html&lt;/code&gt;字符串直接返给客户端，客户端接受到对应的&lt;code&gt;html&lt;/code&gt;字符串后，解析渲染呈现出相应的页面。客户端渲染时，客户端需要去请求相应的接口取得相应的数据然后渲染出&lt;code&gt;html&lt;/code&gt;页面，因此，服务端渲染白屏时间相对较短。还有个额外的好处当然是利于SEO，这个作用恐怕还在白屏优化之上。客户端渲染一开始的页面为空，在某些爬虫来爬的时候什么东西都获取不到，所以不利于SEO，当然这是后话了。现在我们这用的比较多的，一般是以&lt;code&gt;nodejs&lt;/code&gt;为中间层，接受到客户端的请求后，发送真正的请求到后台，随后在&lt;code&gt;nodejs&lt;/code&gt;中处理完对应的数据，渲染页面。现在以&lt;code&gt;react&lt;/code&gt;、&lt;code&gt;vue&lt;/code&gt;为基础，也有各自对应的服务端渲染方案，如&lt;code&gt;next.js&lt;/code&gt;、&lt;code&gt;nuxt.js&lt;/code&gt;这里就不介绍了&lt;/p&gt;

&lt;p&gt;骨架屏&lt;/p&gt;

&lt;p&gt;骨架屏可以看做用来代替页面&lt;code&gt;loading&lt;/code&gt;效果的一种方案，在页面加载完成之前，呈现出页面的一个大致结构，给用户一个良好的体验，让他觉得这个页面正在缓慢加载，这种效果看起来也比单纯的放一张菊花图、一张加载动画好一些。这个方案更多的是带来更好的用户体验。手写骨架屏，首先确定页面的基本结构，然后按照这个结构写一个类似的加载页面，这个由设计来定。以下介绍使用&lt;code&gt;webpack(4.0+)&lt;/code&gt;来写一个简单的骨架屏插件。&lt;/p&gt;

&lt;p&gt;首先定义一个骨架屏插件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)

let Skeleton = function (options) {
  // 接收传入的参数
}

Skeleton.prototype.apply = function (compiler) {
  compiler.plugin(&#39;compilation&#39;, compilation =&amp;gt; {
    HtmlWebpackPlugin.getHooks(compilation).beforeEmit.tapAsync(
      &#39;Skeleton&#39;,
      (htmlData, cb) =&amp;gt; {
        htmlData.html = htmlData.html.replace(&#39;&amp;lt;div id=&amp;quot;root&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#39;, `骨架屏代码`)
        cb(null, htmlData)
      }
    )
  })
}

module.exports = Skeleton
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后&lt;code&gt;webpack&lt;/code&gt;配置文件中引入即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;...
new HtmlWebPackPlugin({
  template: &#39;public/index.html&#39;,
  filename: &#39;index.html&#39;,
  inject: true
}),
new Skeleton({
  template: &#39;public/index.html&#39;
})
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.以上首先定义一个插件对象&lt;code&gt;Skeleton&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2.引入&lt;code&gt;html-webpack-plugin&lt;/code&gt;，在&lt;code&gt;html-webpack-plugin&lt;/code&gt;的钩子函数&lt;code&gt;beforeEmit&lt;/code&gt;中，调用这个&lt;code&gt;Skeleton&lt;/code&gt;对象，&lt;/p&gt;

&lt;p&gt;&lt;code&gt;beforeEmit&lt;/code&gt;这个钩子函数的作用在于&lt;code&gt;html-webpack-plugin&lt;/code&gt;插件将生成的&lt;code&gt;html&lt;/code&gt;插入模板文件前进行的操作。这里就相当于在生成真正的&lt;code&gt;html&lt;/code&gt;代码之前调用生成骨架屏页面。&lt;/p&gt;

&lt;p&gt;3.调用&lt;code&gt;cb&lt;/code&gt;，传回&lt;code&gt;html&lt;/code&gt;内容&lt;/p&gt;

&lt;p&gt;4.需要注意的是，&lt;code&gt;replace&lt;/code&gt;中的需要替换的根元素、类名不要搞错了。&lt;/p&gt;

&lt;p&gt;其余的，根据不同的路径，入口可以将参数传入这个构造函数中，然后判断显示不同的骨架屏。最大的缺点就是复用性不强，也许会随着页面的迭代而经常变动，维护起来也很麻烦。&lt;/p&gt;

&lt;p&gt;还有些其他自动生成骨架屏的开源方案。比如饿了么开源的&lt;code&gt;page-skeleton-webpack-plugin&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;通过 &lt;a href=&#34;https://link.zhihu.com/?target=https%3A//github.com/GoogleChrome/puppeteer&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;puppeteer&lt;/a&gt; 在服务端操控 &lt;a href=&#34;https://link.zhihu.com/?target=https%3A//developers.google.com/web/updates/2017/04/headless-chrome&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;headless Chrome&lt;/a&gt; 打开开发中的需要生成骨架屏的页面，在等待页面加载渲染完成之后，在保留页面布局样式的前提下，通过对页面中元素进行删减或增添，对已有元素通过层叠样式进行覆盖，这样达到在不改变页面布局下，隐藏图片和文字，通过样式覆盖，使得其展示为灰色块。然后将修改后的 HTML 和 CSS 样式提取出来，这样就是骨架屏了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;它的大致原理，就是利用&lt;code&gt;puppeteer&lt;/code&gt;获取页面结构，将不同的节点分类处理，展现不同的&amp;rsquo;骨架效果&amp;rsquo;，最后实际渲染的时候，进行相应的替换。但是就针对于这个项目&lt;code&gt;page-skeleton-webpack-plugin&lt;/code&gt;来说，坑比较多，而且不支持&lt;code&gt;webpack4&lt;/code&gt;，慎重使用。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Webpack打包优化</title>
      <link>https://xtid.github.io/2020/webpack%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 07 Sep 2020 22:03:34 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/webpack%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/</guid>
      <description>&lt;p&gt;之前了解了&lt;code&gt;webpack&lt;/code&gt;的基本打包流程或者说原理，如果只是配置一个基本的&lt;code&gt;webpack&lt;/code&gt;打包配置，
打包后的文件会变得很大，当你项目部署后，用户打开对应的界面，也许会很长时间才加载完(当然和网络环境或硬件设备也有关系)，尤其是单页面应用效果很明显，这样的用户体验自然是不好的，所以此文章主要是对&lt;code&gt;webpack&lt;/code&gt;打包优化的一个小小总结&lt;/p&gt;

&lt;p&gt;首先搭建好一个基本的项目，目录结构&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;├── dist // 打包目录
│   ├── bundle.js // 打包后的js
│   └── index.html // 入口html文件
├── package-lock.json
├── package.json
├── public
│   └── index.html // html模板文件
├── src
│   ├── actions // redux actions文件
│   │   └── index.js
│   ├── app.js // webpack打包入口文件，也是项目的入口文件
│   ├── assets // scss
│   │   ├── about.scss
│   │   ├── title.scss
│   │   └── user.scss
│   ├── dev.js // 开发时的一些配置
│   ├── pages // page页面
│   │   ├── about.jsx
│   │   ├── index.jsx
│   │   ├── title.jsx
│   │   └── user.jsx
│   ├── reducers // redux中的reducer
│   │   └── index.js
│   └── store.js
└── webpack.config.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt;基本配置如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const path = require(&#39;path&#39;)
const HtmlWebPackPlugin = require(&#39;html-webpack-plugin&#39;)

module.exports = {
  entry: &#39;./src/app.js&#39;,
  output: {
    path: path.resolve(__dirname, &#39;./dist/&#39;),
    filename: &#39;bundle.js&#39;
  },
  resolve: {
    extensions: [&#39;.wasm&#39;, &#39;.mjs&#39;, &#39;.js&#39;, &#39;.json&#39;, &#39;.jsx&#39;]
  },

  devServer: {
    contentBase: path.join(__dirname, &#39;./src/&#39;),
    publicPath: &#39;/&#39;,
    host: &#39;127.0.0.1&#39;,
    port: 3000,
    hot: true,
    stats: {
      colors: true
    }
  },
  module: {
    rules: [{
      test: /\.jsx?$/,
      exclude: /node_modules/,
      use: {
        loader: &#39;babel-loader&#39;
      }
    }, {
      test: /\.scss$/,
      use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;]
    }]
  },
  plugins: [
    new HtmlWebPackPlugin({
      template: &#39;public/index.html&#39;,
      filename: &#39;index.html&#39;,
      inject: true
    })
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优化：&lt;/p&gt;

&lt;p&gt;1.基础优化&lt;/p&gt;

&lt;p&gt;配置&lt;code&gt;loader&lt;/code&gt;，添加&lt;code&gt;exclude&lt;/code&gt;、&lt;code&gt;include&lt;/code&gt;缩小搜索范围，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  test: /\.jsx?$/,
    exclude: /node_modules/, // 过滤node_modules
      use: {
        loader: &#39;babel-loader&#39;
      }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.使用&lt;code&gt;DllPlugin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;将一些变动较少或者根本不会变动的库先打包生成对应的&lt;code&gt;.dll.js&lt;/code&gt;，在&lt;code&gt;webpack&lt;/code&gt;打包的时候，将这些资源引入&lt;/p&gt;

&lt;p&gt;首先新建一个&lt;code&gt;webpack.config.dll.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const path = require(&#39;path&#39;);
const DllPlugin = require(&#39;webpack/lib/DllPlugin&#39;);

module.exports = {
  entry: {
    react: [&#39;react&#39;, &#39;react-dom&#39;]
  },
  output: {
    filename: &#39;[name].dll.js&#39;,
    // 生成的文件目录
    path: path.resolve(__dirname, &#39;dist&#39;),
    // 动态链接库名称
    library: &#39;_dll_[name]&#39;
  },
  plugins: [
    new DllPlugin({
      name: &#39;_dll_[name]&#39;,
      path: path.join(__dirname, &#39;dist&#39;, &#39;[name].manifest.json&#39;),
      context: __dirname, 
    })
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在&lt;code&gt;package.json&lt;/code&gt;的&lt;code&gt;scripts&lt;/code&gt;中添加dll打包命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;webpack --config webpack.config.dll.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后运行此命令，可以看到会在&lt;code&gt;dist&lt;/code&gt;目录下面生成&lt;code&gt;react.dll&lt;/code&gt;，&lt;code&gt;react.manifest.json&lt;/code&gt;两个文件，这就是生成的&lt;code&gt;dll&lt;/code&gt;文件，然后&lt;code&gt;webpack.config.js&lt;/code&gt;里面添加配置，打包时引入这些的&lt;code&gt;dll&lt;/code&gt;文件。&lt;/p&gt;

&lt;p&gt;首先安装插件&lt;code&gt;add-asset-html-webpack-plugin&lt;/code&gt;，引入&lt;code&gt;DllReferencePlugin&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const DllReferencePlugin = require(&#39;webpack/lib/DllReferencePlugin&#39;)
const AddAssetHtmlPlugin = require(&#39;add-asset-html-webpack-plugin&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;插件里面配置(webpack4+)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;new DllReferencePlugin({
  context: __dirname,
  manifest: require(&#39;./dist/react.manifest.json&#39;),
}),
new AddAssetHtmlPlugin({
  filepath: path.resolve(__dirname, &#39;./dist/react.dll.js&#39;)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样打包时页面就会引入&lt;code&gt;react.dll.js&lt;/code&gt;资源了，从而减少重复的资源打包。这种方式可以简单的理解为，抽出公共模块打包，然后引入&lt;/p&gt;

&lt;p&gt;3.&lt;code&gt;splitChunks&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以前&lt;code&gt;webpack&lt;/code&gt;拆分模块还会用&lt;code&gt;CommonsChunkPlugin&lt;/code&gt;，在&lt;code&gt;webpack4&lt;/code&gt;后，可以直接用&lt;code&gt;splitChunks&lt;/code&gt;来代替完成这项工作，在&lt;code&gt;optimization&lt;/code&gt;里面设置了&lt;code&gt;splitChunks&lt;/code&gt;后，打包分割出来的文件是默认压缩过的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;splitChunks: {
  chunks: &amp;quot;async&amp;quot;, // &amp;quot;initial&amp;quot; | &amp;quot;all&amp;quot; | &amp;quot;async&amp;quot;，对哪种代码进行分割
  minSize: 30000, // 超过minSize的包才做代码分割
  minChunks: 1, // 一个包至少被用了多少次的时候才进行代码分割
  maxAsyncRequests: 5, // 按需加载最多能加载多少个模块
  maxInitialRequests: 3, // 对于entry里面的文件做代码分割最多能生成多少个js文件
  automaticNameDelimiter: &#39;~&#39;, // 文件生成时的连接符
  name: true, // 为true的时候，打包出来的文件名由cacheGroups里面设置的为准
  cacheGroups: {
    vendors: {
      test: /[\\/]node_modules[\\/]/, // 匹配哪些需要分割的模块
      priority: -10, // 优先级
     	filename: &#39;vendors.js&#39;// 打包到一个叫vendors.js的文件
    },
    default: {
      minChunks: 2,
      priority: -20,
      reuseExistingChunk: true
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.&lt;code&gt;catch-loader&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在一些性能开销较大的&lt;code&gt;loader&lt;/code&gt;之前添加此 &lt;code&gt;loader&lt;/code&gt;，以将结果缓存到磁盘里，不做过多介绍&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
  module: {
    rules: [
      {
        test: /\.ext$/,
        use: [
          &#39;cache-loader&#39;,
          ...loaders
        ],
        include: path.resolve(&#39;src&#39;)
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.&lt;code&gt;HappyPack&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HappyPack&lt;/code&gt;使用&lt;code&gt;node&lt;/code&gt;多线程进行构建来提升构建的速度，使用情况较少&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const HappyPack = require(&#39;happypack&#39;)
const os = require(&#39;os&#39;)
const happyThreadPool = HappyPack.ThreadPool({
  size: os.cpus().length
})

......
plugins: [
  new HtmlWebPackPlugin({
    template: &#39;public/index.html&#39;,
    filename: &#39;index.html&#39;,
    inject: true
  }),
  new HappyPack({
    id: &#39;happyBabel&#39;,
    loaders: [{
      loader: &#39;babel-loader?cacheDirectory=true&#39;,
    }],
    threadPool: happyThreadPool,
    verbose: true,
  })
],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.&lt;code&gt;css&lt;/code&gt;的压缩&lt;/p&gt;

&lt;p&gt;对于&lt;code&gt;scss&lt;/code&gt;文件，一般来讲，依次配置&lt;code&gt;sass-loader&lt;/code&gt;、&lt;code&gt;css-loader&lt;/code&gt;、&lt;code&gt;style-loader&lt;/code&gt;来进行处理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  test: /\.scss$/,
  use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后加载完后的页面&lt;code&gt;css&lt;/code&gt;会以内联样式的形式签入到页面中。在&lt;code&gt;webpack4&lt;/code&gt;中使用&lt;code&gt;mini-css-extract-plugin&lt;/code&gt;插件来提取、压缩&lt;code&gt;css&lt;/code&gt;。首先将&lt;code&gt;style-loade&lt;/code&gt;用&lt;code&gt;MiniCssExtractPlugin.loader&lt;/code&gt;代替，然后使用&lt;code&gt;MiniCssExtractPlugin&lt;/code&gt;插件，打包出对应的文件，并在页面中引入对应的&lt;code&gt;css&lt;/code&gt;文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;)

......

{
  test: /\.scss$/,
  use: [MiniCssExtractPlugin.loader, &#39;css-loader&#39;, &#39;sass-loader&#39;]
}

new MiniCssExtractPlugin({
  filename: &#39;[name].[hash:5].css&#39;,
  chunkFilename: &#39;[id].[hash:5].css&#39;
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.图片的处理&lt;/p&gt;

&lt;p&gt;同样的，先用&lt;code&gt;file-loader&lt;/code&gt;解析图片保证webpack能处理，然后可以用&lt;code&gt;image-webpack-loader&lt;/code&gt;压缩图片，或者说用&lt;code&gt;url-loader&lt;/code&gt;将图片转为&lt;code&gt;base64&lt;/code&gt;编码的形式，不多赘述&lt;/p&gt;

&lt;p&gt;8.CDN加速
通常在打包中，把不变的一些静态文件放到&lt;code&gt;CDN&lt;/code&gt;上，可以直观地减小资源包大小，比如项目中用到了&lt;code&gt;clipboard.js&lt;/code&gt;，然后在模板&lt;code&gt;html&lt;/code&gt;中引入这个文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;script src=&amp;quot;https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.6/clipboard.min.js&amp;quot; defer&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般来讲，这种方式引入js静态文件，那么全局对象(如window)里面是会有对应的对象的，就可以直接引用对应的对象。当然还可以加上&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;externals: {
  clipboard: &#39;clipboard&#39;
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就保证了打包时不打包&lt;code&gt;clipboard&lt;/code&gt;，优化打包后的文件体积&lt;/p&gt;

&lt;p&gt;还有一种方式就是把所有的静态资源，如&lt;code&gt;js&lt;/code&gt;、&lt;code&gt;css&lt;/code&gt;都放在相应的&lt;code&gt;CDN&lt;/code&gt;上，在打包的&lt;code&gt;config&lt;/code&gt;中指定对应资源的&lt;code&gt;CDN&lt;/code&gt;域名，同样配置&lt;code&gt;externals&lt;/code&gt;。但其实这种方式有个很大的缺点就是，如果全部这样做的话，万一&lt;code&gt;CDN&lt;/code&gt;挂了，整个页面也就挂了&lt;/p&gt;

&lt;p&gt;9.按需加载&lt;/p&gt;

&lt;p&gt;以&lt;code&gt;react&lt;/code&gt;为例，使用&lt;code&gt;react-loadable&lt;/code&gt;来做按需加载，以前还有些其它方法这里就不赘述。主要是针对&lt;code&gt;react-router&lt;/code&gt;做一个处理，首先安装依赖&lt;code&gt;react-loadable&lt;/code&gt;，入口文件中封装一个&lt;code&gt;loading&lt;/code&gt;组件，用于页面加载时给一个提示，然后封装一个方法，用于异步加载这些组件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import Loadable from &#39;react-loadable&#39;
const Loading = (props) =&amp;gt; {
  return &amp;lt;div&amp;gt;这是一个loading组件&amp;lt;/div&amp;gt;
};
const asyncLoad = loader =&amp;gt; Loadable({
  loader,
  loading: Loading
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下有三个页面，&lt;code&gt;index&lt;/code&gt;、&lt;code&gt;about&lt;/code&gt;、&lt;code&gt;user&lt;/code&gt;，调用&lt;code&gt;asyncLoad&lt;/code&gt;，引入这些文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const Index = asyncLoad(() =&amp;gt; import(&#39;./pages/index&#39;))
const About = asyncLoad(() =&amp;gt; import(&#39;./pages/about&#39;))
const User = asyncLoad(() =&amp;gt; import(&#39;./pages/user&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再配置好路由，这样打包出来的&lt;code&gt;js&lt;/code&gt;文件就只会在对应页面或者说对应路由命中时加载了，从而提升页面的一个加载速度，当然也把打包出来的js文件进一步的分割，减小体积，当然需要注意的是，要在&lt;code&gt;webpack.config&lt;/code&gt;里面配置好&lt;code&gt;chunFilename(按需加载的chunk名字)&lt;/code&gt;，资源的&lt;code&gt;publickPath&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;Router&amp;gt;
  &amp;lt;Switch&amp;gt;
  	&amp;lt;Route path=&amp;quot;/&amp;quot; exact component={Index} /&amp;gt;
    &amp;lt;Route path=&amp;quot;/about/&amp;quot; component={About} /&amp;gt;
    &amp;lt;Route path=&amp;quot;/users/&amp;quot; component={User} /&amp;gt;
  &amp;lt;/Switch&amp;gt;
&amp;lt;/Router&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;webpack.config.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;output: {
  path: path.resolve(__dirname, &#39;./dist/&#39;),
  filename: &#39;[name].[hash:5].bundle.js&#39;,
  chunkFilename: &#39;[name].[hash:5].bundle.js&#39;,
  publicPath: &#39;/&#39;
},
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Webpack简单理解</title>
      <link>https://xtid.github.io/2020/webpack%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</link>
      <pubDate>Sun, 23 Aug 2020 21:36:20 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/webpack%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</guid>
      <description>&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt;是一个模块打包器，老一点的还有&lt;code&gt;gulp&lt;/code&gt;、&lt;code&gt;grunt&lt;/code&gt;等等，
他最显著的特点就是将文件视为一个个模块，通过设置入口文件&lt;code&gt;entry&lt;/code&gt;，加载不同类型的文件用不同&lt;code&gt;loader&lt;/code&gt;转换文件，
然后使用不同&lt;code&gt;plugin&lt;/code&gt;对文件处理，最后输出多个打包、分割后的文件&lt;/p&gt;

&lt;p&gt;首先有几个概念
1.entry：即&lt;code&gt;webpack&lt;/code&gt;打包的入口，告诉它应该从那个文件开始进行构建
2.output：设置打包后文件的输出路径以及如何命名这些文件
3.loader：处理那些非&lt;code&gt;javaScript&lt;/code&gt;文件，通过指定对应文件所需的对应&lt;code&gt;loader&lt;/code&gt;的处理，将文件转换为&lt;code&gt;webpack&lt;/code&gt;能够处理的有效模块
4.plugins：转换某些类型的模块，功能强大，可以做到打包优化，压缩以及各种各样的其它任务&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bundle&lt;/code&gt;：视为&lt;code&gt;webpack&lt;/code&gt;打包提取的模块生成的&lt;code&gt;js&lt;/code&gt;文件，将其它具体模块的代码传入其中执行，原本独立的模块文件，通过调用&lt;code&gt;__webpack_require__&lt;/code&gt;，合并到了&lt;code&gt;bundle&lt;/code&gt;中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function(modules) {
/******/    var installedModules = {};
/******/
/******/    var installedChunks = {
/******/        2: 0
/******/    };
/******/
/******/    function __webpack_require__(moduleId) {
/******/
/******/        if(installedModules[moduleId]) {
/******/            return installedModules[moduleId].exports;
/******/        }
/******/        var module = installedModules[moduleId] = {
/******/            i: moduleId,
/******/            l: false,
/******/            exports: {}
/******/        };
/******/
/******/        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/        module.l = true;
/******/
/******/        return module.exports;
/******/    }
/******/ })
/************************************************************************/
/******/ ({
	// 传入的模块
	......
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打包后的&lt;code&gt;bundle&lt;/code&gt;是一个立即执行的匿名函数，其参数就是打包后的模块，上面&lt;code&gt;__webpack_require__&lt;/code&gt;方法会首先判断当前模块&lt;code&gt;moduleId&lt;/code&gt;是否已经存在缓存&lt;code&gt;installedModules&lt;/code&gt;中，若是存在则直接返回。若是不存在，则会构造一个对象并将其同时存到&lt;code&gt;installedModules&lt;/code&gt;中和&lt;code&gt;module&lt;/code&gt;中&lt;/p&gt;

&lt;p&gt;&lt;code&gt;modules[moduleId].call(module.exports, module, module.exports, __webpack_require__)&lt;/code&gt;
这段代码首先执行当前模块的具体代码，传入&lt;code&gt;module&lt;/code&gt;，&lt;code&gt;module.exports&lt;/code&gt;，&lt;code&gt;__webpack_require__&lt;/code&gt;，递归调用&lt;code&gt;__webpack_require__&lt;/code&gt;处理每个模块种引入的其它模块
如以下形式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/***/ 0:
/***/ (function(module, exports, __webpack_require__) {
	......
	__webpack_require__(1);
	module.exports = __webpack_require__(2);
	......

/***/ })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个简单的bundle构建过程：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 引入相关依赖，对文件进行编译转换输出处理
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);
const parse = require(&#39;@babel/parser&#39;);
const traverse = require(&#39;@babel/traverse&#39;).default;
const babel = require(&#39;@babel/core&#39;);


let ID = 0;
// 读取文件信息，并获得当前js文件的依赖关系
function createAsset(filename) {
  // 获取文件，返回值是字符串
  const content = fs.readFileSync(filename, &#39;utf-8&#39;);

  // 将字符串转为ast
  const ast = parse.parse(content, {
    sourceType: &#39;module&#39;
  });

  //用来存储 文件所依赖的模块，简单来说就是，当前js文件 import 了哪些文件，都会保存在这个数组里
  const dependencies = [];

  //遍历当前ast（抽象语法树）
  traverse(ast, {
    //找到有 import语法 的对应节点
    ImportDeclaration: ({ node }) =&amp;gt; {
      //把当前依赖的模块加入到数组中
      dependencies.push(node.source.value);
    }
  });

  //模块的id 从0开始， 相当一个js文件 可以看成一个模块
  const id = ID++;

  //这边主要把ES6 的代码转成 ES5
  const { code } = babel.transformFromAstSync(ast, null, {
    presets: [&#39;@babel/preset-env&#39;]
  });

  return {
    id,
    filename,
    dependencies,
    code
  };
}

// 从入口开始分析所有依赖项，形成依赖图，采用广度遍历
function createGraph(entry) {
  const mainAsset = createAsset(entry);
    
  const queue = [mainAsset];

  for (const asset of queue) {
    const dirname = path.dirname(asset.filename);
    // 新增一个属性来保存子依赖项的数据
    asset.mapping = {};
    asset.dependencies.forEach(relativePath =&amp;gt; {
      const absolutePath = path.join(dirname, relativePath);
      //获得子依赖（子模块）的依赖项、代码、模块id，文件名
      const child = createAsset(absolutePath);
      //给子依赖项赋值，
      asset.mapping[relativePath] = child.id;
      //将子依赖也加入队列中，广度遍历
      queue.push(child);
    });
  }
  return queue;
}

//根据生成的依赖关系图，生成对应环境能执行的代码，目前是生产浏览器可以执行的
function bundle(graph) {
  let modules = &#39;&#39;;

  //循环依赖关系，并把每个模块中的代码存在function作用域里
  graph.forEach(mod =&amp;gt; {
    modules += `${mod.id}:[
      function (require, module, exports){
        ${mod.code}
      },
      ${JSON.stringify(mod.mapping)},
    ],`;
  });

  //require, module, exports 是 cjs的标准不能再浏览器中直接使用，所以这里模拟cjs模块加载，执行，导出操作。
  const result = `
    (function(modules){
      //创建require函数， 它接受一个模块ID（这个模块id是数字0，1，2） ，它会在我们上面定义 modules 中找到对应是模块.
      function __webpack_require__(id){
        const [fn, mapping] = modules[id];
        function localRequire(relativePath){
          //根据模块的路径在mapping中找到对应的模块id
          return __webpack_require__(mapping[relativePath]);
        }
        const module = {exports:{}};
        //执行每个模块的代码。
        fn(localRequire,module,module.exports);
        return module.exports;
      }
      //执行入口文件，
      __webpack_require__(0);
    })({${modules}})
  `;

  return result;
}

// 入口文件
const graph = createGraph(&#39;./entry.js&#39;);
// 文件内容
const ret = bundle(graph);

// 打包生成文件
fs.writeFileSync(&#39;./bundle.js&#39;, ret);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;loader&lt;/code&gt;，通过设置对应的&lt;code&gt;rule&lt;/code&gt;，使用不同的&lt;code&gt;loader&lt;/code&gt;来转换、处理不同的组件，比如&lt;code&gt;css&lt;/code&gt;文件使用&lt;code&gt;css-loader&lt;/code&gt;以及&lt;code&gt;style-loader&lt;/code&gt;来处理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  test: /\.css$/,
  loader: &#39;style-loader!css-loader&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外，还有一种内联&lt;code&gt;loader&lt;/code&gt;的形式，即&lt;code&gt;import loader from &#39;......&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;两种方式处理的顺序也不同，大致流程为
1.&lt;code&gt;webpack&lt;/code&gt;启动后，创建新的&lt;code&gt;compilation&lt;/code&gt;
2.实例化&lt;code&gt;rules&lt;/code&gt;
3.解析&lt;code&gt;inline loaders&lt;/code&gt;
4.解析&lt;code&gt;config&lt;/code&gt;配置里面的&lt;code&gt;loaders&lt;/code&gt;
5.组合这两种形式的&lt;code&gt;loader&lt;/code&gt;，最终输出上诉第一种形式的配置
6.使用&lt;code&gt;Loader-runner&lt;/code&gt;按配置执行&lt;code&gt;loader&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以下简单写一个&lt;code&gt;loader&lt;/code&gt;，首先写一个方法用于加载&lt;code&gt;loader&lt;/code&gt;，并处理传入的模块，然后返回处理完了之后的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let source = ...... // source为获取到的模块的代码
function loaderModule(loaderName) {
  // 获取loader路径
  const loaderPath = path.join(process.cwd(), loaderName)
  const loader = require(loaderPath)
  source = loader.call(_this, source)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义一个规则&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;rules: [{
  test:/\.js/,
  use:[
    &#39;./loaderModule.js&#39;, // loader的路径
  ]
}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行的时候遍历&lt;code&gt;rules&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;for (let i = rules.length - 1; i &amp;gt;= 0; i--) {
  const { test, use } = rules[i]
  if (test.test(modulePath)) {
    // 使用多个loader
    if (Array.isArray(use)) {
      for (let j = use.length - 1; j &amp;gt;= 0; j--) {
        loaderModule(use[j])
      }
    } else if (typeof use === &#39;string&#39;) {
      loaderModule(use)
      // 带参数型的loader
    } else if (use instanceof Object) {
      loaderModule(use.loader, {
        query: use.options
      })
    }
  }
}

// loaderModule.js内容
// loader-utils是webpack一个工具类，用于解析loader，获取配置的一些loader参数
const loaderUtils = require(&#39;loader-utils&#39;)

// 这个简单的loader会将js文件里面的hello字符串替换成word
module.exports = function (source) {
  const optionsName = loaderUtils.getOptions(this) &amp;amp;&amp;amp; loaderUtils.getOptions(this).name || &#39;world&#39;
  return source.replace(/hello/g, optionsName)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面是一个同步的&lt;code&gt;loader&lt;/code&gt;，如果想写一个异步的&lt;code&gt;loader&lt;/code&gt;，可以在&lt;code&gt;loader&lt;/code&gt;内部调用&lt;code&gt;async&lt;/code&gt;方法，然后在处理之后调用对应的回调方法处理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = function (source) {
  const optionsName = loaderUtils.getOptions(this) &amp;amp;&amp;amp; loaderUtils.getOptions(this).name || &#39;world&#39;
  cosnt callback = this.async()

  // 操作完了之后，调用callback返回结果进入下一个loader
  asyncOperation(source, optionsName, function(err, result) {
    if（err）return callback(err)
    callback(err, result)
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不用上面的方式，返回一个&lt;code&gt;promise&lt;/code&gt;也是可以的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = function (source) {
  const optionsName = loaderUtils.getOptions(this) &amp;amp;&amp;amp; loaderUtils.getOptions(this).name || &#39;world&#39;
  return new Promise(resolve =&amp;gt; {
    asyncOperation(source, function(err, result) {
      if (err) resolve(err)
      resolve(err, result)
    })
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;plugin&lt;/code&gt;
&lt;code&gt;plugin&lt;/code&gt;进一步拓展了&lt;code&gt;webpack&lt;/code&gt;的功能，比如打包优化和压缩，清空当前项目的目录，重新定义环境变量，将代码输出到某个文件，提取功能模块等等&lt;/p&gt;

&lt;p&gt;定义一个&lt;code&gt;plugin&lt;/code&gt;的时候，首先要提供一个&lt;code&gt;apply&lt;/code&gt;方法，接受一个&lt;code&gt;compiler&lt;/code&gt;对象，然后注册对应的钩子函数，在回调里面拿到对应参数，然后处理
以下定义一个&lt;code&gt;plugin&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const path = require(&#39;path&#39;)
const fs = require(&#39;fs&#39;)
const cheerio = require(&#39;cheerio&#39;)

class BasePlugin {
  constructor(options){
    // 插件的参数，filename、template等
    this.options = options
  }
  apply(compiler) {
    // 注册afterEmit钩子函数
    compiler.hooks.afterEmit.tap(&#39;BasePlugin&#39;, (compilation) =&amp;gt; {
      // 2. 根据模板读取html文件内容
      const result = fs.readFileSync(this.options.template, &#39;utf-8&#39;)
      
      // 3. 使用 cheerio 来分析 HTML
      let $ = cheerio.load(result)
    
      // 4. 创建 script 标签后插入HTML中
      // compilation.assets代表所有输出的资源文件
      Object.keys(compilation.assets).forEach(item =&amp;gt; {
        $(`&amp;lt;script src=&amp;quot;/${item}&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;`).appendTo(&#39;body&#39;)
      })
    
      // 5. 转换成新的HTML并写入到 dist 目录中
      fs.writeFileSync(path.join(process.cwd(), &#39;dist&#39;, this.options.filename), $.html())
    })
  } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;compiler&lt;/code&gt;对象包含了&lt;code&gt;webpack&lt;/code&gt;环境所有的的配置信息，包含&lt;code&gt;options&lt;/code&gt;，&lt;code&gt;loaders&lt;/code&gt;，&lt;code&gt;plugins&lt;/code&gt;这些信息，这个对象在&lt;code&gt;webpack&lt;/code&gt;启动时候被实例化，它是全局唯一的，可以简单地把它理解为&lt;code&gt;webpack&lt;/code&gt;实例，&lt;code&gt;compilation&lt;/code&gt;对象包含了当前的模块资源、编译生成资源、变化的文件等。当&lt;code&gt;webpack&lt;/code&gt;以开发模式运行时，每当检测到一个文件变化，&lt;code&gt;compilation&lt;/code&gt;就会被重新构建，其它的一些&lt;a href=&#34;https://www.webpackjs.com/api/compiler-hooks/#hooks&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;钩子函数&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;顺便总结一下，实现一个简单的&lt;code&gt;webpack&lt;/code&gt;的步骤
1.定一个基础对象，构造方法里面传入&lt;code&gt;entry&lt;/code&gt;、&lt;code&gt;output&lt;/code&gt;、&lt;code&gt;rules&lt;/code&gt;、&lt;code&gt;plugins&lt;/code&gt;等属性
2.然后定义一系列钩子函数，在&lt;code&gt;webpack&lt;/code&gt;执行中可以调用这些钩子函数做处理，
3.开始执行，初始化对应的钩子函数，传入&lt;code&gt;entry&lt;/code&gt;等相关信息
4.拿到文件源码信息，使用&lt;code&gt;loader&lt;/code&gt;处理，将代码转换成&lt;code&gt;ast&lt;/code&gt;形式
5.&lt;code&gt;traverse&lt;/code&gt;将&lt;code&gt;ast&lt;/code&gt;代码中的&lt;code&gt;require&lt;/code&gt;替换为&lt;code&gt;__webpack_require__&lt;/code&gt;，添加新的&lt;code&gt;module&lt;/code&gt;信息
6.递归处理每一个依赖，重复上面的步骤
7.初始化&lt;code&gt;plugin&lt;/code&gt;，并对文件做处理
8.输入到指定目录
9.客户端/浏览器运行时执行&lt;/p&gt;

&lt;p&gt;参考链接&lt;/p&gt;

&lt;p&gt;1.&lt;a href=&#34;https://juejin.im/post/6844903957769224206&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;webpack原理&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&#34;https://www.webpackjs.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;webpack官方文档&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Babel简介</title>
      <link>https://xtid.github.io/2020/babel%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sun, 23 Aug 2020 21:32:52 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/babel%E7%AE%80%E4%BB%8B/</guid>
      <description>

&lt;h3 id=&#34;1-babel-简介&#34;&gt;1.babel 简介&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Babel是现代JavaScript语法转换器，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中，包括不限于: eslint jsx vue-template等等。他能为你做的：语法转换、通过 Polyfill 方式在目标环境中添加缺失的特性、源码转换。可以说，通过babel，我们可以使用最新的语法或者特性专注的开发业务，而不用将精力花在代码的兼容上&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;2-babel的解析流程&#34;&gt;2.babel的解析流程&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/xtid/blog/blob/master/static/img/deal_process.png&#34; alt=&#34;babel处理流程&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-1词法解析&#34;&gt;2.1词法解析&lt;/h4&gt;

&lt;p&gt;首先由入口文件&lt;code&gt;@babel/core&lt;/code&gt;引入各种配置文件以及解析的模块，其中负责解析基本语法的为&lt;code&gt;parse&lt;/code&gt;模块，其中就定义了&lt;code&gt;词法解析器Tokenizer&lt;/code&gt;，可以看出初始化时会有一个&lt;code&gt;tokens&lt;/code&gt;数组，在这个阶段会把字符串形式的代码转换为一个数组，&lt;code&gt;tokens可以视为由拆分为各个片段组成的数组&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Tokenizer extends LocationParser {
  constructor(options, input) {
    super();
    this.tokens = [];
    this.state = new State();
    this.state.init(options);
    this.input = input;
    this.length = input.length;
    this.isLookahead = false;
  }
	
  ....
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;Tokenizer&lt;/code&gt;定义中还有一些其它的方法，他们会对各种语法字符串进行一个遍历过滤，比如跳过空格字符串，比如跳过注释等等&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;skipSpace() {
  loop: while (this.state.pos &amp;lt; this.length) {
    const ch = this.input.charCodeAt(this.state.pos);
    .
    .
    .
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后会把符合规则的语法字符串加入到&lt;code&gt;tokens&lt;/code&gt;数组中，也就生成代码拆分为各个片段组成的数组&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;pushToken(token) {
  this.tokens.length = this.state.tokensLength;
  this.tokens.push(token);
  ++this.state.tokensLength;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.log(&#39;我是一段语法&#39;) =&amp;gt; [&#39;console&#39;, &#39;log&#39;, &#39;(&#39;, &#39;&amp;quot;我是一段语法&amp;quot;&#39;, &#39;)&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-2语法解析&#34;&gt;2.2语法解析&lt;/h4&gt;

&lt;p&gt;当生成完&lt;code&gt;tokens&lt;/code&gt;，则进入到语法解析阶段，同样可以看见在&lt;code&gt;parse&lt;/code&gt;模块中定一个了一个&lt;code&gt;Node&lt;/code&gt;对象，这个对象定义了一些属性，当然还有个私有的&lt;code&gt;_clone&lt;/code&gt;方法，用于表示将要生成的&lt;code&gt;AST&lt;/code&gt;中节点的位置、名称、类型等等信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Node {
  constructor(parser, pos, loc) {
    this.type = &amp;quot;&amp;quot;;
    this.start = pos;
    this.end = 0;
    this.loc = new SourceLocation(loc);
    if (parser &amp;amp;&amp;amp; parser.options.ranges) this.range = [pos, 0];
    if (parser &amp;amp;&amp;amp; parser.filename) this.loc.filename = parser.filename;
  }

  __clone() {
    .
    .
    .
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后会定义相应的&lt;code&gt;Parse&lt;/code&gt;，遍历处理不同的&lt;code&gt;tokens&lt;/code&gt;字段，比如&lt;code&gt;ImportDeclaration&lt;/code&gt;用于import语法，导入模块；&lt;code&gt;VariableDeclarator&lt;/code&gt;用于处理表示是什么类型的变量声明，比如&lt;code&gt;var、let、const&lt;/code&gt;；&lt;code&gt;FunctionDeclaration&lt;/code&gt;用于处理函数声明，非函数表达式，其它的就不多赘述。最后则会将这个词法数组转换为&lt;code&gt;AST(抽象语法树)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var add = function(a, b) {
  return  a + b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后生成的&lt;code&gt;AST&lt;/code&gt;简易版本如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  &amp;quot;type&amp;quot;: &amp;quot;Program&amp;quot;,
  &amp;quot;body&amp;quot;: [{
    &amp;quot;type&amp;quot;: &amp;quot;VariableDeclaration&amp;quot;,
    &amp;quot;identifierName&amp;quot;: &amp;quot;add&amp;quot;,
    &amp;quot;init&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;ArrowFunctionExpression&amp;quot;,
      &amp;quot;params&amp;quot;: [{
          &amp;quot;type&amp;quot;: &amp;quot;identifier&amp;quot;,
          &amp;quot;identifierName&amp;quot;: &amp;quot;a&amp;quot;
        },
        {
          &amp;quot;type&amp;quot;: &amp;quot;identifier&amp;quot;,
          &amp;quot;identifierName&amp;quot;: &amp;quot;b&amp;quot;
        }
      ],
      &amp;quot;body&amp;quot;: {
        &amp;quot;type&amp;quot;: &amp;quot;BinaryExpression&amp;quot;,
        &amp;quot;left&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;identifier&amp;quot;,
          &amp;quot;identifierName&amp;quot;: &amp;quot;a&amp;quot;
        },
        &amp;quot;operator&amp;quot;: &amp;quot;+&amp;quot;,
        &amp;quot;right&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;identifier&amp;quot;,
          &amp;quot;identifierName&amp;quot;: &amp;quot;b&amp;quot;
        }
      }
    }
  }]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出这个语法树包含了整个语法的一个层级关系，并且标注了他们的名称、类型以及位置&lt;/p&gt;

&lt;h4 id=&#34;2-3traverser&#34;&gt;2.3Traverser&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Traverser&lt;/code&gt;会对生成好&lt;code&gt;AST&lt;/code&gt;进行一个遍历，在此过程中对节点进行添加、删除等等操作，这也是其他插件将要处理的地方，通过这些插件，也可以处理不同的&lt;code&gt;AST&lt;/code&gt;语法树，然后转换符合相应规则的代码，比如&lt;code&gt;Taro&lt;/code&gt;，就可以视为将&lt;code&gt;React&lt;/code&gt;代码转换成小程序对应代码的一个插件。&lt;code&gt;Traverser&lt;/code&gt;中会引入&lt;code&gt;visitors&lt;/code&gt;，用它来进行一个深度遍历操作；&lt;code&gt;Path&lt;/code&gt;用于关联各个节点，这样使得节点操作简单，例如：&lt;/p&gt;

&lt;p&gt;例如，如果有下面这样一个节点及其子节点︰&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  type: &amp;quot;ArrowFunctionExpression&amp;quot;,
  id: {
    type: &amp;quot;Identifier&amp;quot;,
    name: &amp;quot;a&amp;quot;
  },
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将子节点 &lt;code&gt;Identifier&lt;/code&gt; 表示为一个路径（Path）的话，看起来是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  &amp;quot;parent&amp;quot;: {
    &amp;quot;type&amp;quot;: &amp;quot;ArrowFunctionExpression&amp;quot;,
    &amp;quot;id&amp;quot;: {...},
    ....
  },
  &amp;quot;node&amp;quot;: {
    &amp;quot;type&amp;quot;: &amp;quot;Identifier&amp;quot;,
    &amp;quot;name&amp;quot;: &amp;quot;a&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Scope&lt;/code&gt;用来表示树中各个节点的一个作用域关系，就好像&lt;code&gt;js&lt;/code&gt;语法中，创建变量、函数时所呈现的一个作用域效果，在&lt;code&gt;babel&lt;/code&gt;中，新添加的引用或者变量名，&lt;code&gt;Scope&lt;/code&gt;表示的时候需要体现出节点的路径，节点间的关系，如以下形式:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  path: path,
  block: path.node,
  parentBlock: path.parent,
  parent: parentScope,
  bindings: [...]
  .
  .
  .
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有个很重要的概念&lt;code&gt;Bindings&lt;/code&gt;，&lt;code&gt;Bindings&lt;/code&gt;可以获取当前作用域下所有的标识符，其返回的信息包括节点的&lt;code&gt;标识符&lt;/code&gt;、&lt;code&gt;scope&lt;/code&gt;、&lt;code&gt;path&lt;/code&gt;、&lt;code&gt;引用&lt;/code&gt;等等信息，通过对这些属性的操作，达到对节点信息的一个更改&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export class Binding {
  identifier: t.Identifier;
  scope: Scope;
  path: NodePath;
  kind: &amp;quot;var&amp;quot; | &amp;quot;let&amp;quot; | &amp;quot;const&amp;quot; | &amp;quot;module&amp;quot;;
  referenced: boolean;
  references: number;              // 被引用的数量
  referencePaths: NodePath[];      // 获取所有应用该标识符的节点路径
  constant: boolean;               // 是否是常量
  constantViolations: NodePath[];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-4transform&#34;&gt;2.4Transform&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;transform&lt;/code&gt;会对抽象语法树进行又一次遍历，针对已经处理好的&lt;code&gt;AST&lt;/code&gt;做进一步处理，如对代码的更改，对节点的操作、节点的增删改查、压缩代码、删除注释等等。得到最终的一个&lt;code&gt;AST&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-5生成代码&#34;&gt;2.5生成代码&lt;/h4&gt;

&lt;p&gt;得到上一步生成的&lt;code&gt;AST&lt;/code&gt;之后，会调用对应的代码生成器代码，通过递归遍历生成最终的代码，其中遇到不同的节点类型时，会做不同的处理，比如函数类型、参数定义类型、代码块类型等等&lt;/p&gt;

&lt;h3 id=&#34;3-babel里面的一些依赖包&#34;&gt;3.babel里面的一些依赖包&lt;/h3&gt;

&lt;h4 id=&#34;3-1-babel-core&#34;&gt;3.1@babel/core&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;@babel/core&lt;/code&gt;整个&lt;code&gt;babel&lt;/code&gt;的一个核心，也算是&lt;code&gt;babel&lt;/code&gt;的一个入口，它会加载和处理用户定义的配置，加载各种各样的插件；调用&lt;code&gt;Parser&lt;/code&gt;进行语法解析，生成&lt;code&gt;Tokens&lt;/code&gt;以及&lt;code&gt;AST&lt;/code&gt;；调用&lt;code&gt;Traverser&lt;/code&gt;遍历&lt;code&gt;AST&lt;/code&gt;，进行一个转换；最后&lt;code&gt;generator&lt;/code&gt;生成源代码&lt;/p&gt;

&lt;h4 id=&#34;3-2插件&#34;&gt;3.2插件&lt;/h4&gt;

&lt;p&gt;语法插件：&lt;code&gt;babel&lt;/code&gt;有很多语法插件，用于支持&lt;code&gt;JavaScript&lt;/code&gt;的各种语法特性，在解析的时候会用的到，通常其形式为&lt;code&gt;@babel/plugin-syntax-*&lt;/code&gt;，比如&lt;code&gt;babel-plugin-syntax-dynamic-import&lt;/code&gt;就是用来处理&lt;code&gt;import&lt;/code&gt;语法的一个插件&lt;/p&gt;

&lt;p&gt;转换插件： 用于对 &lt;code&gt;AST&lt;/code&gt; 进行转换, 实现转换为&lt;code&gt;ES5&lt;/code&gt;代码、压缩、功能增强等目的，&lt;code&gt;babel&lt;/code&gt;仓库将转换插件划分为两种(只是命名上的区别)：&lt;/p&gt;

&lt;p&gt;如&lt;code&gt;@babel/plugin-transform-*&lt;/code&gt;： &lt;code&gt;babel&lt;/code&gt;中的一个转换插件&lt;/p&gt;

&lt;p&gt;预定义的插件：插件集合或者分组，可设置项目内所用插件的使用场景，主要方便用户对插件进行管理和使用。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@babel/preset-env&lt;/code&gt;：&lt;code&gt;preset-env&lt;/code&gt;是ES语法插件的合集，在根目录下创建&lt;code&gt;.babelrc&lt;/code&gt;配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt; {
   &amp;quot;presets&amp;quot;: [
     [&amp;quot;@babel/preset-env&amp;quot;, {
       &amp;quot;modules&amp;quot;: false,
       &amp;quot;targets&amp;quot;: {
         &amp;quot;browsers&amp;quot;: [&amp;quot;&amp;gt; 1%&amp;quot;, &amp;quot;last 2 versions&amp;quot;, &amp;quot;not ie &amp;lt;= 8&amp;quot;]
       },
       &amp;quot;useBuiltIns&amp;quot;: false,
       &amp;quot;corejs&amp;quot;: false
     }]
   ]
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;targets&lt;/code&gt;生成指定环境的代码，&lt;code&gt;useBuiltIns&lt;/code&gt;配合&lt;code&gt;@babel/polyfill&lt;/code&gt;使用，当然最新版的&lt;code&gt;babel&lt;/code&gt;可直接使用&lt;code&gt;corejs&lt;/code&gt;，填上对应的数值就行，&lt;code&gt;modules&lt;/code&gt;表示是否将代码ES6的模块语法转换为另一种类型或标准，比如&lt;code&gt;amd&lt;/code&gt;、&lt;code&gt;commonjs&lt;/code&gt;等&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@babel/polyfill&lt;/code&gt;顾名思义，在&lt;code&gt;babel&lt;/code&gt;转化的过程中，对于一些无法处理的特性或者属性，使用&lt;code&gt;@babel/polyfill&lt;/code&gt;来对这些功能进行处理；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@babel/runtime&lt;/code&gt;一般应用于两种场景：开发类库/工具（生成不污染全局空间和内置对象原型的代码）、借助 &lt;code&gt;@babel/runtime&lt;/code&gt; 中帮助函数（helper function）移除冗余工具函数，在最新的版本中，完全可以用&lt;code&gt;@babel/runtime&lt;/code&gt;代替&lt;code&gt;@babel/polyfill&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;3-3辅助开发工具&#34;&gt;3.3辅助开发工具&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;@babel/template&lt;/code&gt;： 某些场景直接操作&lt;code&gt;AST&lt;/code&gt;太麻烦，就比如我们直接操作&lt;code&gt;DOM&lt;/code&gt;一样，所以&lt;code&gt;babel&lt;/code&gt;实现了这么一个简单的模板引擎，可以将字符串代码转换为&lt;code&gt;AST&lt;/code&gt;。比如在生成一些辅助代码&lt;code&gt;(helper)&lt;/code&gt;时会用到这个库&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@babel/types&lt;/code&gt;： 主要用途是在创建&lt;code&gt;AST&lt;/code&gt;的过程中判断各种语法的类型。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@babel/helper-*&lt;/code&gt;： 一些辅助器，用于辅助插件开发，例如简化&lt;code&gt;AST&lt;/code&gt;操作&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@babel/helper&lt;/code&gt;： 辅助代码，单纯的语法转换可能无法让代码运行起来，比如低版本浏览器无法识别&lt;code&gt;class&lt;/code&gt;关键字，这时候需要添加辅助代码，对&lt;code&gt;class&lt;/code&gt;进行模拟。&lt;/p&gt;

&lt;h4 id=&#34;4-参考链接&#34;&gt;4.参考链接&lt;/h4&gt;

&lt;p&gt;1.&lt;a href=&#34;https://juejin.im/post/5d94bfbf5188256db95589be&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;深入浅出Babel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&#34;https://www.babeljs.cn/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;babel中文网&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.&lt;a href=&#34;https://github.com/jamiebuilds/babel-handbook&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;babel-handbook&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Vue中的patch</title>
      <link>https://xtid.github.io/2020/vue%E4%B8%AD%E7%9A%84patch/</link>
      <pubDate>Thu, 13 Aug 2020 00:12:17 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/vue%E4%B8%AD%E7%9A%84patch/</guid>
      <description>&lt;p&gt;在生成&lt;code&gt;vnode&lt;/code&gt;之后，可以通过&lt;code&gt;patch&lt;/code&gt;方法创建&lt;code&gt;DOM&lt;/code&gt;元素、进行&lt;code&gt;diff&lt;/code&gt;更新&lt;code&gt;DOM&lt;/code&gt;元素、销毁&lt;code&gt;DOM&lt;/code&gt;元素&lt;/p&gt;

&lt;p&gt;1.首先是第一次初始化时，生成了&lt;code&gt;vnode&lt;/code&gt;后，在&lt;code&gt;_update&lt;/code&gt;方法中调用&lt;code&gt;patch&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;vm.$el = vm.__patch__(
  vm.$el, vnode, hydrating, false
  // undefined
  vm.$options._parentElm,
  // undefined
  vm.$options._refElm
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时&lt;code&gt;vm.$el&lt;/code&gt;是挂载的根元素，&lt;code&gt;vnode&lt;/code&gt;是根元素对应的虚拟&lt;code&gt;Dom&lt;/code&gt;元素&lt;/p&gt;

&lt;p&gt;&lt;code&gt;patch&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    // 如果更新后的VNode不存在
    // 直接销毁旧的节点
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];
		
    if (isUndef(oldVnode)) {
      // 如果旧节点不存在
      // 创建VNode对应的元素
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      // oldValue是否是真实的DOM元素
      var isRealElement = isDef(oldVnode.nodeType);
      // 新旧节点相同
      if (!isRealElement &amp;amp;&amp;amp; sameVnode(oldVnode, vnode)) {
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // oldVNode类型为元素类型
          if (oldVnode.nodeType === 1 &amp;amp;&amp;amp; oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
      		......
          // 创建一个div空元素
          oldVnode = emptyNodeAt(oldVnode);
        }
				// oldElm代表真实的DOM元素
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);

        createElm(
          vnode,
          insertedVnodeQueue,
          oldElm._leaveCb ? null : parentElm$1,
          nodeOps.nextSibling(oldElm)
        );
				......
        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中调用了一个重要的方法&lt;code&gt;createElm&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  function createElm (
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
		......
    // VNode如果是一个组件，调用createComponent
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    // 如果tag是一个字符串，但非平台标签，也非自定义组件，抛错
    if (isDef(tag)) {
      if (process.env.NODE_ENV !== &#39;production&#39;) {
        if (data &amp;amp;&amp;amp; data.pre) {
          creatingElmInVPre++;
        }
        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn(
            &#39;Unknown custom element: &amp;lt;&#39; + tag + &#39;&amp;gt; - did you &#39; +
            &#39;register the component correctly? For recursive components, &#39; +
            &#39;make sure to provide the &amp;quot;name&amp;quot; option.&#39;,
            vnode.context
          );
        }
      }
			
      // setScope用户设置scoped CSS
      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

        var appendAsTree = isDef(data) &amp;amp;&amp;amp; isTrue(data.appendAsTree);
        if (!appendAsTree) {
          if (isDef(data)) {
            // 调用invokeCreateHooks
            // 此方法会处理directives、ref、attrs、class、domProps、on、style和show等一些属性
            // 如果VNode上有对应的狗子函数则会直接执行
            // 如果有insert方法，则把VNode添加到insertedVnodeQueue数组
            invokeCreateHooks(vnode, insertedVnodeQueue);
          }
          insert(parentElm, vnode.elm, refElm);
        }
      	// 递归处理子节点
        createChildren(vnode, children, insertedVnodeQueue);
        if (appendAsTree) {
          if (isDef(data)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
          }
          insert(parentElm, vnode.elm, refElm);
        }
      }

      if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; data &amp;amp;&amp;amp; data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      // 如果非保留标签，非自定义组件，并且是注释节点
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      // 创建文本节点
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在初始化时，&lt;code&gt;parentElm&lt;/code&gt;指的是&lt;code&gt;body&lt;/code&gt;，&lt;code&gt;refElm&lt;/code&gt;是当前节点的下一个兄弟元素&lt;/p&gt;

&lt;p&gt;2.上面说的是&lt;code&gt;Vue&lt;/code&gt;第一次加载页面时patch的操作，还有当页面绑定的数据修改后，&lt;code&gt;Vue&lt;/code&gt;对页面的更新，其核心也就是&lt;code&gt;diff&lt;/code&gt;算法了
在页面绑定的数据发生改变时，&lt;code&gt;watcher&lt;/code&gt;会调用&lt;code&gt;updateComponent&lt;/code&gt;，然后调用&lt;code&gt;vm._render&lt;/code&gt;生成最新的&lt;code&gt;vnode&lt;/code&gt;，
然后&lt;code&gt;vm._update&lt;/code&gt;会讲新旧&lt;code&gt;vnode&lt;/code&gt;传入&lt;code&gt;patch&lt;/code&gt;方法中进行diff处理，其实总体流程还是一样，只不过传入的参数不同&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
  ......

  let isInitialPatch = false;
  const insertedVnodeQueue = [];

  if (isUndef(oldVnode)) {
    isInitialPatch = true;
    createElm(vnode, insertedVnodeQueue, parentElm, refElm);
  } else {
     // oldValue是不是vnode真实的dom元素
    const isRealElement = isDef(oldVnode.nodeType);
    // 判断是否为同一vnode
    // 如果是统一vnode，调用patchVnode
    // sameVnode判断依据为两个vnode的key相同，tag名相同，type，data，attrs如果有的话必须相同
    // 如果可以复用，patchVnode
    if (!isRealElement &amp;amp;&amp;amp; sameVnode(oldVnode, vnode)) {
      patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
    } else {
      ......
    }
  }

  invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
  return vnode.elm
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;patchVnode&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
  // 如果新旧vnode相同，return
  if (oldVnode === vnode) {
    return
  }                           
  // vnode应的dom指向oldVnode的dom             
  const elm = vnode.elm = oldVnode.elm;

  ......

  // 如果新旧节点都是静态根节点
  // key也相同
  // 如果renderStatic或者markOnce
  if (isTrue(vnode.isStatic) &amp;amp;&amp;amp;
    isTrue(oldVnode.isStatic) &amp;amp;&amp;amp;
    vnode.key === oldVnode.key &amp;amp;&amp;amp;
    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
  ) {
    vnode.componentInstance = oldVnode.componentInstance;
    return
  }

  let i;
  const data = vnode.data;
  // 调用prepatch钩子函数
  if (isDef(data) &amp;amp;&amp;amp; isDef(i = data.hook) &amp;amp;&amp;amp; isDef(i = i.prepatch)) {
    i(oldVnode, vnode);
  }

  // 新旧vnode children
  const oldCh = oldVnode.children;
  const ch = vnode.children;
  // data不为空，即节点相关的属性不为空
  // isPatchable用于判断vnode的tag是否为空
  if (isDef(data) &amp;amp;&amp;amp; isPatchable(vnode)) {
    // 更新元素上相关各种属性
    for (i = 0; i &amp;lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode);
    // 调用update钩子函数
    if (isDef(i = data.hook) &amp;amp;&amp;amp; isDef(i = i.update)) i(oldVnode, vnode);
  }
  // 判断vnode是否为文本节点
  if (isUndef(vnode.text)) {
    // 新旧节点都有子元素
    if (isDef(oldCh) &amp;amp;&amp;amp; isDef(ch)) {
      // 子元素不相同
      // 调用updateChildren
      if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
      // 如果新的vnode有子元素，旧的没有
    } else if (isDef(ch)) {
      // 如果旧节点是文本节点，则置空
      if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &#39;&#39;);
      // addVnodes把ch中的元素依次添加到elm中
      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      // 如果新节点vnode没有子元素
    } else if (isDef(oldCh)) {
      // 删除旧节点的子元素
      removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      // 以上如果都不满足，如果oldVnode是文本结点，则直接内容置空
    } else if (isDef(oldVnode.text)) {
      nodeOps.setTextContent(elm, &#39;&#39;);
    }
    // 如果vnode是文本结点，且text有变化，则修改elm的文本内容
  } else if (oldVnode.text !== vnode.text) {
    nodeOps.setTextContent(elm, vnode.text);
  }
  // 调用postpatch钩子函数
  if (isDef(data)) {
    if (isDef(i = data.hook) &amp;amp;&amp;amp; isDef(i = i.postpatch)) i(oldVnode, vnode);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来重点是&lt;code&gt;updateChildren&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
  // 定义了一些索引以及起始节点的信息
  let oldStartIdx = 0
  let newStartIdx = 0
  let oldEndIdx = oldCh.length - 1
  let oldStartVnode = oldCh[0]
  let oldEndVnode = oldCh[oldEndIdx]
  let newEndIdx = newCh.length - 1
  let newStartVnode = newCh[0]
  let newEndVnode = newCh[newEndIdx]
  let oldKeyToIdx, idxInOld, vnodeToMove, refElm

  // removeOnly为false，transition-group中为true
  const canMove = !removeOnly

  if (process.env.NODE_ENV !== &#39;production&#39;) {
    checkDuplicateKeys(newCh)
  }
  // 新旧节点都未遍历完
  while (oldStartIdx &amp;lt;= oldEndIdx &amp;amp;&amp;amp; newStartIdx &amp;lt;= newEndIdx) {
    // 如果oldStartVnode未定义
    if (isUndef(oldStartVnode)) {
      // oldCh向后移一位
      oldStartVnode = oldCh[++oldStartIdx]
      // 如果oldEndVnode未定义
    } else if (isUndef(oldEndVnode)) {
      // oldCh尾索引向前移动一位
      oldEndVnode = oldCh[--oldEndIdx]
      // 首节点比较，如果能复用
    } else if (sameVnode(oldStartVnode, newStartVnode)) {
      // 调用patchVnode，更新oldStartVnode、newStartVnode，也会递归updateChildren
      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
      // 更新节点位置
      oldStartVnode = oldCh[++oldStartIdx]
      newStartVnode = newCh[++newStartIdx]
      // 尾节点比较
    } else if (sameVnode(oldEndVnode, newEndVnode)) {
      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)
      oldEndVnode = oldCh[--oldEndIdx]
      newEndVnode = newCh[--newEndIdx]
      // 首尾节点比较
    } else if (sameVnode(oldStartVnode, newEndVnode)) {
      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)
      canMove &amp;amp;&amp;amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))
      oldStartVnode = oldCh[++oldStartIdx]
      newEndVnode = newCh[--newEndIdx]
      // 尾首节点比较
    } else if (sameVnode(oldEndVnode, newStartVnode)) {
      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
      canMove &amp;amp;&amp;amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)
      oldEndVnode = oldCh[--oldEndIdx]
      newStartVnode = newCh[++newStartIdx]
    } else {
      // 以上条件都不满足，调用createKeyToOldIdx
      // createKeyToOldIdx 方法的作用，遍历oldCh，找到里面设置key的对象
      // 返回一个map，key为键，index为值
      if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)
      // 查询新节点在oldCh中的索引
      idxInOld = isDef(newStartVnode.key) ?
        oldKeyToIdx[newStartVnode.key] :
        findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)
      // 如果没找到，说明是新建的节点
      if (isUndef(idxInOld)) {
        // 创建新的DOM元素，插入到指定节点
        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
      } else {
        // 如果在oldCh中找到了索引
        vnodeToMove = oldCh[idxInOld]
        // 可复用
        if (sameVnode(vnodeToMove, newStartVnode)) {
          // patchVnode复用dom元素递归子元素
          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
          // vnode处理完了之后清楚oldCh对应的节点
          oldCh[idxInOld] = undefined
          canMove &amp;amp;&amp;amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
          // 不可复用，直接创建新元素
        } else {
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
        }
      }
      // newCh向后移一位
      newStartVnode = newCh[++newStartIdx]
    }
  }
  // 如果oldCh遍历完了
  if (oldStartIdx &amp;gt; oldEndIdx) {
    // 创建剩下的dom节点，添加到对应的位置
    refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm
    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)
    // 如果newCh遍历完了，oldCh没有 
    // 移出剩下的oldCh
  } else if (newStartIdx &amp;gt; newEndIdx) {
    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是&lt;code&gt;diff&lt;/code&gt;处理&lt;code&gt;vnode children&lt;/code&gt;属性的过程&lt;/p&gt;

&lt;p&gt;3.对于自定义组件，在&lt;code&gt;createElm&lt;/code&gt;方法中中，会调用一个方法&lt;code&gt;createComponent&lt;/code&gt;来判断是否是自定义组件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;...
if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
	return
}
...

createComponent

function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
  let i = vnode.data
  if (isDef(i)) {
    const isReactivated = isDef(vnode.componentInstance) &amp;amp;&amp;amp; i.keepAlive
    if (isDef(i = i.hook) &amp;amp;&amp;amp; isDef(i = i.init)) {
      i(vnode, false /* hydrating */, parentElm, refElm)
    }
    ......
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用&lt;code&gt;init&lt;/code&gt;初始化，&lt;code&gt;init&lt;/code&gt;方法定义在&lt;code&gt;componentVNodeHooks&lt;/code&gt;中，&lt;code&gt;componentVNodeHooks&lt;/code&gt;中定义的钩子函数，会在&lt;code&gt;patch&lt;/code&gt;中调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const componentVNodeHooks = {
  init (
    vnode,
    hydrating,
    parentElm,
    refElm
  ) {
    // 如果当前vnode上没有组件实例或者已经销毁，则创建新的新的component实例
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      // 调用createComponentInstanceForVnode
      // createComponentInstanceForVnode方法中会处理组件中的各种属性
      // 比如 Ctor是自定义组件的构造函数，propsData是父组件通过props传递的数据
      // listeners是添加在当前组件上的事件，tag是自定义的标签名，children即当前自定义组件的子元素
      const child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance,
        parentElm,
        refElm
      );
      // 调用$mount
      // 其内部依旧调用__patch__
      // 然后update
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      const mountedNode = vnode;
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },
  // patchVNode中调用
  // 组件diff之前的操作
  prepatch (oldVnode: MountedComponentVNode, vnode: MountedComponentVNode) {
    const options = vnode.componentOptions
    const child = vnode.componentInstance = oldVnode.componentInstance
    // 调用updateChildComponent，通过传入的属性，更新对应的模板，数据，事件
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    )
  },

  // patch invokeInsertHook中调用
  // 生成的dom元素插入页面后调用
  insert (vnode: MountedComponentVNode) {
    const { context, componentInstance } = vnode
    // 设置_isMounted为true，调用mounted钩子函数
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true
      callHook(componentInstance, &#39;mounted&#39;)
    }
    if (vnode.data.keepAlive) {
      // keepAlive组件，如果已经加载好了的
      // 调用queueActivatedComponent，放进activatedChildren
      if (context._isMounted) {
        queueActivatedComponent(componentInstance)
      } else {
        // 反之调用activateChildComponent，触发activated钩子函数
        // 这又是keepAlive专有的生命周期
        activateChildComponent(componentInstance, true /* direct */)
      }
    }
  },

  destroy (vnode: MountedComponentVNode) {
    const { componentInstance } = vnode
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        // 销毁组件
        componentInstance.$destroy()
      } else {
        // 对于keepAlive组件，调用deactivateChildComponent，触发deactivated钩子函数
        deactivateChildComponent(componentInstance, true /* direct */)
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;销毁组件&lt;code&gt;destroy&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Vue.prototype.$destroy = function () {
  const vm: Component = this
  if (vm._isBeingDestroyed) {
    return
  }
  // 调用beforeDestroy钩子函数
  callHook(vm, &#39;beforeDestroy&#39;)
  vm._isBeingDestroyed = true
  const parent = vm.$parent
  // 从父元素中删除当前元素
  if (parent &amp;amp;&amp;amp; !parent._isBeingDestroyed &amp;amp;&amp;amp; !vm.$options.abstract) {
    remove(parent.$children, vm)
  }
  // 销毁watcher
  if (vm._watcher) {
    vm._watcher.teardown()
  }
  // _watchers减一
  let i = vm._watchers.length
  while (i--) {
    vm._watchers[i].teardown()
  }
  // observe减一
  if (vm._data.__ob__) {
    vm._data.__ob__.vmCount--
  }
  vm._isDestroyed = true
  // 传入null，销毁当前组件
  vm.__patch__(vm._vnode, null)
  // 调用destroyed钩子函数
  callHook(vm, &#39;destroyed&#39;)
  // 销毁事件
  vm.$off()
  // 消除各种属性
  if (vm.$el) {
    vm.$el.__vue__ = null
  }
  vm.$options._parentElm = vm.$options._refElm = null
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上就是&lt;code&gt;patch&lt;/code&gt;的内容，包括一次生成&lt;code&gt;dom&lt;/code&gt;元素，&lt;code&gt;diff&lt;/code&gt;更新操作，还有对于&lt;code&gt;component&lt;/code&gt;先转换为&lt;code&gt;vnode&lt;/code&gt;再进行&lt;code&gt;patch&lt;/code&gt;，另外还有一些生命周期函数&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Vue中的VNode</title>
      <link>https://xtid.github.io/2020/vue%E4%B8%AD%E7%9A%84vnode/</link>
      <pubDate>Tue, 04 Aug 2020 23:28:03 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/vue%E4%B8%AD%E7%9A%84vnode/</guid>
      <description>&lt;p&gt;经过&lt;code&gt;compile&lt;/code&gt;编译模板字符串变成了&lt;code&gt;render&lt;/code&gt;函数，在&lt;code&gt;src/core/instance/render.js&lt;/code&gt;中，通过&lt;code&gt;vnode = render.call(vm._renderProxy, vm.$createElement)&lt;/code&gt;调用了&lt;code&gt;render&lt;/code&gt;方法并最终返回了一个&lt;code&gt;VNode&lt;/code&gt;对象实例，即&lt;code&gt;Vue&lt;/code&gt;中的虚拟&lt;code&gt;Dom&lt;/code&gt;，基本定义如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export default class VNode {
  constructor (
    tag?: string,
    data?: VNodeData,
    children?: ?Array&amp;lt;VNode&amp;gt;,
    text?: string,
    elm?: Node,
    context?: Component,
    componentOptions?: VNodeComponentOptions,
    asyncFactory?: Function
  ) {
    this.tag = tag v // 标签名
    this.data = data // 结点相关属性数据
    this.children = children // 子节点
    this.text = text // 文本
    this.elm = elm // dom元素 
    this.ns = undefined // 命名空间
    this.context = context // VNode上下文对象
    ...... 
    this.key = data &amp;amp;&amp;amp; data.key // key
    this.componentOptions = componentOptions // VNode对象如果对应的是一个自定义组件，componentOptions保存组件相关事件、props数据等
    this.componentInstance = undefined // VNode对象如果对应的是一个自定义组件，componentInstance保存相对应的vue实例
    this.parent = undefined // 当前自定义组件在父组件中的vnode
    this.raw = false
    this.isStatic = false // 是否静态节点
    .....
    this.isOnce = false // 是否为v-once元素的VNode对象
  }

  get child (): Component | void {
    return this.componentInstance
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后面还定义了一些创建简单的VNode的方法，如&lt;code&gt;createEmptyVNode&lt;/code&gt;、&lt;code&gt;reateEmptyVNode&lt;/code&gt;、&lt;code&gt;createTextVNode&lt;/code&gt;、&lt;code&gt;cloneVNode&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;前面说过，调用_init方法的最后，会调用vm._render来生成VNode节点，在&lt;code&gt;src/core/instance/render.js&lt;/code&gt;可以找到这个方法，
在这个方法里面，就会调用&lt;code&gt;vnode = render.call(vm._renderProxy, vm.$createElement)&lt;/code&gt;来生成&lt;code&gt;VNode&lt;/code&gt;，其中在这文件有两个&lt;code&gt;createElement&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;vm._c = (a, b, c, d) =&amp;gt; createElement(vm, a, b, c, d, false)
vm.$createElement = (a, b, c, d) =&amp;gt; createElement(vm, a, b, c, d, true)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;vm._c = (a, b, c, d) =&amp;gt; createElement(vm, a, b, c, d, false)&lt;/code&gt;是编译模板生成的render函数执行时调用的，
&lt;code&gt;vm.$createElement&lt;/code&gt;是自己添加&lt;code&gt;render&lt;/code&gt;函数时，作为参数传递给render函数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/core/vdom/create-element.js&lt;/code&gt;中&lt;code&gt;createElement&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function createElement (
  context: Component, // 当前的上下文对象，哪一个vm
  tag: any, //  标签名
  data: any, // 节点相关的属性，比如key，ref，attrs等等属性
  children: any, // children
  normalizationType: any, // 子元素扁平化处理的级别
  alwaysNormalize: boolean // 总是扁平化处理
): VNode | Array&amp;lt;VNode&amp;gt; {
  // 如果判定为true，说明该元素没有相关属性
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children
    children = data
    data = undefined
  }
  if (isTrue(alwaysNormalize)) {
    // 最高级别的扁平化处理
    normalizationType = ALWAYS_NORMALIZE
  }
  return _createElement(context, tag, data, children, normalizationType)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用&lt;code&gt;_createElement&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function _createElement (
  context: Component,
  tag?: string | Class&amp;lt;Component&amp;gt; | Function | Object,
  data?: VNodeData,
  children?: any,
  normalizationType?: number
): VNode | Array&amp;lt;VNode&amp;gt; {
	......
  if (!tag) {
    // 如果tag为空，创建一个空的VNode
    return createEmptyVNode()
  }
  // 在Vue中，如果设置对象或者数组为key的时候，会报错
  if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp;
    isDef(data) &amp;amp;&amp;amp; isDef(data.key) &amp;amp;&amp;amp; !isPrimitive(data.key)
  ) {
    if (!__WEEX__ || !(&#39;@binding&#39; in data.key)) {
      warn(
        &#39;Avoid using non-primitive value as key, &#39; +
        &#39;use string/number value instead.&#39;,
        context
      )
    }
  }
  // 如果只有一个children，则当成slot解析
  if (Array.isArray(children) &amp;amp;&amp;amp;
    typeof children[0] === &#39;function&#39;
  ) {
    data = data || {}
    data.scopedSlots = { default: children[0] }
    children.length = 0
  }
  // 扁平化处理
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children)
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children)
  }
  let vnode, ns
  if (typeof tag === &#39;string&#39;) {
    let Ctor
    ns = (context.$vnode &amp;amp;&amp;amp; context.$vnode.ns) || config.getTagNamespace(tag)
    if (config.isReservedTag(tag)) {
      // 如果tag为String，且为平台保留的标签，直接创建VNode
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      )
    } else if ((!data || !data.pre) &amp;amp;&amp;amp; isDef(Ctor = resolveAsset(context.$options, &#39;components&#39;, tag))) {
      // 如果不是保留标签，并且有数据，没有设置跳过，且是自定义组件
      vnode = createComponent(Ctor, data, context, children, tag)
    } else {
      // 否则，创建VNode对象
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      )
    }
  } else {
    // 如果tab不是字符串，也是直接createComponent
    vnode = createComponent(tag, data, context, children)
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) applyNS(vnode, ns)
    if (isDef(data)) registerDeepBindings(data)
    return vnode
  } else {
    return createEmptyVNode()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;createComponent&lt;/code&gt;可以创建自定义组件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function createComponent (
  Ctor: Class&amp;lt;Component&amp;gt; | Function | Object | void,
  data: ?VNodeData,
  context: Component,
  children: ?Array&amp;lt;VNode&amp;gt;,
  tag?: string
): VNode | Array&amp;lt;VNode&amp;gt; | void {
  // 如果Ctor为空，跳过此步骤，对应的实际情况就是传入的参数并不是字符串或者自定义组件
  if (isUndef(Ctor)) {
    return
  }
	
	// baseCtor其实就是指的Vue对象
  const baseCtor = context.$options._base

  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor)
  }
	......
  data = data || {}
	
	// 递归合并父对象上的options
  resolveConstructorOptions(Ctor)

	// 处理v-model指令
  if (isDef(data.model)) {
    transformModel(Ctor.options, data)
  }
	
	// 抽取props属性
  const propsData = extractPropsFromVNodeData(data, Ctor, tag)

  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }
	
	// 处理组件.native的事件，表示组件上的事件
  const listeners = data.on
  data.on = data.nativeOn
		
	// 处理抽象组件中的slot，如keep-alive
  if (isTrue(Ctor.options.abstract)) {
    const slot = data.slot
    data = {}
    if (slot) {
      data.slot = slot
    }
  }
	
	// 合并一些钩子函数
  installComponentHooks(data)

  const name = Ctor.options.name || tag
  
  // 生成VNode
  const vnode = new VNode(
    `vue-component-${Ctor.cid}${name ? `-${name}` : &#39;&#39;}`,
    data, undefined, undefined, undefined, context,
    { Ctor, propsData, listeners, tag, children },
    asyncFactory
  )
	
  ......

  return vnode
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;extractPropsFromVNodeData&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function extractProps (data: VNodeData, Ctor: Class&amp;lt;Component&amp;gt;, tag?: string): ?Object {
  const propOptions = Ctor.options.props
  // 组件没有props，return
  if (!propOptions) {
    return
  }
  const res = {}
  // domProps表示input的value、option的selected等属性
  // attrs表父组件绑定在子元素上的属性值
  const { attrs, props, domProps } = data
  if (attrs || props || domProps) {
    for (const key in propOptions) {
      // 将驼峰命名转化为连线命名
			// aB -&amp;gt; a-b
      const altKey = hyphenate(key)
      .....
      
      // 遍历找到props、attrs、domProps中的属性
      // 如果没有传递preserve参数，则表示找到该key的值时删除对应的属性
      // 最后返回res，并且只留下props上的属性
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey) ||
      checkProp(res, domProps, key, altKey)
    }
  }
  return res
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，对于自定义组件，会创建一个&lt;code&gt;vnode&lt;/code&gt;对象，并返回一个标签名为&lt;code&gt;vue-component-cid-name&lt;/code&gt;格式的&lt;code&gt;VNode&lt;/code&gt;对象。&lt;/p&gt;

&lt;p&gt;上面说的扁平化处理其实就是将多维的数组，合并转换成一个一维的数组&lt;/p&gt;

&lt;p&gt;&lt;code&gt;simpleNormalizeChildren&lt;/code&gt;简单的扁平化处理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function simpleNormalizeChildren (children: any) {
  for (let i = 0; i &amp;lt; children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;normalizeChildren&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function normalizeChildren (children: any): ?Array&amp;lt;VNode&amp;gt; {
  return isPrimitive(children)
  	// 如果传入的children是字符串或者数字，则直接返回文本结点数组
    ? [createTextVNode(children)]
    : Array.isArray(children)
			// 如果传入的children是数组，调用normalizeArrayChildren
      ? normalizeArrayChildren(children)
      : undefined
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;normalizeArrayChildren&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function normalizeArrayChildren (children: any, nestedIndex?: string): Array&amp;lt;VNode&amp;gt; {
  const res = []
  let i, c, lastIndex, last
  for (i = 0; i &amp;lt; children.length; i++) {
    c = children[i]
    // 如果该元素为undefined或null或Boolean类型的值,continue
    if (isUndef(c) || typeof c === &#39;boolean&#39;) continue
    lastIndex = res.length - 1
    last = res[lastIndex]
    if (Array.isArray(c)) {
      if (c.length &amp;gt; 0) {
        // c是一个数组，则递归的执行normalizeArrayChildren方法
        c = normalizeArrayChildren(c, `${nestedIndex || &#39;&#39;}_${i}`)
        if (isTextNode(c[0]) &amp;amp;&amp;amp; isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]: any).text)
          c.shift()
        }
        res.push.apply(res, c)
      }
    } else if (isPrimitive(c)) {
      // 如果最后一个节点是文本节点
      if (isTextNode(last)) {
        // 合并last.text和c
        res[lastIndex] = createTextVNode(last.text + c)
      } else if (c !== &#39;&#39;) {
        // 如果最后一个节点不是文本节点，且不为空
        // 创建一个空文本节点
        res.push(createTextVNode(c))
      }
    } else {
      // 如果c是一个文本VNode对象，且res中最后一个元素也是文本结点
      // 合并两个VNode为一个
      if (isTextNode(c) &amp;amp;&amp;amp; isTextNode(last)) {
        res[lastIndex] = createTextVNode(last.text + c.text)
      } else {
        // 设置VNode的key
        if (isTrue(children._isVList) &amp;amp;&amp;amp;
          isDef(c.tag) &amp;amp;&amp;amp;
          isUndef(c.key) &amp;amp;&amp;amp;
          isDef(nestedIndex)) {
          c.key = `__vlist${nestedIndex}_${i}__`
        }
        res.push(c)
      }
    }
  }
  return res
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Vue里面compile模板编译</title>
      <link>https://xtid.github.io/2020/vue%E9%87%8C%E9%9D%A2compile%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/</link>
      <pubDate>Thu, 30 Jul 2020 22:16:42 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/vue%E9%87%8C%E9%9D%A2compile%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/</guid>
      <description>&lt;p&gt;1.complie简述&lt;/p&gt;

&lt;p&gt;&lt;code&gt;complie&lt;/code&gt;阶段主要是将&lt;code&gt;Vue&lt;/code&gt;代码通过一系列转换，最终生成对应的&lt;code&gt;render&lt;/code&gt;字符串，然后&lt;code&gt;Vue&lt;/code&gt;通过&lt;code&gt;render&lt;/code&gt;字符串里面的关键词或者说定义，对页面内容进行增删改，&lt;code&gt;Vue&lt;/code&gt;对象上有一个全局函数&lt;code&gt;compile&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import { compileToFunctions } from &#39;./compiler/index&#39;
......
Vue.compile = compileToFunctions
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，他是引用的&lt;code&gt;./compiler/index&lt;/code&gt;模块导出的&lt;code&gt;compileToFunctions&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { baseOptions } from &#39;./options&#39;
import { createCompiler } from &#39;compiler/index&#39;
const { compile, compileToFunctions } = createCompiler(baseOptions)
export { compile, compileToFunctions }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;baseOptions&lt;/code&gt;，对解析模板的一些选项进行基本的定义，规定如果解析模板中的各种标签或代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export const baseOptions: CompilerOptions = {
  expectHTML: true,
  modules,
  directives,
  isPreTag,
  isUnaryTag,
  mustUseProp,
  canBeLeftOpenTag,
  isReservedTag,
  getTagNamespace,
  staticKeys: genStaticKeys(modules)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;expectHTML&lt;/code&gt;：为&lt;code&gt;true&lt;/code&gt;时，解析&lt;code&gt;HTML&lt;/code&gt;的结束标签&lt;/p&gt;

&lt;p&gt;&lt;code&gt;modules&lt;/code&gt;：包括&lt;code&gt;klass&lt;/code&gt;和&lt;code&gt;style&lt;/code&gt;，对模板中类和样式的解析。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;directives&lt;/code&gt;：这里包括&lt;code&gt;model&lt;/code&gt;（&lt;code&gt;v-model&lt;/code&gt;）、&lt;code&gt;html&lt;/code&gt;（&lt;code&gt;v-html&lt;/code&gt;）、&lt;code&gt;text&lt;/code&gt;(&lt;code&gt;v-text&lt;/code&gt;)三个指令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;isPreTag&lt;/code&gt;：是否是&lt;code&gt;pre&lt;/code&gt;标签&lt;/p&gt;

&lt;p&gt;&lt;code&gt;isUnaryTag&lt;/code&gt;：是否是单标签，比如&lt;code&gt;img&lt;/code&gt;、&lt;code&gt;input&lt;/code&gt;、&lt;code&gt;iframe&lt;/code&gt;等&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mustUseProp&lt;/code&gt;：需要使用&lt;code&gt;props&lt;/code&gt;绑定的属性，比如&lt;code&gt;value&lt;/code&gt;、&lt;code&gt;selected&lt;/code&gt;等&lt;/p&gt;

&lt;p&gt;&lt;code&gt;canBeLeftOpenTag&lt;/code&gt;：可以不闭合的标签，比如&lt;code&gt;tr&lt;/code&gt;、&lt;code&gt;td&lt;/code&gt;等&lt;/p&gt;

&lt;p&gt;&lt;code&gt;isReservedTag&lt;/code&gt;：是否是保留标签，&lt;code&gt;html&lt;/code&gt;标签和&lt;code&gt;SVG&lt;/code&gt;标签&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getTagNamespace&lt;/code&gt;：获取命名空间，&lt;code&gt;svg&lt;/code&gt;和&lt;code&gt;math&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;staticKeys&lt;/code&gt;：静态关键词，包括&lt;code&gt;staticClass,staticStyle&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后是&lt;code&gt;createCompiler&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function createCompilerCreator (baseCompile: Function): Function {
  // 接受一个基本的CompilerOptions
  return function createCompiler (baseOptions: CompilerOptions) {
    function compile (
      template: string,
      options?: CompilerOptions
    ): CompiledResult {
      // finalOptions继承自baseOptions
      const finalOptions = Object.create(baseOptions)
      const errors = []
      const tips = []

      let warn = (msg, range, tip) =&amp;gt; {
        (tip ? tips : errors).push(msg)
      }

      if (options) {
        if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; options.outputSourceRange) {
          // $flow-disable-line
          const leadingSpaceLength = template.match(/^\s*/)[0].length

          warn = (msg, range, tip) =&amp;gt; {
            const data: WarningMessage = { msg }
            if (range) {
              if (range.start != null) {
                data.start = range.start + leadingSpaceLength
              }
              if (range.end != null) {
                data.end = range.end + leadingSpaceLength
              }
            }
            (tip ? tips : errors).push(data)
          }
        }
        // 合并modules
        if (options.modules) {
          finalOptions.modules =
            (baseOptions.modules || []).concat(options.modules)
        }
        // 合并directives
        if (options.directives) {
          finalOptions.directives = extend(
            Object.create(baseOptions.directives || null),
            options.directives
          )
        }
        
        // 额外传入的options，合并
        for (const key in options) {
          if (key !== &#39;modules&#39; &amp;amp;&amp;amp; key !== &#39;directives&#39;) {
            finalOptions[key] = options[key]
          }
        }
      }
	
      // 收集到的错误日志
      finalOptions.warn = warn

      const compiled = baseCompile(template.trim(), finalOptions)
      if (process.env.NODE_ENV !== &#39;production&#39;) {
        detectErrors(compiled.ast, warn)
      }
      compiled.errors = errors
      compiled.tips = tips
      // 返回render字符串
      return compiled
    }

    return {
      compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导出的模块&lt;code&gt;compileToFunctions&lt;/code&gt;为&lt;code&gt;createCompileToFunctionFn&lt;/code&gt;执行返回的结果&lt;/p&gt;

&lt;p&gt;&lt;code&gt;createCompileToFunctionFn&lt;/code&gt;代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function createCompileToFunctionFn (compile: Function): Function {
  const cache = Object.create(null)

  return function compileToFunctions (
    template: string,
    options?: CompilerOptions,
    vm?: Component
  ): CompiledFunctionResult {
    // 拿到options，并且删除错误日志等数据
    options = extend({}, options)
    const warn = options.warn || baseWarn
    delete options.warn
		
    ......

		// 如果有缓存，拿到缓存中的编译结果
    const key = options.delimiters
      ? String(options.delimiters) + template
      : template
    if (cache[key]) {
      return cache[key]
    }

    // 编译的结果
    const compiled = compile(template, options)

 		......

    const res = {}
    const fnGenErrors = []
    // render字符串
    res.render = createFunction(compiled.render, fnGenErrors)
    // 将render字符串中的标识符转为函数，如_c、_m
    res.staticRenderFns = compiled.staticRenderFns.map(code =&amp;gt; {
      return createFunction(code, fnGenErrors)
    })

		......

    return (cache[key] = res)
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.生成ast&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;src/compiler/parser/index.js&lt;/code&gt;中，首先定义了各种&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 匹配@或v-on开头的属性
export const onRE = /^@|^v-on:/
// 是匹配v-或@或:开头的属性
export const dirRE = /^v-|^@|^:|^\./ 
// 匹配v-for中的属性值，比如item in items、(item, index) of items
export const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/ 
// 是对forAliasRE中捕获的第一部分内容，进行拆解，v-for中in|of前最后可以有三个逗号分隔的参数
export const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/
// 去掉字符串 &#39;(item, index)&#39; 中的左右括号
const stripParensRE = /^\(|\)$/g
// 用来匹配指令编写中的参数
const argRE = /:(.*)$/
// 匹配以字符:或字符串 v-bind: 开头的字符串
export const bindRE = /^:|^\.|^v-bind:/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;parse&lt;/code&gt;，里面解析的方法主要是&lt;code&gt;parseHTML&lt;/code&gt;，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function parse (
	template: string,
	options: CompilerOptions
  ): ASTElement | void {
	warn = options.warn || baseWarn
  
	......
	parseHTML()
  return root
}

// src/compiler/parser/html-parser.js

export function parseHTML (html, options) {
  const stack = []
  const expectHTML = options.expectHTML
  const isUnaryTag = options.isUnaryTag || no
  const canBeLeftOpenTag = options.canBeLeftOpenTag || no
  let index = 0
  let last, lastTag
  while (html) {}

  function advance (n) {
    ...
  }

  function parseStartTag () {
    ...
  }

  function handleStartTag (match) {
    ...
  }

	function parseEndTag (tagName, start, end) {
  	...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;parseHTML&lt;/code&gt;的&lt;code&gt;while&lt;/code&gt;循环里&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// advance这个方法，用于截取传入的字符串
// 过滤掉注释，doctype等
if (comment.test(html)) {
  const commentEnd = html.indexOf(&#39;--&amp;gt;&#39;)

  if (commentEnd &amp;gt;= 0) {
    advance(commentEnd + 3)
    continue
  }
}

// 过滤文档类型标示的字符串
const doctypeMatch = html.match(doctype)
if (doctypeMatch) {
  advance(doctypeMatch[0].length)
  continue
}

// 匹配结束的标签
const endTagMatch = html.match(endTag)
if (endTagMatch) {
  const curIndex = index
  advance(endTagMatch[0].length)
  parseEndTag(endTagMatch[1], curIndex, index)
  continue
}

// 匹配开始标签
// 传入handleStartTag处理完后，会生成一个包含标签各种属性的对象
const startTagMatch = parseStartTag()
if (startTagMatch) {
  handleStartTag(startTagMatch)
  continue
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后续会调用&lt;code&gt;parse&lt;/code&gt;里调用&lt;code&gt;parseHTML&lt;/code&gt;传入的&lt;code&gt;start&lt;/code&gt;的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;start () {
  // 定义基本的ast结构
  createASTElement()
  // 解析v-pre、v-if、v-for、v-once、slot、key、ref等指令
  processPre()
  processFor()
  ......
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;处理完后会调用&lt;code&gt;parse&lt;/code&gt;里调用&lt;code&gt;parseHTML&lt;/code&gt;传入的&lt;code&gt;end&lt;/code&gt;的方法&lt;/p&gt;

&lt;p&gt;1、取出&lt;code&gt;stack&lt;/code&gt;中的最后一个元素。&lt;/p&gt;

&lt;p&gt;2、取出该元素的最后一个子元素。&lt;/p&gt;

&lt;p&gt;3、如果最后一个子元素是纯文本&lt;code&gt;&#39; &#39;&lt;/code&gt;则删除，这是因为我们的模板一般都会缩进，都会有换行，所以这里是清除换行等添加的内容。&lt;/p&gt;

&lt;p&gt;4、&lt;code&gt;stack&lt;/code&gt;长度减一&lt;/p&gt;

&lt;p&gt;5、&lt;code&gt;currentParent&lt;/code&gt;变为栈中最后一个元素&lt;/p&gt;

&lt;p&gt;6、 处理&lt;code&gt;v-pre&lt;/code&gt;或&lt;code&gt;pre&lt;/code&gt;的结束标签&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;end (tag, start, end) {
  const element = stack[stack.length - 1]
  if (!inPre) {
    const lastNode = element.children[element.children.length - 1]
    if (lastNode &amp;amp;&amp;amp; lastNode.type === 3 &amp;amp;&amp;amp; lastNode.text === &#39; &#39;) {
      element.children.pop()
    }
  }
  stack.length -= 1
  currentParent = stack[stack.length - 1]
  if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; options.outputSourceRange) {
    element.end = end
  }
  closeElement(element)
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，得到一个包含名称、类型、属性、父子节点信息的一个&lt;code&gt;ast&lt;/code&gt;语法树，如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const element = {
  type: 1,
  tag: &#39;&#39;,
  attrsList: [],
  attrsMap: {},
  parent: {},
  children: []
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.优化静态内容，打开&lt;code&gt;src/compiler/index&lt;/code&gt;，看到调用&lt;code&gt;const ast = parse(template.trim(), options)&lt;/code&gt;生成&lt;code&gt;ast&lt;/code&gt;后，调用&lt;code&gt;optimize&lt;/code&gt;，传入&lt;code&gt;ast&lt;/code&gt; ，打开&lt;code&gt;optimisze&lt;/code&gt;源码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 获取基本静态key的一个集合
const genStaticKeysCached = cached(genStaticKeys)
export function optimize (root: ?ASTElement, options: CompilerOptions) {
  if (!root) return
  // 如果ast上有staticKeys选项
  isStaticKey = genStaticKeysCached(options.staticKeys || &#39;&#39;)
  // 是不是平台保留tag，如HTML 标签
  isPlatformReservedTag = options.isReservedTag || no
  // 标记所有静态和非静态节点
  markStatic(root)
  // 标记静态根节点
  markStaticRoots(root, false)
}

function genStaticKeys (keys: string): Function {
  return makeMap(
    &#39;type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap,has$Slot&#39; +
    (keys ? &#39;,&#39; + keys : &#39;&#39;)
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;markStatic&lt;/code&gt;标记所有静态和非静态节点&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function markStatic (node: ASTNode) {
  // 判断当前节点是否为静态节点
  // 静态节点包括普通元素、纯文本元素、v-pre、v-once
  node.static = isStatic(node)
 	// 如果type为1，代表当前节点为元素节点
  if (node.type === 1) {
    if (
      // 如果不是保留标签，即自定义标签时
      !isPlatformReservedTag(node.tag) &amp;amp;&amp;amp;
      // 如果不是component标签
      !node.component &amp;amp;&amp;amp;
      // 如果标签不是slot
      node.tag !== &#39;slot&#39; &amp;amp;&amp;amp;
      // 不是一个内联模板容器？？
      node.attrsMap[&#39;inline-template&#39;] == null
    ) {
      // 直接return，不对子节点做处理，反之，递归对子节点做标记
      return
    }
  	......
  }
}
  
function isStatic (node: ASTNode): boolean {
  // 表达式
  if (node.type === 2) {
    return false
  }
  // text
  if (node.type === 3) { 
    return true
  }
  return !!(node.pre || (
    // 没有任何指令或事件绑定
    !node.hasBindings &amp;amp;&amp;amp; 
    // 没有if 和 for 指令
    !node.if &amp;amp;&amp;amp; !node.for &amp;amp;&amp;amp; 
    // 不是内置标签，如slot
    !isBuiltInTag(node.tag) &amp;amp;&amp;amp;
    // 平台保留标签，如HTML
    isPlatformReservedTag(node.tag) &amp;amp;&amp;amp; 
    // 不是template标签的直接子元素且没有包含在for循环中
    !isDirectChildOfTemplateFor(node) &amp;amp;&amp;amp;
    // 结点包含的属性只能有isStaticKey中指定的几个
    Object.keys(node).every(isStaticKey)
  ))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;markStaticRoots&lt;/code&gt;标记静态根节点&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function markStaticRoots (node: ASTNode, isInFor: boolean) {
  // 只处理元素节点类型
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor
    }
    // 标记静态根节点的条件为本身static标记为true
    // 并且该结点不是只有一个静态文本子节点
    if (node.static &amp;amp;&amp;amp; node.children.length &amp;amp;&amp;amp; !(
      node.children.length === 1 &amp;amp;&amp;amp;
      node.children[0].type === 3
    )) {
      node.staticRoot = true
      return
    } else {
      node.staticRoot = false
    }
		......
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.生成render字符串&lt;/p&gt;

&lt;p&gt;在标记完静态节点之后，会调用&lt;code&gt;generate&lt;/code&gt;方法来生成render字符串，生成的字符串中&lt;/p&gt;

&lt;p&gt;&lt;code&gt;_c&lt;/code&gt; 该方法对应的是&lt;code&gt;createElement&lt;/code&gt;方法，顾名思义，它的含义是创建一个元素，它的第一个参数是要定义的元素标签名、第二个参数是元素上添加的属性，第三个参数是子元素数组，第四个参数是子元素数组进行归一化处理的级别。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;_v&lt;/code&gt; 该方法是创建一个文本结点。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;_s&lt;/code&gt; 是把一个值转换为字符串。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;_m&lt;/code&gt; 是渲染静态内容，它接收的第一个参数是一个索引值，指向最终生成的&lt;code&gt;staticRenderFns&lt;/code&gt;数组中对应的内容，第二个参数是标识元素是否包裹在&lt;code&gt;for&lt;/code&gt;循环内。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function generate (
  ast: ASTElement | void,
  options: CompilerOptions
): CodegenResult {
  const state = new CodegenState(options)
  // 如果ast为空，直接返回一个空的div节点
  // 有过有值，调用genElement
  const code = ast ? genElement(ast, state) : &#39;_c(&amp;quot;div&amp;quot;)&#39;
  // 返回render字符串
  return {
    render: `with(this){return ${code}}`,
    staticRenderFns: state.staticRenderFns
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;genElement&lt;/code&gt;会通过节点上的标志来判断使用什么方法来生成render字符串，这里说一下&lt;code&gt;genStatic&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function genElement (el: ASTElement, state: CodegenState): string {
  // pre的状态用来判断是否跳过当前解析
  if (el.parent) {
    el.pre = el.pre || el.parent.pre
  }
	
  if (el.staticRoot &amp;amp;&amp;amp; !el.staticProcessed) {
    return genStatic(el, state)
  } 
  ...... 
		else {
      let data
      // 如果节点没其他属性或者跳过解析，直接genData
      // genData这个方法会给节点添加各种属性
      if (!el.plain || (el.pre &amp;amp;&amp;amp; state.maybeComponent(el))) {
        data = genData(el, state)
      }
			
      // 如果不是内部模板，调用genChildren，返回对应的字符串
      const children = el.inlineTemplate ? null : genChildren(el, state, true)
      code = `_c(&#39;${el.tag}&#39;${
        data ? `,${data}` : &#39;&#39; 
      }${
        children ? `,${children}` : &#39;&#39; 
      })`
    }
    for (let i = 0; i &amp;lt; state.transforms.length; i++) {
      code = state.transforms[i](el, code)
    }
    return code
  }
}

function genStatic (el: ASTElement, state: CodegenState): string {
  el.staticProcessed = true
  // 暂存pre
  const originalPreState = state.pre
  // 如果当前节点pre为true，更改pre的状态
  if (el.pre) {
    state.pre = el.pre
  }
  // 通过递归处理静态根节点及其子内容，添加到staticRenderFns
  state.staticRenderFns.push(`with(this){return ${genElement(el, state)}}`)
  // 恢复pre状态
  state.pre = originalPreState
  return `_m(${
    state.staticRenderFns.length - 1
  }${
    el.staticInFor ? &#39;,true&#39; : &#39;&#39;
  })`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后返回的结果就包含&lt;code&gt;render&lt;/code&gt;字符串以及&lt;code&gt;staticRenderFns&lt;/code&gt;静态节点&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Vue2.x里面的双向数据绑定</title>
      <link>https://xtid.github.io/2020/vue2.x%E9%87%8C%E9%9D%A2%E7%9A%84%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</link>
      <pubDate>Wed, 29 Jul 2020 22:13:21 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/vue2.x%E9%87%8C%E9%9D%A2%E7%9A%84%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</guid>
      <description>&lt;p&gt;Vue2.x的数据绑定是通过数据劫持的方式来实现的，其中最核心的便是&lt;code&gt;Object.defineProperty()&lt;/code&gt;，而Vue3.0里面数据绑定是通过&lt;code&gt;Proxy&lt;/code&gt;实现的&lt;/p&gt;

&lt;p&gt;Vue2.x的双向数据绑定，有三个比较核心的部分&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Observer&lt;/code&gt;：通过&lt;code&gt;Object.defineProperty&lt;/code&gt;来做数据劫持，递归地监听对象上的所有属性，在属性值改变的时候，触发相应的&lt;code&gt;Watcher&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Watcher&lt;/code&gt;：订阅者，当监听的数据值修改时，执行通知&lt;code&gt;Dep&lt;/code&gt;执行对应的响应的回调函数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Dep&lt;/code&gt;：将&lt;code&gt;Observer&lt;/code&gt;和&lt;code&gt;Watcher&lt;/code&gt;关联起来，这个双向数据绑定实现的设计模式为发布订阅模式，&lt;code&gt;Dep&lt;/code&gt;就相当于发布订阅模式的中间对象&lt;/p&gt;

&lt;p&gt;Observer&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export class Observer {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that have this object as root $data

  constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0
    // 通过Object.defineProperty设置_ob_值，使用_ob_可以直接拿到Observer对象
    def(value, &#39;__ob__&#39;, this)
    if (Array.isArray(value)) {
      if (hasProto) {
        protoAugment(value, arrayMethods)
      } else {
        copyAugment(value, arrayMethods, arrayKeys)
      }
      // 如果是数组，调用observeArray处理
      this.observeArray(value)
    } else {
      // 如果是其他对象调用walk处理
      this.walk(value)
    }
  }

  walk (obj: Object) {
    const keys = Object.keys(obj)
    // 遍历对象属性，对每个属性添加数据邦数据绑定
    for (let i = 0; i &amp;lt; keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }

  observeArray (items: Array&amp;lt;any&amp;gt;) {
    // 如果是数组，则循环遍历数组，调用observe
    for (let i = 0, l = items.length; i &amp;lt; l; i++) {
      observe(items[i])
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;defineReactive&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  const dep = new Dep()
	
  // 获取obj上对应属性key的描述符，如果configurable为false，属性不能改变，return
  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property &amp;amp;&amp;amp; property.configurable === false) {
    return
  }

  const getter = property &amp;amp;&amp;amp; property.get
  const setter = property &amp;amp;&amp;amp; property.set
  if ((!getter || setter) &amp;amp;&amp;amp; arguments.length === 2) {
    val = obj[key]
  }

  let childOb = !shallow &amp;amp;&amp;amp; observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      // 获取这个值
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        // 将当前dep添加到target中，然后将dep添加到subs中	
        dep.depend()
        if (childOb) 
          childOb.dep.depend()
          if (Array.isArray(value)) {
						// 如果传入的值为数组，遍历这个数组，对每一个元素depend
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
    	// 获取对象原来的值
      const value = getter ? getter.call(obj) : val
      // 如果新设置的值和原来的值一样，直接return
      if (newVal === value || (newVal !== newVal &amp;amp;&amp;amp; value !== value)) {
        return
      }
    	// 打印错误
      if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; customSetter) {
        customSetter()
      }
    	// 若属性上设置了getter没设置setter，return
      if (getter &amp;amp;&amp;amp; !setter) return
      if (setter) {
        setter.call(obj, newVal)
      } else {
        // 设置新的值
        val = newVal
      }
    	// 创建一个新的observe，并触发对应的更新事件
      childOb = !shallow &amp;amp;&amp;amp; observe(newVal)
      dep.notify()
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;observe&lt;/code&gt;这个方法主要是返回与对象相关的&lt;code&gt;Observer&lt;/code&gt;对象，如果没有，则新创建一个&lt;code&gt;Observer&lt;/code&gt;对象并返回&lt;/p&gt;

&lt;p&gt;defineReactive中还有几个方法，&lt;code&gt;protoAugment&lt;/code&gt;和&lt;code&gt;copyAugment&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var arrayProto = Array.prototype
var arrayMethods = Object.create(arrayProto)
function protoAugment (target, src) {
  target.__proto__ = src;
}
protoAugment(value, arrayMethods)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于数组对象来说在当前环境如果能使用&lt;code&gt;__proto__&lt;/code&gt;对象(&lt;code&gt;__proto__ in {}&lt;/code&gt;)，则调用&lt;code&gt;protoAugment&lt;/code&gt;，其实就是将当前的数组对象&lt;code&gt;__proto__&lt;/code&gt;指向数组原型对象，然后对于&lt;code&gt;push&lt;/code&gt;、&lt;code&gt;pop&lt;/code&gt;、&lt;code&gt;shift&lt;/code&gt;、&lt;code&gt;unshift&lt;/code&gt;、&lt;code&gt;splice&lt;/code&gt;、&lt;code&gt;sort&lt;/code&gt;、&lt;code&gt;reverse&lt;/code&gt;这些操作数组的方法，遍历，添加到&lt;code&gt;arrayMethods&lt;/code&gt;上，操作之后，调用&lt;code&gt;ob.dep.notify()&lt;/code&gt;触发更新&lt;/p&gt;

&lt;p&gt;&lt;code&gt;copyAugment&lt;/code&gt;则是在循环中把&lt;code&gt;arrayMethods&lt;/code&gt;上的&lt;code&gt;arrayKeys&lt;/code&gt;方法添加到&lt;code&gt;value&lt;/code&gt;上&lt;/p&gt;

&lt;p&gt;Dep&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Dep&lt;/code&gt;的定义比较简单，就是简单的保存了一个&lt;code&gt;Wacher&lt;/code&gt;数组，有一些增删的方法，最后&lt;code&gt;notify&lt;/code&gt;调用对应&lt;code&gt;Wacher&lt;/code&gt;更新的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export default class Dep {
  static target: ?Watcher;
  id: number;
  subs: Array&amp;lt;Watcher&amp;gt;;

  constructor () {
    this.id = uid++
    this.subs = []
  }

  addSub (sub: Watcher) {
    this.subs.push(sub)
  }

  removeSub (sub: Watcher) {
    remove(this.subs, sub)
  }

  depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }

  notify () {
    const subs = this.subs.slice()
    if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; !config.async) {
      subs.sort((a, b) =&amp;gt; a.id - b.id)
    }
    for (let i = 0, l = subs.length; i &amp;lt; l; i++) {
      subs[i].update()
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Watcher&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export default class Watcher {
	......
  constructor (
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) {
    this.vm = vm
    if (isRenderWatcher) {
      vm._watcher = this
    }
    vm._watchers.push(this)
    // 创建Watcher时传的options
    // 如之前调用updateComponet方法时，传入before来调用beforeUpdate钩子函数
    if (options) {
      this.deep = !!options.deep
      this.user = !!options.user
      this.lazy = !!options.lazy
      this.sync = !!options.sync
      this.before = options.before
    } else {
      this.deep = this.user = this.lazy = this.sync = false
    }
    this.cb = cb
    this.id = ++uid 
    this.active = true
    this.dirty = this.lazy 
    this.deps = []
    this.newDeps = []
    this.depIds = new Set()
    this.newDepIds = new Set()
    this.expression = process.env.NODE_ENV !== &#39;production&#39;
      ? expOrFn.toString()
      : &#39;&#39;
    
    // 设置getter
    // 如果传入expOrFn是一个函数
    if (typeof expOrFn === &#39;function&#39;) {
      this.getter = expOrFn
    } else {
      // 如果传入的不是一个函数，通过parsePath解析，赋值给getter
      this.getter = parsePath(expOrFn)
      if (!this.getter) {
        // 如果解析出来的getter不是一个函数，设置为空 noop，并打印错误
        this.getter = noop
        process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; warn(
          `Failed watching path: &amp;quot;${expOrFn}&amp;quot; ` +
          &#39;Watcher only accepts simple dot-delimited paths. &#39; +
          &#39;For full control, use a function instead.&#39;,
          vm
        )
      }
    }
    this.value = this.lazy
      ? undefined
      : this.get()
  }

  /**
   * Evaluate the getter, and re-collect dependencies.
   */
  get () {
    // 设置Dep.tartget为当前watcher，这样它就有addSub、removeSub等方法
    pushTarget(this)
    let value
    const vm = this.vm
    try {
      // 得到调用getter的value
      value = this.getter.call(vm, vm)
    } catch (e) {
      if (this.user) {
        handleError(e, vm, `getter for watcher &amp;quot;${this.expression}&amp;quot;`)
      } else {
        throw e
      }
    } finally {
      if (this.deep) {
        traverse(value)
      }
      // 清楚Dep，移出target队列，重新设置Dep.target值
      popTarget()
      this.cleanupDeps()
    }
    
    // 在进行模板渲染的时候，value为undefined
    return value
  }
	
	......
	
  // 在更新数据时，调用dep.notify，会触发update方法
  update () {
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) {
      // 若生成Watcher传入配置sync
      // 在更新的时候直接调用run方法，调用回掉方法
      this.run()
    } else {
      // 如果不是sync配置，处理Watcher队列
      // queueWatcher方法里会使用一个id来表示Watcher的优先级，依次执行上面的run方法
      // 更新的时候如果watcher列表正在更新，则把新的watcher添加到对应的位置，并更新
      // 否则，在下一个nextTick中执行flushSchedulerQueue
      queueWatcher(this)
    }
  }

  run () {
    if (this.active) {
      const value = this.get()
      if (
        value !== this.value ||
        isObject(value) ||
        this.deep
      ) {
        const oldValue = this.value
        this.value = value
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue)
          } catch (e) {
            handleError(e, this.vm, `callback for watcher &amp;quot;${this.expression}&amp;quot;`)
          }
        } else {
          // 回调
          this.cb.call(this.vm, value, oldValue)
        }
      }
    }
  }
	
	......
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Vue的初始化渲染过程简介</title>
      <link>https://xtid.github.io/2020/vue%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 27 Jul 2020 22:25:56 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/vue%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/</guid>
      <description>&lt;p&gt;首先进入到&lt;code&gt;src/core/instance/index.js&lt;/code&gt;，可以看到定义了一个&lt;code&gt;Vue&lt;/code&gt;构造函数，内容很简单，如果不是生产环境并且不是通过&lt;code&gt;new&lt;/code&gt;关键字创建对象的话，就在控制台打印一个&lt;code&gt;warn&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Vue (options) {
  if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp;
    !(this instanceof Vue)
  ) {
    warn(&#39;Vue is a constructor and should be called with the `new` keyword&#39;)
  }
  this._init(options)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后面调用了几个函数，用来在&lt;code&gt;Vue&lt;/code&gt;对象上创建各种属性或者方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;1.initMixin&lt;/h2&gt;

&lt;p&gt;初始化方法，首先为当前&lt;code&gt;vm&lt;/code&gt;设置一个&lt;code&gt;_uid&lt;/code&gt;，然后添加属性&lt;code&gt;_isVue&lt;/code&gt;，其目的在于监听数据变化时过滤&lt;code&gt;vm&lt;/code&gt;，&lt;code&gt;_isComponent&lt;/code&gt;是内部创建子组件时才会添加为&lt;code&gt;true&lt;/code&gt;的属性，然后走到&lt;code&gt;else&lt;/code&gt;分支，调用&lt;code&gt;resolveConstructorOptions&lt;/code&gt;会获取构造器父级的&lt;code&gt;options&lt;/code&gt;，然后调用&lt;code&gt;mergeOptions&lt;/code&gt;合并父级的&lt;code&gt;options&lt;/code&gt;以及本身传入的&lt;code&gt;options&lt;/code&gt;，最后生成的&lt;code&gt;options&lt;/code&gt;包含&lt;code&gt;components、directives&lt;/code&gt;等属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function initMixin (Vue: Class&amp;lt;Component&amp;gt;) {
  Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
    // a uid
    vm._uid = uid++

    let startTag, endTag
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; config.performance &amp;amp;&amp;amp; mark) {
      startTag = `vue-perf-start:${vm._uid}`
      endTag = `vue-perf-end:${vm._uid}`
      mark(startTag)
    }

    // a flag to avoid this being observed
    vm._isVue = true
    // merge options
    if (options &amp;amp;&amp;amp; options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options)
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== &#39;production&#39;) {
      initProxy(vm)
    } else {
      vm._renderProxy = vm
    }
    // expose real self
    vm._self = vm
    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    callHook(vm, &#39;beforeCreate&#39;)
    initInjections(vm) // resolve injections before data/props
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    callHook(vm, &#39;created&#39;)

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; config.performance &amp;amp;&amp;amp; mark) {
      vm._name = formatComponentName(vm, false)
      mark(endTag)
      measure(`vue ${vm._name} init`, startTag, endTag)
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt; 1.1initLifecycle &lt;/h3&gt;

&lt;p&gt;这个方法首先会设置&lt;code&gt;vm&lt;/code&gt;的一个父子节点、根节点信息，然后会定义一些生命周期相关的属性，比如&lt;code&gt;_isMounted、_isDestroyed、_isBeingDestroyed&lt;/code&gt;等&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function initLifecycle (vm: Component) {
  const options = vm.$options

  // locate first non-abstract parent
  let parent = options.parent
  if (parent &amp;amp;&amp;amp; !options.abstract) {
    while (parent.$options.abstract &amp;amp;&amp;amp; parent.$parent) {
      parent = parent.$parent
    }
    parent.$children.push(vm)
  }

  vm.$parent = parent
  vm.$root = parent ? parent.$root : vm

  vm.$children = []
  vm.$refs = {}

  vm._watcher = null
  vm._inactive = null
  vm._directInactive = false
  vm._isMounted = false
  vm._isDestroyed = false
  vm._isBeingDestroyed = false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt; 1.2initEvents &lt;/h3&gt;

&lt;p&gt;通过名字可以看出是一个初始化事件相关的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function initEvents (vm: Component) {
  // events表示父组件绑定在当前组件上的事件
  vm._events = Object.create(null)
  // 属性表示父组件是否通过&amp;quot;@hook:&amp;quot;把钩子函数绑定在当前组件上
  vm._hasHookEvent = false
  // init parent attached events
  // 同样是来表示父组件绑定在当前组件上的事件
  const listeners = vm.$options._parentListeners
  if (listeners) {
    updateComponentListeners(vm, listeners)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果&lt;code&gt;listeners&lt;/code&gt;有值，则调用&lt;code&gt;updateComponentListeners&lt;/code&gt;这个方法，其内部调用了&lt;code&gt;updateListeners&lt;/code&gt;，其中的&lt;code&gt;add&lt;/code&gt;方法会调用&lt;code&gt;vm.$on&lt;/code&gt;，&lt;code&gt;vm.$on&lt;/code&gt;会监听当前实例上的自定义事件，&lt;code&gt;remove&lt;/code&gt;会调用&lt;code&gt;vm.$off&lt;/code&gt;，移出这个事件监听&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function add (event, fn) {
  target.$on(event, fn)
}

function remove (event, fn) {
  target.$off(event, fn)
}

export function updateComponentListeners (
  vm: Component,
  listeners: Object,
  oldListeners: ?Object
) {
  // 保存当前的vm引用
  target = vm
  // 传入listeners，父组件绑定在当前组件上的事件，oldListeners同理，不过在第一次初始化的时候为空
  // 其内部会遍历listeners调用add方法添加监听事件，同时移出oldListeners
  updateListeners(listeners, oldListeners || {}, add, remove, createOnceHandler, vm)
  target = undefined
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt; 1.3initRender &lt;/h3&gt;

&lt;p&gt;主要是添加了一些虚拟dom、&lt;code&gt;slot&lt;/code&gt;等相关的属性和方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function initRender (vm: Component) {
  // 表示虚拟dom节点
  vm._vnode = null 
  // 表示当前实例render得到的Vnode
  vm._staticTrees = null 
  const options = vm.$options
  const parentVnode = vm.$vnode = options._parentVnode  tree
  const renderContext = parentVnode &amp;amp;&amp;amp; parentVnode.context
  // 生成插槽内容
  vm.$slots = resolveSlots(options._renderChildren, renderContext)
  // 作用域插槽，此时为空
  vm.$scopedSlots = emptyObject
  vm._c = (a, b, c, d) =&amp;gt; createElement(vm, a, b, c, d, false)
  vm.$createElement = (a, b, c, d) =&amp;gt; createElement(vm, a, b, c, d, true)
  const parentData = parentVnode &amp;amp;&amp;amp; parentVnode.data
	......
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;resolveSlots&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function resolveSlots (
  children: ?Array&amp;lt;VNode&amp;gt;,
  context: ?Component
): { [key: string]: Array&amp;lt;VNode&amp;gt; } {
  if (!children || !children.length) {
    return {}
  }
  const slots = {}
  // 遍历当前节点chilren
  for (let i = 0, l = children.length; i &amp;lt; l; i++) {
    const child = children[i]
    // 获取data
    const data = child.data
    if (data &amp;amp;&amp;amp; data.attrs &amp;amp;&amp;amp; data.attrs.slot) {
      delete data.attrs.slot
    }
    if ((child.context === context || child.fnContext === context) &amp;amp;&amp;amp;
      data &amp;amp;&amp;amp; data.slot != null
    ) {
      // 拿到插槽名称
      const name = data.slot
      const slot = (slots[name] || (slots[name] = []))
      if (child.tag === &#39;template&#39;) {
        slot.push.apply(slot, child.children || [])
      } else {
        slot.push(child)
      }
    } else {
      // 如果 data.slot 不存在，则是默认插槽的内容，则把对应的 child 添加到 slots.defaults 中
      (slots.default || (slots.default = [])).push(child)
    }
  }
  // 最后过滤一些空内容
  for (const name in slots) {
    if (slots[name].every(isWhitespace)) {
      delete slots[name]
    }
  }
  return slots
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用钩子函数&lt;code&gt;beforeCreate&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt; 1.4initProvide和initInjection &lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === &#39;function&#39;
      ? provide.call(vm)
    : provide;
  }
}
function initInjections (vm) {
  // 获取当前节点上的inject属性
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    toggleObserving(false);
    // 遍历这些属性，defineReactive，将这些属性变成响应式的
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      {
        defineReactive$$1(vm, key, result[key], function () {
          warn(
            &amp;quot;Avoid mutating an injected value directly since the changes will be &amp;quot; +
            &amp;quot;overwritten whenever the provided component re-renders. &amp;quot; +
            &amp;quot;injection being mutated: \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot;&amp;quot;,
            vm
          );
        });
      }
    });
    toggleObserving(true);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt; 1.5initState &lt;/h3&gt;

&lt;p&gt;主要是初始化一些数据和属性，比如&lt;code&gt;props&lt;/code&gt;、&lt;code&gt;methods&lt;/code&gt;、&lt;code&gt;data&lt;/code&gt;、&lt;code&gt;computed&lt;/code&gt;、&lt;code&gt;watch&lt;/code&gt;,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch &amp;amp;&amp;amp; opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化&lt;code&gt;props&lt;/code&gt;属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function initProps (vm, propsOptions) {
  // 获取当前节点的props属性值
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  var isRoot = !vm.$parent;
  // 用于保存当前组件的props里的key，以便之后在父组件更新props时可以直接使用数组迭代
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  if (!isRoot) {
    toggleObserving(false);
  }
  var loop = function ( key ) {
    keys.push(key);
    // validateProp验证当前prop[key]是否propsOptions定义的要求
    var value = validateProp(key, propsOptions, propsData, vm);
    {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          (&amp;quot;\&amp;quot;&amp;quot; + hyphenatedKey + &amp;quot;\&amp;quot; is a reserved attribute and cannot be used as component prop.&amp;quot;),
          vm
        );
      }
      // 添加响应式属性，这样props里面的值改变之后，组件会自动更新视图
      defineReactive$$1(props, key, value, function () {
        if (!isRoot &amp;amp;&amp;amp; !isUpdatingChildComponent) {
          warn(
            &amp;quot;Avoid mutating a prop directly since the value will be &amp;quot; +
            &amp;quot;overwritten whenever the parent component re-renders. &amp;quot; +
            &amp;quot;Instead, use a data or computed property based on the prop&#39;s &amp;quot; +
            &amp;quot;value. Prop being mutated: \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot;&amp;quot;,
            vm
          );
        }
      });
    }
    // static props are already proxied on the component&#39;s prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, &amp;quot;_props&amp;quot;, key);
    }
  };
	// 循环遍历key
  for (var key in propsOptions) loop( key );
  toggleObserving(true);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化&lt;code&gt;methods&lt;/code&gt;属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function initMethods (vm, methods) {
  // props属性用于判断methods中的方法名是否和props的属性重名
  var props = vm.$options.props;
  for (var key in methods) {
    {
      if (typeof methods[key] !== &#39;function&#39;) {
        warn(
          &amp;quot;Method \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot; has type \&amp;quot;&amp;quot; + (typeof methods[key]) + &amp;quot;\&amp;quot; in the component definition. &amp;quot; +
          &amp;quot;Did you reference the function correctly?&amp;quot;,
          vm
        );
      }
      // 如果props中有同名属性，则报错
      if (props &amp;amp;&amp;amp; hasOwn(props, key)) {
        warn(
          (&amp;quot;Method \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot; has already been defined as a prop.&amp;quot;),
          vm
        );
      }
      // 如果key是以$或_开头则，也报错
      if ((key in vm) &amp;amp;&amp;amp; isReserved(key)) {
        warn(
          &amp;quot;Method \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot; conflicts with an existing Vue instance method. &amp;quot; +
          &amp;quot;Avoid defining component methods that start with _ or $.&amp;quot;
        );
      }
    }
    vm[key] = typeof methods[key] !== &#39;function&#39; ? noop : bind(methods[key], vm);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化&lt;code&gt;data&lt;/code&gt;属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function initData (vm) {
  // 获取data属性
  var data = vm.$options.data;
  // 如果data是一个function，则调用getData返回里面的值，否则直接将data属性赋给_data
  data = vm._data = typeof data === &#39;function&#39;
    ? getData(data, vm)
  : data || {};
  // 如果data属性不是一个对象，设置data为空对象，并打印一个warn
  if (!isPlainObject(data)) {
    data = {};
    warn(
      &#39;data functions should return an object:\n&#39; +
      &#39;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#39;,
      vm
    );
  }
  // 获取data keys，props属性，methods属性
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    {
      // 当前data的key如果和methods中的方法重名，抛出警告
      if (methods &amp;amp;&amp;amp; hasOwn(methods, key)) {
        warn(
          (&amp;quot;Method \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot; has already been defined as a data property.&amp;quot;),
          vm
        );
      }
    }
    // 当前data的key如果和props中的属性重名，抛出警告
    if (props &amp;amp;&amp;amp; hasOwn(props, key)) {
      warn(
        &amp;quot;The data property \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot; is already declared as a prop. &amp;quot; +
        &amp;quot;Use prop default value instead.&amp;quot;,
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, &amp;quot;_data&amp;quot;, key);
    }
  }
  // 双向数据绑定data
  observe(data, true /* asRootData */);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化&lt;code&gt;computed&lt;/code&gt;属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function initComputed (vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    // 每个computed key所定义的方法
    var userDef = computed[key];
    // 将该方法赋值给getter变量
    var getter = typeof userDef === &#39;function&#39; ? userDef : userDef.get;
    if (getter == null) {
			// 如果为空，打印错误
      warn(
        (&amp;quot;Getter is missing for computed property \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot;.&amp;quot;),
        vm
      );
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }

    // 如果当前节点computed上未有key这个方法
    if (!(key in vm)) {
      // defineComputed方法主要是为当前节点的computed属性添加响应式更新方法
      // 可以在defineComputed定义最后看到 Object.defineProperty(target, key, sharedPropertyDefinition) 
      defineComputed(vm, key, userDef);
    } else {
      if (key in vm.$data) {
        warn((&amp;quot;The computed property \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot; is already defined in data.&amp;quot;), vm);
      } else if (vm.$options.props &amp;amp;&amp;amp; key in vm.$options.props) {
        warn((&amp;quot;The computed property \&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot; is already defined as a prop.&amp;quot;), vm);
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化&lt;code&gt;watch&lt;/code&gt;属性比较简单，在做了相应的判断后直接添加一个响应式更新属性，这里不多赘述，调用完&lt;code&gt;initState&lt;/code&gt;之后，会调用&lt;code&gt;created&lt;/code&gt;钩子函数，此时&lt;code&gt;vm&lt;/code&gt;上的属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// _init
vm._uid = 0
vm._isVue = true
vm.$options = {
  components: {
    KeepAlive,
    Transition,
    TransitionGroup
  },
  directives: {
    model,
    show
  },
  methods: {},
  computed: {},
  watch: {},
  filters: {},
  _base: Vue,
  el: &#39;#app&#39;,
  data: function mergedInstanceDataFn(){}
}
vm._renderProxy = vm
vm._self = vm

// initLifecycle
vm.$parent = parent
vm.$root = parent ? parent.$root : vm

vm.$children = []
vm.$refs = {}

vm._watcher = null
vm._inactive = null
vm._directInactive = false
vm._isMounted = false
vm._isDestroyed = false
vm._isBeingDestroyed = false

// initEvents	
vm._events = Object.create(null)
vm._hasHookEvent = false

// initRender
vm.$vnode = null  
vm._vnode = null
vm._staticTrees = null
vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext)
vm.$scopedSlots = emptyObject

vm._c = (a, b, c, d) =&amp;gt; createElement(vm, a, b, c, d, false)

vm.$createElement = (a, b, c, d) =&amp;gt; createElement(vm, a, b, c, d, true)
// 在 initState 中添加的属性
vm._watchers = []
vm._data
vm.message
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行完上面步骤后，会调用&lt;code&gt;vm.$mount&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 保存之前定义的$mount方法，然后重写Vue.prototype.$mount
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  // 查找当前节点
  el = el &amp;amp;&amp;amp; query(el)

 	// 如果事body元素或者documentElement元素则抛错
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; warn(
      `Do not mount Vue to &amp;lt;html&amp;gt; or &amp;lt;body&amp;gt; - mount to normal elements instead.`
    )
    return this
  }
	
  // 拿到options
  const options = this.$options
  // 如果节点上没有render函数
  if (!options.render) {
    // 获取template，template可以是#id、模板字符串、dom元素
    let template = options.template
    if (template) {
      if (typeof template === &#39;string&#39;) {
        if (template.charAt(0) === &#39;#&#39;) {
          // 获取templatge innerHTML
          template = idToTemplate(template)
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) {
        // 如果不是#id、模板字符串，直接获取其innerHTML
        template = template.innerHTML
      } else {
        if (process.env.NODE_ENV !== &#39;production&#39;) {
          warn(&#39;invalid template option:&#39; + template, this)
        }
        return this
      }
    } else if (el) {
      // 如果没有template，则获取el以及其子内容作为模板
      template = getOuterHTML(el)
    }
    if (template) {
      ......
    }
  }
  // 有render函数，直接执行mount.call(this, el, hydrating)
  return mount.call(this, el, hydrating)
}

function getOuterHTML (el: Element): string {
  if (el.outerHTML) {
    return el.outerHTML
  } else {
    const container = document.createElement(&#39;div&#39;)
    container.appendChild(el.cloneNode(true))
    return container.innerHTML
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面最后调用了&lt;code&gt;mount.call(this, el, hydrating)&lt;/code&gt;，其方法对应于&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el &amp;amp;&amp;amp; inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}

  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el
	......
  // 调用beforeMount钩子函数
  callHook(vm, &#39;beforeMount&#39;)

  let updateComponent
	
  ......
  
  // 更新当前节点的方法
  updateComponent = () =&amp;gt; {
    // vm._render会返回一个render字符串，_update其内部会调用patch方法来进行节点的增删改
    vm._update(vm._render(), hydrating)
  }

	// 创建一个watch对象，在调用updateComponent之前会先调用before方法
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted &amp;amp;&amp;amp; !vm._isDestroyed) {
        // 如果是更新节点，调用beforeUpdate钩子函数
        callHook(vm, &#39;beforeUpdate&#39;)
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

   // 当页面渲染完成后，调用钩子函数mounted
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, &#39;mounted&#39;)
  }
  return vm
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Vue自定义指令</title>
      <link>https://xtid.github.io/2020/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Sun, 26 Jul 2020 22:35:47 +0800</pubDate>
      
      <guid>https://xtid.github.io/2020/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</guid>
      <description>&lt;p&gt;Vue自定义指令也分全局指令和局部指令两种，全局指令和局部指令的使用方法分别为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 全局指令使用方法
Vue.directive(&#39;test&#39;, {
  bind: function(){
    ...
  }
})

// 局部指令使用方法
Vue({
  directives: {
    test: {
      bind: function(){
    	...
  	  }
    }
  } 
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面写的&lt;code&gt;bind&lt;/code&gt;方法其实就是自定义指令的几个钩子函数之一，可以视情况添加其他的钩子函数，官方的介绍：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bind&lt;/code&gt;：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置&lt;/p&gt;

&lt;p&gt;&lt;code&gt;inserted&lt;/code&gt;：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)，实际应用场景：被绑定元素插入父节点后，做一些初始化的操作，比如改变颜色，字体大小等等&lt;/p&gt;

&lt;p&gt;&lt;code&gt;update&lt;/code&gt;：所在组件的&lt;code&gt;VNode&lt;/code&gt; 更新时调用，但是可能发生在其子 &lt;code&gt;VNode&lt;/code&gt; 更新之前，实际应用场景：被绑定元素状态/样式、内容发生改变时触发&lt;/p&gt;

&lt;p&gt;&lt;code&gt;componentUpdated&lt;/code&gt;：指令所在组件的 &lt;code&gt;VNode&lt;/code&gt;及其子&lt;code&gt;VNode&lt;/code&gt;全部更新后调用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;unbind&lt;/code&gt;：只调用一次，指令与元素解绑时调用，实际应用场景：当指令绑定的元素从 dom 中删除时触发，可在这个时候做一些需要的操作&lt;/p&gt;

&lt;p&gt;指令钩子函数会被传入以下参数：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;el&lt;/code&gt;：指令所绑定的元素，可以用来直接操作 DOM 。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;binding&lt;/code&gt;：一个对象，包含以下属性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt;：指令名，不包括 &lt;code&gt;v-&lt;/code&gt; 前缀。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;value&lt;/code&gt;：指令的绑定值，例如：&lt;code&gt;v-my-directive=&amp;quot;1 + 1&amp;quot;&lt;/code&gt; 中，绑定值为 &lt;code&gt;2&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;oldValue&lt;/code&gt;：指令绑定的前一个值，仅在 &lt;code&gt;update&lt;/code&gt; 和 &lt;code&gt;componentUpdated&lt;/code&gt; 钩子中可用。无论值是否改变都可用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;expression&lt;/code&gt;：字符串形式的指令表达式。例如 &lt;code&gt;v-my-directive=&amp;quot;1 + 1&amp;quot;&lt;/code&gt; 中，表达式为 &lt;code&gt;&amp;quot;1 + 1&amp;quot;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arg&lt;/code&gt;：传给指令的参数，可选。例如 &lt;code&gt;v-my-directive:foo&lt;/code&gt; 中，参数为 &lt;code&gt;&amp;quot;foo&amp;quot;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;modifiers&lt;/code&gt;：一个包含修饰符的对象。例如：&lt;code&gt;v-my-directive.foo.bar&lt;/code&gt; 中，修饰符对象为 &lt;code&gt;{ foo: true, bar: true }&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;vnode&lt;/code&gt;：Vue 编译生成的虚拟节点&lt;/p&gt;

&lt;p&gt;&lt;code&gt;oldVnode&lt;/code&gt;：上一个虚拟节点，仅在 &lt;code&gt;update&lt;/code&gt; 和 &lt;code&gt;componentUpdated&lt;/code&gt; 钩子中可用。&lt;/p&gt;

&lt;p&gt;在文件&lt;code&gt;src/core/global-api/index.js&lt;/code&gt;中可以看到&lt;code&gt;initAssetRegisters&lt;/code&gt;，这个方法会用来初始化&lt;code&gt;component&lt;/code&gt;以及&lt;code&gt;directive&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export function initGlobalAPI (Vue: GlobalAPI) {
  .
  .
  .

  initUse(Vue)
  initMixin(Vue)
  initExtend(Vue)
  initAssetRegisters(Vue)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;initGlobalAPI&lt;/code&gt;会接受两个参数，第一个参数代表指令的名字，第二个参数如果是函数，则会创建一个&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{ bind: definition, update: definition}&lt;/code&gt;对象，并将他赋值给&lt;code&gt;definition&lt;/code&gt;，这个对象会在生成&lt;code&gt;Vue&lt;/code&gt;实例的时候会合并到&lt;code&gt;vm.$options.directives&lt;/code&gt;上。顺便说一下这里面也对自定义&lt;code&gt;component&lt;/code&gt;进行一个处理，他会根据传入的组件定义创建一个&lt;code&gt;Vue&lt;/code&gt;子类，设置好&lt;code&gt;name&lt;/code&gt;或者&lt;code&gt;id&lt;/code&gt;，最后返回。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  ASSET_TYPES.forEach(type =&amp;gt; {
    Vue[type] = function (
      id: string,
      definition: Function | Object
    ): Function | Object | void {
      if (!definition) {
        return this.options[type + &#39;s&#39;][id]
      } else {
        /* istanbul ignore if */
        if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; type === &#39;component&#39;) {
          validateComponentName(id)
        }
        if (type === &#39;component&#39; &amp;amp;&amp;amp; isPlainObject(definition)) {
          definition.name = definition.name || id
          definition = this.options._base.extend(definition)
        }
        if (type === &#39;directive&#39; &amp;amp;&amp;amp; typeof definition === &#39;function&#39;) {
          definition = { bind: definition, update: definition }
        }
        this.options[type + &#39;s&#39;][id] = definition
        return definition
      }
    }
  })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指令的解析在&lt;code&gt;src/compiler/parser/index.js&lt;/code&gt;中完成，用正则匹配指令，在解析完&lt;code&gt;v-bind&lt;/code&gt;、&lt;code&gt;v-on&lt;/code&gt;等等原生的指令后，调用&lt;code&gt;addDirective&lt;/code&gt;，将指令属性添加到当前节点的&lt;code&gt;directives&lt;/code&gt;上。其中的正则&lt;code&gt;modifierRE&lt;/code&gt;会去掉修饰符，&lt;code&gt;dirRE&lt;/code&gt;是去掉前面的&lt;code&gt;v-&lt;/code&gt;，&lt;code&gt;argRE&lt;/code&gt;匹配冒号及后面的值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt; else { // normal directives
   name = name.replace(dirRE, &#39;&#39;)
   // parse arg
   const argMatch = name.match(argRE)
   const arg = argMatch &amp;amp;&amp;amp; argMatch[1]
   if (arg) {
     name = name.slice(0, -(arg.length + 1))
   }
   addDirective(el, name, rawName, value, arg, modifiers, list[i])
   if (process.env.NODE_ENV !== &#39;production&#39; &amp;amp;&amp;amp; name === &#39;model&#39;) {
     checkForAliasModel(el, value)
   }
 }


export function addDirective (
  el: ASTElement,
  name: string,
  rawName: string,
  value: string,
  arg: ?string,
  modifiers: ?ASTModifiers,
  range?: Range
) {
  (el.directives || (el.directives = [])).push(rangeSetItem({ name, rawName, value, arg, modifiers }, range))
  el.plain = false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译阶段，在&lt;code&gt;src/compiler/codegen/index.js&lt;/code&gt;中，调用&lt;code&gt;genDirectives&lt;/code&gt;，循环遍历&lt;code&gt;directives&lt;/code&gt;对象，最终生成对应的属性，生成的形式为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;directives:[{
  name: &#39;&#39;,
  rawName: &#39;&#39;,
  value: &#39;&#39;,
  expression: &#39;&#39;,
  arg: &#39;&#39;,
  modifiers: {}
}
...
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其代码为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;...      
res += `{name:&amp;quot;${dir.name}&amp;quot;,rawName:&amp;quot;${dir.rawName}&amp;quot;${
        dir.value ? `,value:(${dir.value}),expression:${JSON.stringify(dir.value)}` : &#39;&#39;
      }${
        dir.arg ? `,arg:&amp;quot;${dir.arg}&amp;quot;` : &#39;&#39;
      }${
        dir.modifiers ? `,modifiers:${JSON.stringify(dir.modifiers)}` : &#39;&#39;
      }},`
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，会在&lt;code&gt;src/core/vdom/modules/directives.js&lt;/code&gt;中调用&lt;code&gt;_update&lt;/code&gt;，这个方法的主要作用遍历指令对象，将上面的属性通过回调函数调用对应的钩子函数，然后处理，钩子函数即上面提到的&lt;code&gt;bind&lt;/code&gt;、&lt;code&gt;update&lt;/code&gt;、&lt;code&gt;inserted&lt;/code&gt;等&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function _update (oldVnode, vnode) {
  // 第一次实例化组件时，oldVnode是emptyNode
  const isCreate = oldVnode === emptyNode
  // 销毁组件时，vnode是emptyNode
  const isDestroy = vnode === emptyNode
  //normalizeDirectives函数是从组件的vm.$options.directives中获取指令的定义
  const oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context)
  const newDirs = normalizeDirectives(vnode.data.directives, vnode.context)

  const dirsWithInsert = []
  const dirsWithPostpatch = []

  let key, oldDir, dir
  for (key in newDirs) {
    //循环新vnode上绑定的指令
    oldDir = oldDirs[key]
    dir = newDirs[key]
    if (!oldDir) {
      // new directive, bind   =&amp;gt; 如果第一次绑定，则直接调用bind钩子函数
      callHook(dir, &#39;bind&#39;, vnode, oldVnode)
      if (dir.def &amp;amp;&amp;amp; dir.def.inserted) {
        //若同时还添加了inserted钩子，则会先把它添加到dirsWithInsert数组中。
        dirsWithInsert.push(dir)
      }
    } else {
      // existing directive, update   =&amp;gt;  如果不是第一次绑定，则调用update钩子函数
      dir.oldValue = oldDir.value
      dir.oldArg = oldDir.arg
      callHook(dir, &#39;update&#39;, vnode, oldVnode)
      if (dir.def &amp;amp;&amp;amp; dir.def.componentUpdated) {
         //若同时定义了componentUpdated钩子，则会先把它添加到dirsWithPostpatch数组中。
        dirsWithPostpatch.push(dir)
      }
    }
  }

  if (dirsWithInsert.length) {
    const callInsert = () =&amp;gt; {
      for (let i = 0; i &amp;lt; dirsWithInsert.length; i++) {
        callHook(dirsWithInsert[i], &#39;inserted&#39;, vnode, oldVnode)
      }
    }
    if (isCreate) {
       //如果是vnode是第一次创建，
      //则会把dirsWithInsert数组中的回调追加到vnode.data.hook.insert中执行
      mergeVNodeHook(vnode, &#39;insert&#39;, callInsert)
    } else {
      callInsert()
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, &#39;postpatch&#39;, () =&amp;gt; {
      for (let i = 0; i &amp;lt; dirsWithPostpatch.length; i++) {
        callHook(dirsWithPostpatch[i], &#39;componentUpdated&#39;, vnode, oldVnode)
      }
    })
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind  
        // 如果不是第一次创建，就调用旧vnode中新vnode不存在的指令的unbind钩子函数
        callHook(oldDirs[key], &#39;unbind&#39;, oldVnode, oldVnode, isDestroy)
      }
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>使用Canvas实现一个红包雨的效果</title>
      <link>https://xtid.github.io/2020/%E4%BD%BF%E7%94%A8canvas%E5%81%9A%E4%B8%80%E4%B8%AA%E7%BA%A2%E5%8C%85%E9%9B%A8%E7%9A%84%E6%95%88%E6%9E%9C/</link>
      <pubDate>Mon, 15 Jun 2020 18:12:19 +0700</pubDate>
      
      <guid>https://xtid.github.io/2020/%E4%BD%BF%E7%94%A8canvas%E5%81%9A%E4%B8%80%E4%B8%AA%E7%BA%A2%E5%8C%85%E9%9B%A8%E7%9A%84%E6%95%88%E6%9E%9C/</guid>
      <description>

&lt;p&gt;之前使用jQuery做了一个红包雨的效果，感觉不是很理想，创建过多DOM元素造成性能上的浪费，整个页面也不够丝滑流畅，这次该用Canvas做一个红包雨的效果&lt;/p&gt;

&lt;h3 id=&#34;1-核心原理&#34;&gt;1.核心原理&lt;/h3&gt;

&lt;p&gt;1.生成红包，设置好默认的背景图像，传入页面上所需的红包数量&lt;/p&gt;

&lt;p&gt;2.保存状态，利用Canvas的原生API实现页面的渲染，每次移动各个红包到不同位置，利用&lt;code&gt;window.requestAnimationFrame&lt;/code&gt;实现每一帧的动画绘制，使整个页面不会卡顿&lt;/p&gt;

&lt;p&gt;3.点击红包，计算是否点中红包，如果点中，则进行相应的事件处理&lt;/p&gt;

&lt;h3 id=&#34;2-具体实现&#34;&gt;2.具体实现&lt;/h3&gt;

&lt;p&gt;2.1定义一些基本变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;redEnvelopeArr: [], // 当前整个红包对象数组
itemSpeed: [], // 每个红包对象对应的一些属性，如下落速度，页面上所在的位置
count: 0, // 加载好的红包图片的数量
ctx: null, // Canvas context对象
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.2加载红包图片&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;loadImgs(totalCount) {
  const self = this
  const canvas = document.getElementById(&#39;canvas&#39;)
  if (canvas.width &amp;lt; window.innerWidth) {
    canvas.width = window.innerWidth
  }
  if (canvas.height &amp;lt; window.innerHeight) {
    canvas.height = window.innerHeight
  }
  return new Promise(resolve =&amp;gt; {
    for (let index = 0; index &amp;lt; totalCount; index++) {
      const image = new Image()
      image.src = &#39;&#39; // 图片地址
      image.onload = () =&amp;gt; {
        self.count++
        self.itemSpeed.push({
          speed: 0, // 开始下落的位置
          step: self.randomFloat(2, 6) // 每个红包下落的速度
        })
        self.redEnvelopeArr.push({
          x: self.randomFloat(0, window.innerWidth - 100),
          y: 0,
          img: image
        })
        if (self.count === totalCount) resolve() // 所有图片加载完成跳出
      }
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.2生成随机数的一个方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;randomFloat(low, high) {
  return low + Math.random() * (high - low)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.3绘制红包图片下落，这里做了一个旋转下落的效果，主要原理是利用&lt;code&gt;translate&lt;/code&gt;移动context位置，旋转一定角度后，将原点移动到之前位置，做一个旋转的效果，每次操作的时候记得&lt;code&gt;sava&lt;/code&gt;、&lt;code&gt;restore&lt;/code&gt;。当然如果不想做旋转效果，那直接用&lt;code&gt;drawImage&lt;/code&gt;每次画不同位置的红包就行了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;drawRedEnvelope() {
  const self = this
  self.ctx.width = 100 // 红包的宽度
  self.ctx.height = 120 // 红包的高度
  self.redEnvelopeArr.forEach((item, index) =&amp;gt; {
    const newRedEnvelope = {
      x: item.x, // 红包所在的x轴位置
      y: item.y + self.itemSpeed[index].step, // 红包所在的y轴位置，主要由下落速度决定
      img: item.img,
      speed: item.speed
    }
    self.ctx.save()
    self.redEnvelopeArr.splice(index, 1, newRedEnvelope)
    self.ctx.translate(item.x + 50, 60 + self.itemSpeed[index].speed)
    self.ctx.rotate(self.itemSpeed[index].speed * Math.PI / 180)
    self.ctx.translate(-item.x - 50, -60 - self.itemSpeed[index].speed)
    self.ctx.drawImage(item.img, item.x, self.itemSpeed[index].speed)
    self.ctx.restore()
    self.itemSpeed[index].speed += self.itemSpeed[index].step
    // self.ctx.drawImage(item.img, item.x, item.y, self.ctx.width, self.ctx.height)
  })
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.4使用&lt;code&gt;clearRect&lt;/code&gt;清除上一帧的效果，在调用&lt;code&gt;drawRedEnvelope&lt;/code&gt;绘制新一帧的效果，使用&lt;code&gt;requestAnimationFrame&lt;/code&gt;重复执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;moveRedEnvelope() {
  const self = this
  self.ctx.clearRect(0, 0, window.innerWidth, window.innerHeight)
  self.drawRedEnvelope()
  window.requestAnimationFrame(self.moveRedEnvelope.bind(this))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.5点击红包时，循环遍历判断当前点击位置是否在某个红包内，如果遇到多个红包重叠的情况，只需取最上面一个就行了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;redEnvelopeClick() {
  const self = this
  const canvas = document.getElementById(&#39;canvas&#39;)
  canvas.addEventListener(&#39;click&#39;, e =&amp;gt; {
    let result = {}
    this.redEnvelopeArr.forEach((item, index) =&amp;gt; {
      const distanceX = e.clientX - item.x
      const distanceY = e.clientY - item.y
      const withinX = distanceX &amp;gt; 0
      const withinY = distanceY &amp;gt; 0
      if (withinX &amp;amp;&amp;amp; withinY) {
        result = item // 最后的result返回，然后做一些处理
      }
    })
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;后言&#34;&gt;后言&lt;/h3&gt;

&lt;p&gt;以上就是主要内容，需要特别注意的是，点击完了某个红包需要找个时间点清空整个页面上的动画，还有就是具体的点击实现的业务逻辑需自己去处理&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>nodejs实现excel导出数据的功能</title>
      <link>https://xtid.github.io/2019/nodejs%E5%AE%9E%E7%8E%B0excel%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Sun, 10 Nov 2019 22:42:19 +0915</pubDate>
      
      <guid>https://xtid.github.io/2019/nodejs%E5%AE%9E%E7%8E%B0excel%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8A%9F%E8%83%BD/</guid>
      <description>&lt;p&gt;1.对于一些业务系统，很常见的一个功能就是将数据生成excel导出，其实在&lt;code&gt;nodejs&lt;/code&gt;中已经很多优秀的第三方库可以实现这个功能，我这里选择的是&lt;code&gt;node-xlsx&lt;/code&gt;这个模块，其实它的本质也是依赖的&lt;code&gt;xlsx&lt;/code&gt;这个模块。&lt;/p&gt;

&lt;p&gt;2.首先得将你需要的导出的数据组装好，并且设置好没一个列表的宽度，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 后台所返回的数据
let result = data || [];
// 遍历组装数据
result.map(item =&amp;gt; {
    xlsxData.push([1, 2, 3]);
});
// 设置每一列的宽度
let option = { 
    &#39;!cols&#39;: [{
        wch: 30
    }, {
        wch: 20
    }, {
        wch: 20
    }]
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.调用&lt;code&gt;node-xlsx&lt;/code&gt;模块的&lt;code&gt;build&lt;/code&gt;方法，将数据转换为字节流数据，并设置请求的响应头，下载保存，大致代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 后台所返回的数据
let result = data || [];

// 遍历组装数据
result.map(item =&amp;gt; {
    xlsxData.push([1, 2, 3]);
});

// 设置每一列的宽度
let option = { 
    &#39;!cols&#39;: [{
        wch: 30
    }, {
        wch: 20
    }, {
        wch: 20
    }]
};

// res为express或koa2请求的相应结果，此方法需在express或koa2框架下运行
getXlsxInfo(xlsxData, &#39;渠道粉丝统计数据&#39;, option, res);

// 生成Excel表格并下载
function getXlsxInfo(xlsxData, name, option, res) {
    const buffer = xlsx.build([{
        name: &#39;sheet&#39;,
        data: xlsxData
    }], option);
    res.setHeader(&#39;Content-Type&#39;, &#39;application/vnd.openxmlformats&#39;);
    res.setHeader(&#39;Content-Disposition&#39;, &#39;attachment; filename=&#39; + encodeURIComponent(name) + &#39;.xlsx&#39;);
    res.end(buffer, &#39;binary&#39;);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.有个坑就是使用这种方式下载，必须是直接访问你所写的&lt;code&gt;nodejs接口地址&lt;/code&gt;才能打开下载功能，若使用&lt;code&gt;ajax&lt;/code&gt;或&lt;code&gt;fetch&lt;/code&gt;等方式返回的会是乱码的形式。其原因在于，这两种方式的请求发送的数据不一样，后端解析返回头也不一样，异步请求是不能触发下载返回头的。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>