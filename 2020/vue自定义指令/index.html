<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  
  
  
  
  <link rel="prev" href="https://xtid.github.io/2020/%E4%BD%BF%E7%94%A8canvas%E5%81%9A%E4%B8%80%E4%B8%AA%E7%BA%A2%E5%8C%85%E9%9B%A8%E7%9A%84%E6%95%88%E6%9E%9C/" />
  <link rel="next" href="https://xtid.github.io/2020/vue%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/" />
  <link rel="canonical" href="https://xtid.github.io/2020/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" sizes="32x32" href="/favicon.ico">
  <link rel="icon" sizes="16x16" href="/favicon.ico">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           Vue自定义指令 | 👨🏻‍💻
       
  </title>
  <meta name="title" content="Vue自定义指令 | 👨🏻‍💻">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/xtid.github.io"
    },
    "articleSection" : "posts",
    "name" : "Vue自定义指令",
    "headline" : "Vue自定义指令",
    "description" : "Vue自定义指令也分全局指令和局部指令两种，全局指令和局部指令的使用方法分别为： \/\/ 全局指令使用方法 Vue.directive(\x27test\x27, { bind: function(){ ... } }) \/\/ 局部指令使用方法 Vue({ directives: { test: {",
    "inLanguage" : "zh-CN",
    "author" : "",
    "creator" : "",
    "publisher": "",
    "accountablePerson" : "",
    "copyrightHolder" : "",
    "copyrightYear" : "2020",
    "datePublished": "2020-07-26 22:35:47 \x2b0800 CST",
    "dateModified" : "2020-07-26 22:35:47 \x2b0800 CST",
    "url" : "https:\/\/xtid.github.io\/2020\/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4\/",
    "wordCount" : "2235",
    "keywords" : [  "👨🏻‍💻"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://xtid.github.io">👨🏻‍💻</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/links/" title="">Links</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://xtid.github.io">👨🏻‍💻</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/links/" title="">Links</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Vue自定义指令</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://xtid.github.io" rel="author"></a> with ♥ 
                <span class="post-time">
                on <time datetime=2020-07-26 itemprop="datePublished">July 26, 2020</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://xtid.github.io/categories/%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/"> 源码理解 </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        

        
        
     
          
          
          

          
          
          

          <p>Vue自定义指令也分全局指令和局部指令两种，全局指令和局部指令的使用方法分别为：</p>

<pre><code class="language-javascript">// 全局指令使用方法
Vue.directive('test', {
  bind: function(){
    ...
  }
})

// 局部指令使用方法
Vue({
  directives: {
    test: {
      bind: function(){
    	...
  	  }
    }
  } 
})
</code></pre>

<p>上面写的<code>bind</code>方法其实就是自定义指令的几个钩子函数之一，可以视情况添加其他的钩子函数，官方的介绍：</p>

<p><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置</p>

<p><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)，实际应用场景：被绑定元素插入父节点后，做一些初始化的操作，比如改变颜色，字体大小等等</p>

<p><code>update</code>：所在组件的<code>VNode</code> 更新时调用，但是可能发生在其子 <code>VNode</code> 更新之前，实际应用场景：被绑定元素状态/样式、内容发生改变时触发</p>

<p><code>componentUpdated</code>：指令所在组件的 <code>VNode</code>及其子<code>VNode</code>全部更新后调用</p>

<p><code>unbind</code>：只调用一次，指令与元素解绑时调用，实际应用场景：当指令绑定的元素从 dom 中删除时触发，可在这个时候做一些需要的操作</p>

<p>指令钩子函数会被传入以下参数：</p>

<p><code>el</code>：指令所绑定的元素，可以用来直接操作 DOM 。</p>

<p><code>binding</code>：一个对象，包含以下属性：</p>

<ul>
<li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</li>
<li><code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</li>
<li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li>
<li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。</li>
<li><code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li>
<li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>{ foo: true, bar: true }</code>。</li>
</ul>

<p><code>vnode</code>：Vue 编译生成的虚拟节点</p>

<p><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</p>

<p>在文件<code>src/core/global-api/index.js</code>中可以看到<code>initAssetRegisters</code>，这个方法会用来初始化<code>component</code>以及<code>directive</code></p>

<pre><code class="language-javascript">export function initGlobalAPI (Vue: GlobalAPI) {
  .
  .
  .

  initUse(Vue)
  initMixin(Vue)
  initExtend(Vue)
  initAssetRegisters(Vue)
}
</code></pre>

<p><code>initGlobalAPI</code>会接受两个参数，第一个参数代表指令的名字，第二个参数如果是函数，则会创建一个</p>

<p><code>{ bind: definition, update: definition}</code>对象，并将他赋值给<code>definition</code>，这个对象会在生成<code>Vue</code>实例的时候会合并到<code>vm.$options.directives</code>上。顺便说一下这里面也对自定义<code>component</code>进行一个处理，他会根据传入的组件定义创建一个<code>Vue</code>子类，设置好<code>name</code>或者<code>id</code>，最后返回。</p>

<pre><code class="language-javascript">  ASSET_TYPES.forEach(type =&gt; {
    Vue[type] = function (
      id: string,
      definition: Function | Object
    ): Function | Object | void {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if (process.env.NODE_ENV !== 'production' &amp;&amp; type === 'component') {
          validateComponentName(id)
        }
        if (type === 'component' &amp;&amp; isPlainObject(definition)) {
          definition.name = definition.name || id
          definition = this.options._base.extend(definition)
        }
        if (type === 'directive' &amp;&amp; typeof definition === 'function') {
          definition = { bind: definition, update: definition }
        }
        this.options[type + 's'][id] = definition
        return definition
      }
    }
  })
</code></pre>

<p>指令的解析在<code>src/compiler/parser/index.js</code>中完成，用正则匹配指令，在解析完<code>v-bind</code>、<code>v-on</code>等等原生的指令后，调用<code>addDirective</code>，将指令属性添加到当前节点的<code>directives</code>上。其中的正则<code>modifierRE</code>会去掉修饰符，<code>dirRE</code>是去掉前面的<code>v-</code>，<code>argRE</code>匹配冒号及后面的值</p>

<pre><code class="language-javascript"> else { // normal directives
   name = name.replace(dirRE, '')
   // parse arg
   const argMatch = name.match(argRE)
   const arg = argMatch &amp;&amp; argMatch[1]
   if (arg) {
     name = name.slice(0, -(arg.length + 1))
   }
   addDirective(el, name, rawName, value, arg, modifiers, list[i])
   if (process.env.NODE_ENV !== 'production' &amp;&amp; name === 'model') {
     checkForAliasModel(el, value)
   }
 }


export function addDirective (
  el: ASTElement,
  name: string,
  rawName: string,
  value: string,
  arg: ?string,
  modifiers: ?ASTModifiers,
  range?: Range
) {
  (el.directives || (el.directives = [])).push(rangeSetItem({ name, rawName, value, arg, modifiers }, range))
  el.plain = false
}
</code></pre>

<p>编译阶段，在<code>src/compiler/codegen/index.js</code>中，调用<code>genDirectives</code>，循环遍历<code>directives</code>对象，最终生成对应的属性，生成的形式为</p>

<pre><code class="language-javascript">directives:[{
  name: '',
  rawName: '',
  value: '',
  expression: '',
  arg: '',
  modifiers: {}
}
...
]
</code></pre>

<p>其代码为</p>

<pre><code class="language-javascript">...      
res += `{name:&quot;${dir.name}&quot;,rawName:&quot;${dir.rawName}&quot;${
        dir.value ? `,value:(${dir.value}),expression:${JSON.stringify(dir.value)}` : ''
      }${
        dir.arg ? `,arg:&quot;${dir.arg}&quot;` : ''
      }${
        dir.modifiers ? `,modifiers:${JSON.stringify(dir.modifiers)}` : ''
      }},`
...
</code></pre>

<p>最后，会在<code>src/core/vdom/modules/directives.js</code>中调用<code>_update</code>，这个方法的主要作用遍历指令对象，将上面的属性通过回调函数调用对应的钩子函数，然后处理，钩子函数即上面提到的<code>bind</code>、<code>update</code>、<code>inserted</code>等</p>

<pre><code class="language-javascript">function _update (oldVnode, vnode) {
  // 第一次实例化组件时，oldVnode是emptyNode
  const isCreate = oldVnode === emptyNode
  // 销毁组件时，vnode是emptyNode
  const isDestroy = vnode === emptyNode
  //normalizeDirectives函数是从组件的vm.$options.directives中获取指令的定义
  const oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context)
  const newDirs = normalizeDirectives(vnode.data.directives, vnode.context)

  const dirsWithInsert = []
  const dirsWithPostpatch = []

  let key, oldDir, dir
  for (key in newDirs) {
    //循环新vnode上绑定的指令
    oldDir = oldDirs[key]
    dir = newDirs[key]
    if (!oldDir) {
      // new directive, bind   =&gt; 如果第一次绑定，则直接调用bind钩子函数
      callHook(dir, 'bind', vnode, oldVnode)
      if (dir.def &amp;&amp; dir.def.inserted) {
        //若同时还添加了inserted钩子，则会先把它添加到dirsWithInsert数组中。
        dirsWithInsert.push(dir)
      }
    } else {
      // existing directive, update   =&gt;  如果不是第一次绑定，则调用update钩子函数
      dir.oldValue = oldDir.value
      dir.oldArg = oldDir.arg
      callHook(dir, 'update', vnode, oldVnode)
      if (dir.def &amp;&amp; dir.def.componentUpdated) {
         //若同时定义了componentUpdated钩子，则会先把它添加到dirsWithPostpatch数组中。
        dirsWithPostpatch.push(dir)
      }
    }
  }

  if (dirsWithInsert.length) {
    const callInsert = () =&gt; {
      for (let i = 0; i &lt; dirsWithInsert.length; i++) {
        callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode)
      }
    }
    if (isCreate) {
       //如果是vnode是第一次创建，
      //则会把dirsWithInsert数组中的回调追加到vnode.data.hook.insert中执行
      mergeVNodeHook(vnode, 'insert', callInsert)
    } else {
      callInsert()
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', () =&gt; {
      for (let i = 0; i &lt; dirsWithPostpatch.length; i++) {
        callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode)
      }
    })
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind  
        // 如果不是第一次创建，就调用旧vnode中新vnode不存在的指令的unbind钩子函数
        callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy)
      }
    }
  }
}

</code></pre>

    </div>

    

  
    <div class="post-tags">
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://xtid.github.io">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://xtid.github.io/2020/%E4%BD%BF%E7%94%A8canvas%E5%81%9A%E4%B8%80%E4%B8%AA%E7%BA%A2%E5%8C%85%E9%9B%A8%E7%9A%84%E6%95%88%E6%9E%9C/" class="prev" rel="prev" title="使用Canvas实现一个红包雨的效果"><i class="iconfont icon-left"></i>&nbsp;使用Canvas实现一个红包雨的效果</a>
         
        
        <a href="https://xtid.github.io/2020/vue%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/" class="next" rel="next" title="Vue的初始化渲染过程简介">Vue的初始化渲染过程简介&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2019 - 2021</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  



     </div>
  </body>
</html>
