<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  
  
  
  
  <link rel="prev" href="https://xtid.github.io/2020/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/" />
  <link rel="next" href="https://xtid.github.io/2020/vue2.x%E9%87%8C%E9%9D%A2%E7%9A%84%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/" />
  <link rel="canonical" href="https://xtid.github.io/2020/vue%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" sizes="32x32" href="/favicon.ico">
  <link rel="icon" sizes="16x16" href="/favicon.ico">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           Vueçš„åˆå§‹åŒ–æ¸²æŸ“è¿‡ç¨‹ç®€ä»‹ | ğŸ‘¨ğŸ»â€ğŸ’»
       
  </title>
  <meta name="title" content="Vueçš„åˆå§‹åŒ–æ¸²æŸ“è¿‡ç¨‹ç®€ä»‹ | ğŸ‘¨ğŸ»â€ğŸ’»">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/xtid.github.io"
    },
    "articleSection" : "posts",
    "name" : "Vueçš„åˆå§‹åŒ–æ¸²æŸ“è¿‡ç¨‹ç®€ä»‹",
    "headline" : "Vueçš„åˆå§‹åŒ–æ¸²æŸ“è¿‡ç¨‹ç®€ä»‹",
    "description" : "é¦–å…ˆè¿›å…¥åˆ°src\/core\/instance\/index.jsï¼Œå¯ä»¥çœ‹åˆ°å®šä¹‰äº†ä¸€ä¸ªVueæ„é€ å‡½æ•°ï¼Œå†…å®¹å¾ˆç®€å•ï¼Œå¦‚æœä¸æ˜¯ç”Ÿäº§ç¯å¢ƒå¹¶ä¸”ä¸æ˜¯é€šè¿‡n",
    "inLanguage" : "zh-CN",
    "author" : "",
    "creator" : "",
    "publisher": "",
    "accountablePerson" : "",
    "copyrightHolder" : "",
    "copyrightYear" : "2020",
    "datePublished": "2020-07-27 22:25:56 \x2b0800 CST",
    "dateModified" : "2020-07-27 22:25:56 \x2b0800 CST",
    "url" : "https:\/\/xtid.github.io\/2020\/vue%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B\/",
    "wordCount" : "3980",
    "keywords" : [  "ğŸ‘¨ğŸ»â€ğŸ’»"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://xtid.github.io">ğŸ‘¨ğŸ»â€ğŸ’»</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://xtid.github.io">ğŸ‘¨ğŸ»â€ğŸ’»</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Vueçš„åˆå§‹åŒ–æ¸²æŸ“è¿‡ç¨‹ç®€ä»‹</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://xtid.github.io" rel="author"></a> with â™¥ 
                <span class="post-time">
                on <time datetime=2020-07-27 itemprop="datePublished">July 27, 2020</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://xtid.github.io/categories/%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/"> æºç ç†è§£ </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        

        
        
     
          
          
          

          
          
          

          <p>é¦–å…ˆè¿›å…¥åˆ°<code>src/core/instance/index.js</code>ï¼Œå¯ä»¥çœ‹åˆ°å®šä¹‰äº†ä¸€ä¸ª<code>Vue</code>æ„é€ å‡½æ•°ï¼Œå†…å®¹å¾ˆç®€å•ï¼Œå¦‚æœä¸æ˜¯ç”Ÿäº§ç¯å¢ƒå¹¶ä¸”ä¸æ˜¯é€šè¿‡<code>new</code>å…³é”®å­—åˆ›å»ºå¯¹è±¡çš„è¯ï¼Œå°±åœ¨æ§åˆ¶å°æ‰“å°ä¸€ä¸ª<code>warn</code></p>

<pre><code class="language-javascript">function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &amp;&amp;
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}
</code></pre>

<p>åé¢è°ƒç”¨äº†å‡ ä¸ªå‡½æ•°ï¼Œç”¨æ¥åœ¨<code>Vue</code>å¯¹è±¡ä¸Šåˆ›å»ºå„ç§å±æ€§æˆ–è€…æ–¹æ³•</p>

<pre><code class="language-javascript">initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)
</code></pre>

<h2>1.initMixin</h2>

<p>åˆå§‹åŒ–æ–¹æ³•ï¼Œé¦–å…ˆä¸ºå½“å‰<code>vm</code>è®¾ç½®ä¸€ä¸ª<code>_uid</code>ï¼Œç„¶åæ·»åŠ å±æ€§<code>_isVue</code>ï¼Œå…¶ç›®çš„åœ¨äºç›‘å¬æ•°æ®å˜åŒ–æ—¶è¿‡æ»¤<code>vm</code>ï¼Œ<code>_isComponent</code>æ˜¯å†…éƒ¨åˆ›å»ºå­ç»„ä»¶æ—¶æ‰ä¼šæ·»åŠ ä¸º<code>true</code>çš„å±æ€§ï¼Œç„¶åèµ°åˆ°<code>else</code>åˆ†æ”¯ï¼Œè°ƒç”¨<code>resolveConstructorOptions</code>ä¼šè·å–æ„é€ å™¨çˆ¶çº§çš„<code>options</code>ï¼Œç„¶åè°ƒç”¨<code>mergeOptions</code>åˆå¹¶çˆ¶çº§çš„<code>options</code>ä»¥åŠæœ¬èº«ä¼ å…¥çš„<code>options</code>ï¼Œæœ€åç”Ÿæˆçš„<code>options</code>åŒ…å«<code>componentsã€directives</code>ç­‰å±æ€§</p>

<pre><code class="language-javascript">export function initMixin (Vue: Class&lt;Component&gt;) {
  Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
    // a uid
    vm._uid = uid++

    let startTag, endTag
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {
      startTag = `vue-perf-start:${vm._uid}`
      endTag = `vue-perf-end:${vm._uid}`
      mark(startTag)
    }

    // a flag to avoid this being observed
    vm._isVue = true
    // merge options
    if (options &amp;&amp; options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options)
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm)
    } else {
      vm._renderProxy = vm
    }
    // expose real self
    vm._self = vm
    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    callHook(vm, 'beforeCreate')
    initInjections(vm) // resolve injections before data/props
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created')

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {
      vm._name = formatComponentName(vm, false)
      mark(endTag)
      measure(`vue ${vm._name} init`, startTag, endTag)
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
}
</code></pre>

<h3> 1.1initLifecycle </h3>

<p>è¿™ä¸ªæ–¹æ³•é¦–å…ˆä¼šè®¾ç½®<code>vm</code>çš„ä¸€ä¸ªçˆ¶å­èŠ‚ç‚¹ã€æ ¹èŠ‚ç‚¹ä¿¡æ¯ï¼Œç„¶åä¼šå®šä¹‰ä¸€äº›ç”Ÿå‘½å‘¨æœŸç›¸å…³çš„å±æ€§ï¼Œæ¯”å¦‚<code>_isMountedã€_isDestroyedã€_isBeingDestroyed</code>ç­‰</p>

<pre><code class="language-javascript">export function initLifecycle (vm: Component) {
  const options = vm.$options

  // locate first non-abstract parent
  let parent = options.parent
  if (parent &amp;&amp; !options.abstract) {
    while (parent.$options.abstract &amp;&amp; parent.$parent) {
      parent = parent.$parent
    }
    parent.$children.push(vm)
  }

  vm.$parent = parent
  vm.$root = parent ? parent.$root : vm

  vm.$children = []
  vm.$refs = {}

  vm._watcher = null
  vm._inactive = null
  vm._directInactive = false
  vm._isMounted = false
  vm._isDestroyed = false
  vm._isBeingDestroyed = false
}
</code></pre>

<h3> 1.2initEvents </h3>

<p>é€šè¿‡åå­—å¯ä»¥çœ‹å‡ºæ˜¯ä¸€ä¸ªåˆå§‹åŒ–äº‹ä»¶ç›¸å…³çš„æ–¹æ³•</p>

<pre><code class="language-javascript">export function initEvents (vm: Component) {
  // eventsè¡¨ç¤ºçˆ¶ç»„ä»¶ç»‘å®šåœ¨å½“å‰ç»„ä»¶ä¸Šçš„äº‹ä»¶
  vm._events = Object.create(null)
  // å±æ€§è¡¨ç¤ºçˆ¶ç»„ä»¶æ˜¯å¦é€šè¿‡&quot;@hook:&quot;æŠŠé’©å­å‡½æ•°ç»‘å®šåœ¨å½“å‰ç»„ä»¶ä¸Š
  vm._hasHookEvent = false
  // init parent attached events
  // åŒæ ·æ˜¯æ¥è¡¨ç¤ºçˆ¶ç»„ä»¶ç»‘å®šåœ¨å½“å‰ç»„ä»¶ä¸Šçš„äº‹ä»¶
  const listeners = vm.$options._parentListeners
  if (listeners) {
    updateComponentListeners(vm, listeners)
  }
}
</code></pre>

<p>å¦‚æœ<code>listeners</code>æœ‰å€¼ï¼Œåˆ™è°ƒç”¨<code>updateComponentListeners</code>è¿™ä¸ªæ–¹æ³•ï¼Œå…¶å†…éƒ¨è°ƒç”¨äº†<code>updateListeners</code>ï¼Œå…¶ä¸­çš„<code>add</code>æ–¹æ³•ä¼šè°ƒç”¨<code>vm.$on</code>ï¼Œ<code>vm.$on</code>ä¼šç›‘å¬å½“å‰å®ä¾‹ä¸Šçš„è‡ªå®šä¹‰äº‹ä»¶ï¼Œ<code>remove</code>ä¼šè°ƒç”¨<code>vm.$off</code>ï¼Œç§»å‡ºè¿™ä¸ªäº‹ä»¶ç›‘å¬</p>

<pre><code class="language-javascript">function add (event, fn) {
  target.$on(event, fn)
}

function remove (event, fn) {
  target.$off(event, fn)
}

export function updateComponentListeners (
  vm: Component,
  listeners: Object,
  oldListeners: ?Object
) {
  // ä¿å­˜å½“å‰çš„vmå¼•ç”¨
  target = vm
  // ä¼ å…¥listenersï¼Œçˆ¶ç»„ä»¶ç»‘å®šåœ¨å½“å‰ç»„ä»¶ä¸Šçš„äº‹ä»¶ï¼ŒoldListenersåŒç†ï¼Œä¸è¿‡åœ¨ç¬¬ä¸€æ¬¡åˆå§‹åŒ–çš„æ—¶å€™ä¸ºç©º
  // å…¶å†…éƒ¨ä¼šéå†listenersè°ƒç”¨addæ–¹æ³•æ·»åŠ ç›‘å¬äº‹ä»¶ï¼ŒåŒæ—¶ç§»å‡ºoldListeners
  updateListeners(listeners, oldListeners || {}, add, remove, createOnceHandler, vm)
  target = undefined
}
</code></pre>

<h3> 1.3initRender </h3>

<p>ä¸»è¦æ˜¯æ·»åŠ äº†ä¸€äº›è™šæ‹Ÿdomã€<code>slot</code>ç­‰ç›¸å…³çš„å±æ€§å’Œæ–¹æ³•</p>

<pre><code class="language-javascript">export function initRender (vm: Component) {
  // è¡¨ç¤ºè™šæ‹ŸdomèŠ‚ç‚¹
  vm._vnode = null 
  // è¡¨ç¤ºå½“å‰å®ä¾‹renderå¾—åˆ°çš„Vnode
  vm._staticTrees = null 
  const options = vm.$options
  const parentVnode = vm.$vnode = options._parentVnode  tree
  const renderContext = parentVnode &amp;&amp; parentVnode.context
  // ç”Ÿæˆæ’æ§½å†…å®¹
  vm.$slots = resolveSlots(options._renderChildren, renderContext)
  // ä½œç”¨åŸŸæ’æ§½ï¼Œæ­¤æ—¶ä¸ºç©º
  vm.$scopedSlots = emptyObject
  vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false)
  vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true)
  const parentData = parentVnode &amp;&amp; parentVnode.data
	......
}
</code></pre>

<p><code>resolveSlots</code>æ–¹æ³•</p>

<pre><code class="language-javascript">export function resolveSlots (
  children: ?Array&lt;VNode&gt;,
  context: ?Component
): { [key: string]: Array&lt;VNode&gt; } {
  if (!children || !children.length) {
    return {}
  }
  const slots = {}
  // éå†å½“å‰èŠ‚ç‚¹chilren
  for (let i = 0, l = children.length; i &lt; l; i++) {
    const child = children[i]
    // è·å–data
    const data = child.data
    if (data &amp;&amp; data.attrs &amp;&amp; data.attrs.slot) {
      delete data.attrs.slot
    }
    if ((child.context === context || child.fnContext === context) &amp;&amp;
      data &amp;&amp; data.slot != null
    ) {
      // æ‹¿åˆ°æ’æ§½åç§°
      const name = data.slot
      const slot = (slots[name] || (slots[name] = []))
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || [])
      } else {
        slot.push(child)
      }
    } else {
      // å¦‚æœ data.slot ä¸å­˜åœ¨ï¼Œåˆ™æ˜¯é»˜è®¤æ’æ§½çš„å†…å®¹ï¼Œåˆ™æŠŠå¯¹åº”çš„ child æ·»åŠ åˆ° slots.defaults ä¸­
      (slots.default || (slots.default = [])).push(child)
    }
  }
  // æœ€åè¿‡æ»¤ä¸€äº›ç©ºå†…å®¹
  for (const name in slots) {
    if (slots[name].every(isWhitespace)) {
      delete slots[name]
    }
  }
  return slots
}
</code></pre>

<p>è°ƒç”¨é’©å­å‡½æ•°<code>beforeCreate</code></p>

<h3> 1.4initProvideå’ŒinitInjection </h3>

<pre><code class="language-javascript">function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
    : provide;
  }
}
function initInjections (vm) {
  // è·å–å½“å‰èŠ‚ç‚¹ä¸Šçš„injectå±æ€§
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    toggleObserving(false);
    // éå†è¿™äº›å±æ€§ï¼ŒdefineReactiveï¼Œå°†è¿™äº›å±æ€§å˜æˆå“åº”å¼çš„
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      {
        defineReactive$$1(vm, key, result[key], function () {
          warn(
            &quot;Avoid mutating an injected value directly since the changes will be &quot; +
            &quot;overwritten whenever the provided component re-renders. &quot; +
            &quot;injection being mutated: \&quot;&quot; + key + &quot;\&quot;&quot;,
            vm
          );
        });
      }
    });
    toggleObserving(true);
  }
}
</code></pre>

<h3> 1.5initState </h3>

<p>ä¸»è¦æ˜¯åˆå§‹åŒ–ä¸€äº›æ•°æ®å’Œå±æ€§ï¼Œæ¯”å¦‚<code>props</code>ã€<code>methods</code>ã€<code>data</code>ã€<code>computed</code>ã€<code>watch</code>,</p>

<pre><code class="language-javascript">function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}
</code></pre>

<p>åˆå§‹åŒ–<code>props</code>å±æ€§</p>

<pre><code class="language-javascript">function initProps (vm, propsOptions) {
  // è·å–å½“å‰èŠ‚ç‚¹çš„propså±æ€§å€¼
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  var isRoot = !vm.$parent;
  // ç”¨äºä¿å­˜å½“å‰ç»„ä»¶çš„propsé‡Œçš„keyï¼Œä»¥ä¾¿ä¹‹ååœ¨çˆ¶ç»„ä»¶æ›´æ–°propsæ—¶å¯ä»¥ç›´æ¥ä½¿ç”¨æ•°ç»„è¿­ä»£
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  if (!isRoot) {
    toggleObserving(false);
  }
  var loop = function ( key ) {
    keys.push(key);
    // validatePropéªŒè¯å½“å‰prop[key]æ˜¯å¦propsOptionså®šä¹‰çš„è¦æ±‚
    var value = validateProp(key, propsOptions, propsData, vm);
    {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          (&quot;\&quot;&quot; + hyphenatedKey + &quot;\&quot; is a reserved attribute and cannot be used as component prop.&quot;),
          vm
        );
      }
      // æ·»åŠ å“åº”å¼å±æ€§ï¼Œè¿™æ ·propsé‡Œé¢çš„å€¼æ”¹å˜ä¹‹åï¼Œç»„ä»¶ä¼šè‡ªåŠ¨æ›´æ–°è§†å›¾
      defineReactive$$1(props, key, value, function () {
        if (!isRoot &amp;&amp; !isUpdatingChildComponent) {
          warn(
            &quot;Avoid mutating a prop directly since the value will be &quot; +
            &quot;overwritten whenever the parent component re-renders. &quot; +
            &quot;Instead, use a data or computed property based on the prop's &quot; +
            &quot;value. Prop being mutated: \&quot;&quot; + key + &quot;\&quot;&quot;,
            vm
          );
        }
      });
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, &quot;_props&quot;, key);
    }
  };
	// å¾ªç¯éå†key
  for (var key in propsOptions) loop( key );
  toggleObserving(true);
}
</code></pre>

<p>åˆå§‹åŒ–<code>methods</code>å±æ€§</p>

<pre><code class="language-javascript">function initMethods (vm, methods) {
  // propså±æ€§ç”¨äºåˆ¤æ–­methodsä¸­çš„æ–¹æ³•åæ˜¯å¦å’Œpropsçš„å±æ€§é‡å
  var props = vm.$options.props;
  for (var key in methods) {
    {
      if (typeof methods[key] !== 'function') {
        warn(
          &quot;Method \&quot;&quot; + key + &quot;\&quot; has type \&quot;&quot; + (typeof methods[key]) + &quot;\&quot; in the component definition. &quot; +
          &quot;Did you reference the function correctly?&quot;,
          vm
        );
      }
      // å¦‚æœpropsä¸­æœ‰åŒåå±æ€§ï¼Œåˆ™æŠ¥é”™
      if (props &amp;&amp; hasOwn(props, key)) {
        warn(
          (&quot;Method \&quot;&quot; + key + &quot;\&quot; has already been defined as a prop.&quot;),
          vm
        );
      }
      // å¦‚æœkeyæ˜¯ä»¥$æˆ–_å¼€å¤´åˆ™ï¼Œä¹ŸæŠ¥é”™
      if ((key in vm) &amp;&amp; isReserved(key)) {
        warn(
          &quot;Method \&quot;&quot; + key + &quot;\&quot; conflicts with an existing Vue instance method. &quot; +
          &quot;Avoid defining component methods that start with _ or $.&quot;
        );
      }
    }
    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
  }
}
</code></pre>

<p>åˆå§‹åŒ–<code>data</code>å±æ€§</p>

<pre><code class="language-javascript">function initData (vm) {
  // è·å–dataå±æ€§
  var data = vm.$options.data;
  // å¦‚æœdataæ˜¯ä¸€ä¸ªfunctionï¼Œåˆ™è°ƒç”¨getDataè¿”å›é‡Œé¢çš„å€¼ï¼Œå¦åˆ™ç›´æ¥å°†dataå±æ€§èµ‹ç»™_data
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
  : data || {};
  // å¦‚æœdataå±æ€§ä¸æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œè®¾ç½®dataä¸ºç©ºå¯¹è±¡ï¼Œå¹¶æ‰“å°ä¸€ä¸ªwarn
  if (!isPlainObject(data)) {
    data = {};
    warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  // è·å–data keysï¼Œpropså±æ€§ï¼Œmethodså±æ€§
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    {
      // å½“å‰dataçš„keyå¦‚æœå’Œmethodsä¸­çš„æ–¹æ³•é‡åï¼ŒæŠ›å‡ºè­¦å‘Š
      if (methods &amp;&amp; hasOwn(methods, key)) {
        warn(
          (&quot;Method \&quot;&quot; + key + &quot;\&quot; has already been defined as a data property.&quot;),
          vm
        );
      }
    }
    // å½“å‰dataçš„keyå¦‚æœå’Œpropsä¸­çš„å±æ€§é‡åï¼ŒæŠ›å‡ºè­¦å‘Š
    if (props &amp;&amp; hasOwn(props, key)) {
      warn(
        &quot;The data property \&quot;&quot; + key + &quot;\&quot; is already declared as a prop. &quot; +
        &quot;Use prop default value instead.&quot;,
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, &quot;_data&quot;, key);
    }
  }
  // åŒå‘æ•°æ®ç»‘å®šdata
  observe(data, true /* asRootData */);
}
</code></pre>

<p>åˆå§‹åŒ–<code>computed</code>å±æ€§</p>

<pre><code class="language-javascript">function initComputed (vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    // æ¯ä¸ªcomputed keyæ‰€å®šä¹‰çš„æ–¹æ³•
    var userDef = computed[key];
    // å°†è¯¥æ–¹æ³•èµ‹å€¼ç»™getterå˜é‡
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if (getter == null) {
			// å¦‚æœä¸ºç©ºï¼Œæ‰“å°é”™è¯¯
      warn(
        (&quot;Getter is missing for computed property \&quot;&quot; + key + &quot;\&quot;.&quot;),
        vm
      );
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }

    // å¦‚æœå½“å‰èŠ‚ç‚¹computedä¸Šæœªæœ‰keyè¿™ä¸ªæ–¹æ³•
    if (!(key in vm)) {
      // defineComputedæ–¹æ³•ä¸»è¦æ˜¯ä¸ºå½“å‰èŠ‚ç‚¹çš„computedå±æ€§æ·»åŠ å“åº”å¼æ›´æ–°æ–¹æ³•
      // å¯ä»¥åœ¨defineComputedå®šä¹‰æœ€åçœ‹åˆ° Object.defineProperty(target, key, sharedPropertyDefinition) 
      defineComputed(vm, key, userDef);
    } else {
      if (key in vm.$data) {
        warn((&quot;The computed property \&quot;&quot; + key + &quot;\&quot; is already defined in data.&quot;), vm);
      } else if (vm.$options.props &amp;&amp; key in vm.$options.props) {
        warn((&quot;The computed property \&quot;&quot; + key + &quot;\&quot; is already defined as a prop.&quot;), vm);
      }
    }
  }
}
</code></pre>

<p>åˆå§‹åŒ–<code>watch</code>å±æ€§æ¯”è¾ƒç®€å•ï¼Œåœ¨åšäº†ç›¸åº”çš„åˆ¤æ–­åç›´æ¥æ·»åŠ ä¸€ä¸ªå“åº”å¼æ›´æ–°å±æ€§ï¼Œè¿™é‡Œä¸å¤šèµ˜è¿°ï¼Œè°ƒç”¨å®Œ<code>initState</code>ä¹‹åï¼Œä¼šè°ƒç”¨<code>created</code>é’©å­å‡½æ•°ï¼Œæ­¤æ—¶<code>vm</code>ä¸Šçš„å±æ€§</p>

<pre><code class="language-javascript">// _init
vm._uid = 0
vm._isVue = true
vm.$options = {
  components: {
    KeepAlive,
    Transition,
    TransitionGroup
  },
  directives: {
    model,
    show
  },
  methods: {},
  computed: {},
  watch: {},
  filters: {},
  _base: Vue,
  el: '#app',
  data: function mergedInstanceDataFn(){}
}
vm._renderProxy = vm
vm._self = vm

// initLifecycle
vm.$parent = parent
vm.$root = parent ? parent.$root : vm

vm.$children = []
vm.$refs = {}

vm._watcher = null
vm._inactive = null
vm._directInactive = false
vm._isMounted = false
vm._isDestroyed = false
vm._isBeingDestroyed = false

// initEvents	
vm._events = Object.create(null)
vm._hasHookEvent = false

// initRender
vm.$vnode = null  
vm._vnode = null
vm._staticTrees = null
vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext)
vm.$scopedSlots = emptyObject

vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false)

vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true)
// åœ¨ initState ä¸­æ·»åŠ çš„å±æ€§
vm._watchers = []
vm._data
vm.message
</code></pre>

<p>æ‰§è¡Œå®Œä¸Šé¢æ­¥éª¤åï¼Œä¼šè°ƒç”¨<code>vm.$mount</code></p>

<pre><code class="language-javascript">// ä¿å­˜ä¹‹å‰å®šä¹‰çš„$mountæ–¹æ³•ï¼Œç„¶åé‡å†™Vue.prototype.$mount
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  // æŸ¥æ‰¾å½“å‰èŠ‚ç‚¹
  el = el &amp;&amp; query(el)

 	// å¦‚æœäº‹bodyå…ƒç´ æˆ–è€…documentElementå…ƒç´ åˆ™æŠ›é”™
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' &amp;&amp; warn(
      `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`
    )
    return this
  }
	
  // æ‹¿åˆ°options
  const options = this.$options
  // å¦‚æœèŠ‚ç‚¹ä¸Šæ²¡æœ‰renderå‡½æ•°
  if (!options.render) {
    // è·å–templateï¼Œtemplateå¯ä»¥æ˜¯#idã€æ¨¡æ¿å­—ç¬¦ä¸²ã€domå…ƒç´ 
    let template = options.template
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          // è·å–templatge innerHTML
          template = idToTemplate(template)
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' &amp;&amp; !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) {
        // å¦‚æœä¸æ˜¯#idã€æ¨¡æ¿å­—ç¬¦ä¸²ï¼Œç›´æ¥è·å–å…¶innerHTML
        template = template.innerHTML
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) {
      // å¦‚æœæ²¡æœ‰templateï¼Œåˆ™è·å–elä»¥åŠå…¶å­å†…å®¹ä½œä¸ºæ¨¡æ¿
      template = getOuterHTML(el)
    }
    if (template) {
      ......
    }
  }
  // æœ‰renderå‡½æ•°ï¼Œç›´æ¥æ‰§è¡Œmount.call(this, el, hydrating)
  return mount.call(this, el, hydrating)
}

function getOuterHTML (el: Element): string {
  if (el.outerHTML) {
    return el.outerHTML
  } else {
    const container = document.createElement('div')
    container.appendChild(el.cloneNode(true))
    return container.innerHTML
  }
}
</code></pre>

<p>ä¸Šé¢æœ€åè°ƒç”¨äº†<code>mount.call(this, el, hydrating)</code>ï¼Œå…¶æ–¹æ³•å¯¹åº”äº</p>

<pre><code class="language-javascript">Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el &amp;&amp; inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}

  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el
	......
  // è°ƒç”¨beforeMounté’©å­å‡½æ•°
  callHook(vm, 'beforeMount')

  let updateComponent
	
  ......
  
  // æ›´æ–°å½“å‰èŠ‚ç‚¹çš„æ–¹æ³•
  updateComponent = () =&gt; {
    // vm._renderä¼šè¿”å›ä¸€ä¸ªrenderå­—ç¬¦ä¸²ï¼Œ_updateå…¶å†…éƒ¨ä¼šè°ƒç”¨patchæ–¹æ³•æ¥è¿›è¡ŒèŠ‚ç‚¹çš„å¢åˆ æ”¹
    vm._update(vm._render(), hydrating)
  }

	// åˆ›å»ºä¸€ä¸ªwatchå¯¹è±¡ï¼Œåœ¨è°ƒç”¨updateComponentä¹‹å‰ä¼šå…ˆè°ƒç”¨beforeæ–¹æ³•
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted &amp;&amp; !vm._isDestroyed) {
        // å¦‚æœæ˜¯æ›´æ–°èŠ‚ç‚¹ï¼Œè°ƒç”¨beforeUpdateé’©å­å‡½æ•°
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

   // å½“é¡µé¢æ¸²æŸ“å®Œæˆåï¼Œè°ƒç”¨é’©å­å‡½æ•°mounted
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, 'mounted')
  }
  return vm
}
</code></pre>

    </div>

    

  
    <div class="post-tags">
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> Â· 
                <span><a href="https://xtid.github.io">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://xtid.github.io/2020/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/" class="prev" rel="prev" title="Vueè‡ªå®šä¹‰æŒ‡ä»¤"><i class="iconfont icon-left"></i>&nbsp;Vueè‡ªå®šä¹‰æŒ‡ä»¤</a>
         
        
        <a href="https://xtid.github.io/2020/vue2.x%E9%87%8C%E9%9D%A2%E7%9A%84%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/" class="next" rel="next" title="Vue2.xé‡Œé¢çš„åŒå‘æ•°æ®ç»‘å®š">Vue2.xé‡Œé¢çš„åŒå‘æ•°æ®ç»‘å®š&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2019 - 2020</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  



     </div>
  </body>
</html>
