<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  
  
  
  
  <link rel="prev" href="https://xtid.github.io/2020/flutter%E5%90%84%E7%A7%8D%E8%B8%A9%E5%9D%91%E5%BF%83%E5%BE%97/" />
  
  <link rel="canonical" href="https://xtid.github.io/2021/react%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" sizes="32x32" href="/favicon.ico">
  <link rel="icon" sizes="16x16" href="/favicon.ico">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           React调度过程 | 👨🏻‍💻
       
  </title>
  <meta name="title" content="React调度过程 | 👨🏻‍💻">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/xtid.github.io"
    },
    "articleSection" : "posts",
    "name" : "React调度过程",
    "headline" : "React调度过程",
    "description" : "1.forwardRef 用来解决高阶组件传递ref的问题。它的用法就像是使用redux的时候，在外面包裹一层，通过...props的方式把外部的props传入到实",
    "inLanguage" : "zh-CN",
    "author" : "",
    "creator" : "",
    "publisher": "",
    "accountablePerson" : "",
    "copyrightHolder" : "",
    "copyrightYear" : "2021",
    "datePublished": "2021-01-05 23:02:17 \x2b0800 CST",
    "dateModified" : "2021-01-05 23:02:17 \x2b0800 CST",
    "url" : "https:\/\/xtid.github.io\/2021\/react%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B\/",
    "wordCount" : "7748",
    "keywords" : [  "👨🏻‍💻"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://xtid.github.io">👨🏻‍💻</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://xtid.github.io">👨🏻‍💻</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">React调度过程</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://xtid.github.io" rel="author"></a> with ♥ 
                <span class="post-time">
                on <time datetime=2021-01-05 itemprop="datePublished">January 5, 2021</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://xtid.github.io/categories/%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/"> 源码理解 </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        

        
        
     
          
          
          

          
          
          

          

<h2 id="1-forwardref">1.forwardRef</h2>

<p>用来解决高阶组件传递<code>ref</code>的问题。它的用法就像是使用<code>redux</code>的时候，在外面包裹一层，通过<code>...props</code>的方式把外部的<code>props</code>传入到实际组件</p>

<pre><code class="language-react">const TargetComponent = React.forwardRef((props, ref) =&gt; (
  &lt;TargetComponent ref={ref} /&gt;
))
</code></pre>

<h2 id="2-reactelement">2.ReactElement</h2>

<p><code>ReactElement</code>通过<code>createElement</code>创建，调用该方法需要传入三个参数：</p>

<ul>
<li>type</li>
<li>config</li>
<li>children</li>
</ul>

<p><code>type</code>指代这个<code>ReactElement</code>的类型</p>

<ul>
<li>字符串比如<code>div</code>，<code>p</code>代表原生DOM，称为<code>HostComponent</code></li>
<li>Class类型是我们继承自<code>Component</code>或者<code>PureComponent</code>的组件，称为<code>ClassComponent</code></li>
<li>方法就是<code>functional Component</code></li>
<li>原生提供的<code>Fragment</code>、<code>AsyncMode</code>等是Symbol，会被特殊处理</li>
<li>TODO: 是否有其他的</li>
</ul>

<p>从源码可以看出虽然创建的时候都是通过<code>config</code>传入的，但是<code>key</code>和<code>ref</code>不会跟其他<code>config</code>中的变量一起被处理，而是单独作为变量出现在<code>ReactElement</code>上。</p>

<p>从源码可以看出虽然创建的时候都是通过<code>config</code>传入的，但是<code>key</code>和<code>ref</code>不会跟其他<code>config</code>中的变量一起被处理，而是单独作为变量出现在<code>ReactElement</code>上。在最后创建<code>ReactElement</code>我们看到了这么一个变量<code>$$typeof</code>，在这里他是一个常量：<code>REACT_ELEMENT_TYPE</code></p>

<h2 id="3-react-children">3.React Children</h2>

<p><code>React</code>上面有有一个<code>Children</code>对象，上面有着<code>Children</code>定义</p>

<pre><code class="language-react">const React = {
  Children: {
    map,
    forEach,
    count,
    toArray,
    only,
  },
	......
}
</code></pre>

<p>找到定义</p>

<pre><code class="language-react">function mapChildren(children, func, context) {
  if (children == null) {
    return children
  }
  const result = []
  mapIntoWithKeyPrefixInternal(children, result, null, func, context)
  return result
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  let escapedPrefix = ''
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/'
  }
  const traverseContext = getPooledTraverseContext(
    array,
    escapedPrefix,
    func,
    context,
  )
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext)
  releaseTraverseContext(traverseContext)
}
</code></pre>

<p>可以看到后面调用了<code>getPooledTraverseContext</code>，这是从内容池中找到当前的<code>contex</code>t对象，操作完了之后<code>releaseTraverseContext</code>会把当前的<code>context</code>对象清空然后放回到<code>pool</code>中。然后调用<code>traverseAllChildren</code>，这个方法的作用就是递归调用<code>mapChildren</code>将所有<code>Children</code>铺平，直到当前元素是一个有效的<code>ReactElement</code></p>

<pre><code class="language-react">function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  const { result, keyPrefix, func, context } = bookKeeping

  let mappedChild = func.call(context, child, bookKeeping.count++)
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c =&gt; c)
  } else if (mappedChild != null) {
    if (isValidElement(mappedChild)) {
      mappedChild = cloneAndReplaceKey(
        mappedChild,
        keyPrefix +
          (mappedChild.key &amp;&amp; (!child || child.key !== mappedChild.key)
            ? escapeUserProvidedKey(mappedChild.key) + '/'
            : '') +
          childKey,
      )
    }
    result.push(mappedChild)
  }
}
</code></pre>

<p>使用方法</p>

<pre><code class="language-react">React.Children.map(this.props.children, function (child) {
    return &lt;li&gt;{child}&lt;/li&gt;;
})
</code></pre>

<h2 id="4-react中的数据结构">4.React中的数据结构</h2>

<p><code>Update</code> &amp;<code>UpdateQueue</code></p>

<pre><code class="language-react">export type Update&lt;State&gt; = {
  // 更新的过期时间
  expirationTime: ExpirationTime,

  // export const UpdateState = 0;
  // export const ReplaceState = 1;
  // export const ForceUpdate = 2;
  // export const CaptureUpdate = 3;
  // 指定更新的类型，值为以上几种
  tag: 0 | 1 | 2 | 3,
  // 更新内容，比如`setState`接收的第一个参数
  payload: any, // 当前DOM元素？
  // 对应的回调，`setState`，`render`都有
  callback: (() =&gt; mixed) | null,

  // 指向下一个更新
  next: Update&lt;State&gt; | null,
  // 指向下一个`side effect`
  nextEffect: Update&lt;State&gt; | null,
};

export type UpdateQueue&lt;State&gt; = {
  // 每次操作完更新之后的`state`
  baseState: State,

  // 队列中的第一个`Update`
  firstUpdate: Update&lt;State&gt; | null,
  // 队列中的最后一个`Update`
  lastUpdate: Update&lt;State&gt; | null,

  // 第一个捕获类型的`Update`
  firstCapturedUpdate: Update&lt;State&gt; | null,
  // 最后一个捕获类型的`Update`
  lastCapturedUpdate: Update&lt;State&gt; | null,

  // 第一个`side effect`
  firstEffect: Update&lt;State&gt; | null,
  // 最后一个`side effect`
  lastEffect: Update&lt;State&gt; | null,

  // 第一个和最后一个捕获产生的`side effect`
  firstCapturedEffect: Update&lt;State&gt; | null,
  lastCapturedEffect: Update&lt;State&gt; | null,
};
</code></pre>

<h2 id="5-初次reactdom-reander过程">5.初次ReactDOM.reander过程</h2>

<p>首先调用<code>legacyRenderSubtreeIntoContainer</code></p>

<pre><code class="language-react">ReactDOM = {
  render(
    element: React$Element&lt;any&gt;,
    container: DOMContainer,
    callback: ?Function,
  ) {
    return legacyRenderSubtreeIntoContainer(
      null,
      element,
      container,
      false,
      callback,
    )
  },
}
</code></pre>

<pre><code class="language-react">function legacyRenderSubtreeIntoContainer(
  parentComponent: ?React$Component&lt;any, any&gt;,
  children: ReactNodeList,
  container: DOMContainer,
  forceHydrate: boolean,
  callback: ?Function,
) {
  let root: Root = (container._reactRootContainer: any)
  if (!root) {
    // 生成root，当前传入的根container的_reactRootContainer指向生成的root
    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
      container,
      forceHydrate,
    )
    if (typeof callback === 'function') {
      const originalCallback = callback
      callback = function() {
        const instance = DOMRenderer.getPublicRootInstance(root._internalRoot)
        originalCallback.call(instance)
      }
    }
    // 首次render不比unbatchedUpdates
    DOMRenderer.unbatchedUpdates(() =&gt; {
      if (parentComponent != null) {
        // 一般不会出现
      } else {
        root.render(children, callback)
      }
    })
  } else {
    // 有root的情况
  }
  return DOMRenderer.getPublicRootInstance(root._internalRoot)
}
</code></pre>

<p><code>legacyCreateRootFromDOMContainer</code>方法生成<code>root</code>，返回的结果上的<code>_internalRoot</code>指向这个<code>root</code>。同时会调用<code>DOMRenderer.createContainer</code>创建<code>FiberRoot</code>，然后生成的<code>root</code>的<code>current</code>属性指向这个<code>FiberRoot</code></p>

<pre><code class="language-react">function legacyCreateRootFromDOMContainer(
  container: DOMContainer,
  forceHydrate: boolean,
): Root {
  const shouldHydrate =
    forceHydrate || shouldHydrateDueToLegacyHeuristic(container)
  // First clear any existing content.
  if (!shouldHydrate) {
    let warned = false
    let rootSibling
    while ((rootSibling = container.lastChild)) {
      container.removeChild(rootSibling)
    }
  }
  // Legacy roots are not async by default.
  const isConcurrent = false
  return new ReactRoot(container, isConcurrent, shouldHydrate)
}

function ReactRoot(
  container: Container,
  isConcurrent: boolean,
  hydrate: boolean,
) {
  const root = DOMRenderer.createContainer(container, isConcurrent, hydrate)
  this._internalRoot = root
}

ReactRoot.prototype.render = function(
  children: ReactNodeList,
  callback: ?() =&gt; mixed,
): Work {
  const root = this._internalRoot
  const work = new ReactWork()
  callback = callback === undefined ? null : callback
  if (__DEV__) {
    warnOnInvalidCallback(callback, 'render')
  }
  if (callback !== null) {
    work.then(callback)
  }
  DOMRenderer.updateContainer(children, root, null, work._onCommit)
  return work
}
</code></pre>

<p>可以看到还有个<code>updateContainer</code>方法</p>

<pre><code class="language-react">export function updateContainer(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component&lt;any, any&gt;,
  callback: ?Function,
): ExpirationTime {
  const current = container.current
  const currentTime = requestCurrentTime()
  const expirationTime = computeExpirationForFiber(currentTime, current)
  return updateContainerAtExpirationTime(
    element,
    container,
    parentComponent,
    expirationTime,
    callback,
  )
}

export function updateContainerAtExpirationTime(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component&lt;any, any&gt;,
  expirationTime: ExpirationTime,
  callback: ?Function,
) {
  // TODO: If this is a nested container, this won't be the root.
  const current = container.current
  const context = getContextForSubtree(parentComponent)
  if (container.context === null) {
    container.context = context
  } else {
    container.pendingContext = context
  }

  return scheduleRootUpdate(current, element, expirationTime, callback)
}
</code></pre>

<p>可以看到先生成一个时间<code>const expirationTime</code>，也就是这次更新的超时时间，然后调用<code>updateContainerAtExpirationTime</code>，然后调用<code>scheduleRootUpdate</code>进行调度</p>

<pre><code class="language-react">function scheduleRootUpdate(
  current: Fiber,
  element: ReactNodeList,
  expirationTime: ExpirationTime,
  callback: ?Function,
) {
  const update = createUpdate(expirationTime)

  update.payload = { element }

  callback = callback === undefined ? null : callback
  if (callback !== null) {
    warningWithoutStack(
      typeof callback === 'function',
      'render(...): Expected the last optional `callback` argument to be a ' +
        'function. Instead received: %s.',
      callback,
    )
    update.callback = callback
  }
  enqueueUpdate(current, update)

  scheduleWork(current, expirationTime)
  return expirationTime
}
</code></pre>

<p><code>scheduleRootUpdate</code>会调用<code>createUpdate</code>创建<code>Update</code>对象，其<code>playload</code>为<code>container</code>上面的<code>ReactNodeList</code>，然后调用<code>enqueueUpdate</code>生成一个双向列表队列，然后调用<code>scheduleWork</code>开始调用。上面的过程都是依赖的<code>FiberRoot</code></p>

<h2 id="6-expirationtime">6.expirationTime</h2>

<pre><code class="language-react">import MAX_SIGNED_31_BIT_INT from './maxSigned31BitInt';

export type ExpirationTime = number;

export const NoWork = 0;
export const Never = 1;
export const Sync = MAX_SIGNED_31_BIT_INT;

const UNIT_SIZE = 10;
const MAGIC_NUMBER_OFFSET = MAX_SIGNED_31_BIT_INT - 1;

// 1 unit of expiration time represents 10ms.
export function msToExpirationTime(ms: number): ExpirationTime {
  // Always add an offset so that we don't clash with the magic number for NoWork.
  return MAGIC_NUMBER_OFFSET - ((ms / UNIT_SIZE) | 0);
}

export function expirationTimeToMs(expirationTime: ExpirationTime): number {
  return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;
}

function ceiling(num: number, precision: number): number {
  return (((num / precision) | 0) + 1) * precision;
}

function computeExpirationBucket(
  currentTime,
  expirationInMs,
  bucketSizeMs,
): ExpirationTime {
  return (
    MAGIC_NUMBER_OFFSET -
    ceiling(
      MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE,
      bucketSizeMs / UNIT_SIZE,
    )
  );
}

export const LOW_PRIORITY_EXPIRATION = 5000;
export const LOW_PRIORITY_BATCH_SIZE = 250;

export function computeAsyncExpiration(
  currentTime: ExpirationTime,
): ExpirationTime {
  return computeExpirationBucket(
    currentTime,
    LOW_PRIORITY_EXPIRATION,
    LOW_PRIORITY_BATCH_SIZE,
  );
}

export const HIGH_PRIORITY_EXPIRATION = __DEV__ ? 500 : 150;
export const HIGH_PRIORITY_BATCH_SIZE = 100;

export function computeInteractiveExpiration(currentTime: ExpirationTime) {
  return computeExpirationBucket(
    currentTime,
    HIGH_PRIORITY_EXPIRATION,
    HIGH_PRIORITY_BATCH_SIZE,
  );
}

</code></pre>

<p>最后的计算公式为<code>((((currentTime - 2 + 5000 / 10) / 25) | 0) + 1) * 25</code>（公式存疑），也就是说最后的结果是以<code>25ms</code>为单位向上增加的，在<code>25ms</code>内，<code>react</code>这样做为的是让两次时间非常想尽的更新得到同样的<code>expirationTime</code>，然后他们的优先级就会判定一样，就会再一次更新中完成，也就是一个<code>batchedUpdates</code></p>

<p>计算当前<code>currentTime</code></p>

<pre><code class="language-react">function requestCurrentTime() {
  if (isRendering) {
    return currentSchedulerTime
  }
  findHighestPriorityRoot()
  if (
    nextFlushedExpirationTime === NoWork ||
    nextFlushedExpirationTime === Never
  ) {
    recomputeCurrentRendererTime()
    currentSchedulerTime = currentRendererTime
    return currentSchedulerTime
  }
  return currentSchedulerTime
}
</code></pre>

<p><code>react</code>为了避免每次计算<code>expirationTime</code>都要<code>Date now</code>，所以用<code>currentRendererTime</code>来保存了这个值，上面的<code>currentSchedulerTime</code>也是记录这个值的</p>

<p>首先</p>

<pre><code class="language-react">if (isRendering) {
  return currentSchedulerTime
}
</code></pre>

<p>这个<code>isRendering</code>只有在<code>performWorkOnRoot</code>的时候才会被设置为<code>true</code>，而其本身是一个同步的方法，不存在他执行到一半没有设置<code>isRendering</code>为<code>false</code>的时候就跳出，那么什么情况下会在这里出现新的<code>requestCurrentTime</code>呢？</p>

<ul>
<li>在生命周期方法中调用了<code>setState</code></li>
<li>需要挂起任务的时候</li>
</ul>

<p>也就是说 React 要求<strong>在一次<code>rendering</code>过程中，新产生的<code>update</code>用于计算过期时间的<code>current</code>必须跟目前的<code>renderTime</code>保持一致，同理在这个周期中所有产生的新的更新的过期时间都会保持一致！</strong></p>

<pre><code class="language-react">  findHighestPriorityRoot()
  if (
    nextFlushedExpirationTime === NoWork ||
    nextFlushedExpirationTime === Never
  ) {
    recomputeCurrentRendererTime()
    currentSchedulerTime = currentRendererTime
    return currentSchedulerTime
  }
</code></pre>

<p><code>findHighestPriorityRoot</code>找到优先级最高的节点，同时设置<code>nextFlushedExpirationTime</code>，然后if判断当前队列中没有更新的任务，就会重新计算当前时间，否则，还是返回最初的<code>currentSchedulerTime</code></p>

<h2 id="7-各种expirationtime">7.各种expirationTime</h2>

<ul>
<li><code>root.expirationTime</code></li>
<li><code>root.nextExpirationTimeToWorkOn</code></li>
<li><code>root.childExpirationTime</code></li>
<li><code>root.earliestPendingTime &amp; root.lastestPendingTime</code></li>
<li><code>root.earliestSuspendedTime &amp; root.lastestSuspendedTime</code></li>
<li><code>root.lastestPingedTime</code></li>
<li><code>nextFlushedExpirationTime</code></li>
<li><code>nextLatestAbsoluteTimeoutMs</code></li>
<li><code>currentRendererTime</code></li>
<li><code>currentSchedulerTime</code></li>
</ul>

<p><code>React</code>更新是从<code>FilberRoot</code>开始的，所以每次更新时都会遍历向上查找<code>FiberRoot</code>，而这个<code>childExpirationTime</code>会设置到每个父节点，代表其子节点<code>expirationTime</code></p>

<p><code>pendingTime</code>，在<code>FiberRoot</code>上有两个值<code>earliestPendingTime</code>和<code>lastestPedingTime</code>，他们是一对值，<strong>用来记录所有子树中需要进行渲染的更新的<code>expirationTime</code>的区间</strong></p>

<p><code>suspendedTime</code>，同样的在<code>ReactFiber</code>上有两个值<code>earliestSuspendedTime</code>和<code>lastestSuspendedTime</code>，<strong>这两个值是用来记录被挂起的任务的过期时间的</strong></p>

<p>首先我们定义一下什么情况下任务是被挂起的：</p>

<ul>
<li>出现可捕获的错误并且还有优先级更低的任务的情况下</li>
<li>当捕获到<code>thenable</code>，并且需要设置<code>onTimeout</code>的时候</li>
</ul>

<p><code>root.expirationTime</code>是用来标志当前渲染的过期时间的，请注意他只管本渲染周期，他并不管你现在的渲染目标是哪个，渲染目标是由<code>root.nextExpirationTimeToWorkOn</code>来决定的。</p>

<p>那么他们有什么区别呢？主要区别在于发挥作用的阶段</p>

<p><code>expirationTime</code>作用于调度阶段，主要指责是：</p>

<ul>
<li>决定是异步执行渲染还是同步执行渲染</li>
<li>作为<code>react-scheduler</code>的<code>timeout</code>标准，决定是否要优先渲染</li>
</ul>

<p><code>nextExpirationTimeToWorkOn</code>主要作用于渲染阶段：</p>

<ul>
<li>决定那些更新要在当前周期中被执行</li>
<li>通过跟每个节点的<code>expirationTime</code>比较决定该节点是否可以直接<code>bailout</code>（跳过）</li>
</ul>

<p>他们都是通过<code>pendingTime</code>、<code>suspenededTime</code>和<code>pingedTime</code>中删选出来的，唯一的不同是，<code>nextExpirationTimeToWorkOn</code>在没有<code>pending</code>或者<code>pinged</code>的任务的时候会选择最晚的<code>suspendedTime</code>，而<code>expirationTime</code>会选择最早的</p>

<p><code>expirationTime</code>的变化：</p>

<ul>
<li>在<code>scheduleWork</code>的时候通过<code>markPendingExpirationTime</code>设置</li>
<li>在<code>beginWork</code>的时候被设置为<code>NoWork</code></li>
<li>在<code>onUncaughtError</code>的时候设置为<code>NoWork</code></li>
<li><code>onSuspend</code>的时候又会设置回当次更新的<code>expirationTime</code></li>
</ul>

<h2 id="8-schedulework">8.scheduleWork</h2>

<p>上面说的在创建完更新队列后，就会调用<code>scheduleWork</code>调度了</p>

<pre><code class="language-react">function scheduleWork(fiber: Fiber, expirationTime: ExpirationTime) {
  const root = scheduleWorkToRoot(fiber, expirationTime);
  if (root === null) {
    if (__DEV__) {
      switch (fiber.tag) {
        case ClassComponent:
          warnAboutUpdateOnUnmounted(fiber, true);
          break;
        case FunctionComponent:
        case ForwardRef:
        case MemoComponent:
        case SimpleMemoComponent:
          warnAboutUpdateOnUnmounted(fiber, false);
          break;
      }
    }
    return;
  }
	
  // 此条件的意思是当前处理空闲阶段，没有render或者commit，并且下一次任务不为空，还有当前过期时间(优先级)高于下次的过期时间
  // 则清空队列
  // 例如上一个任务是异步任务（优先级很低，超时时间是 502ms），并且在上一个时间片（初始是 33ms）任务没有执行完，而且等待下一次requestIdleCallback的时候新的任务进来了，并且超时时间很短（52ms 或者 22ms 甚至是 Sync），那么优先级就变成了先执行当前任务，也就意味着上一个任务被打断了（interrupted）
  if (
    !isWorking &amp;&amp;
    nextRenderExpirationTime !== NoWork &amp;&amp;
    expirationTime &gt; nextRenderExpirationTime
  ) {
    interruptedBy = fiber;
    resetStack();
  }
  // 记录所有子节点的任务时间区间
  markPendingPriorityLevel(root, expirationTime);
  // 要么处于没有 work 的状态，要么只能在 render 阶段，要么有两个不同的root
  if (
    !isWorking ||
    isCommitting ||
    nextRoot !== root
  ) {
    const rootExpirationTime = root.expirationTime;
    requestWork(root, rootExpirationTime);
  }
  if (nestedUpdateCount &gt; NESTED_UPDATE_LIMIT) {
    // Reset this back to zero so subsequent updates don't throw.
    nestedUpdateCount = 0;
    invariant(
      false,
      'Maximum update depth exceeded. This can happen when a ' +
        'component repeatedly calls setState inside ' +
        'componentWillUpdate or componentDidUpdate. React limits ' +
        'the number of nested updates to prevent infinite loops.',
    );
  }
}
</code></pre>

<p>首先是调用<code>scheduleWorkToRoot</code>，这个方法的主要是更新当前任务对应<code>Filber</code>的到期时间</p>

<pre><code class="language-react">function scheduleWorkToRoot(fiber: Fiber, expirationTime): FiberRoot | null {
  recordScheduleUpdate();

  if (__DEV__) {
    if (fiber.tag === ClassComponent) {
      const instance = fiber.stateNode;
      warnAboutInvalidUpdates(instance);
    }
  }

  // 如果filber上的过期时间小于当前的过期时间，更新
  if (fiber.expirationTime &lt; expirationTime) {
    fiber.expirationTime = expirationTime;
  }
  let alternate = fiber.alternate;
  if (alternate !== null &amp;&amp; alternate.expirationTime &lt; expirationTime) {
    alternate.expirationTime = expirationTime;
  }
  // fiber.return 返回当前fiber的父节点
  let node = fiber.return;
  let root = null;
  if (node === null &amp;&amp; fiber.tag === HostRoot) {
    // 如果filber.return的值为null，设置root的值为根节点(fiber.stateNode)
    root = fiber.stateNode;
  } else {
    // 循环向上遍历，更新每个子节点的过期时间
    // 如果子节点的过期时间小于当前过期时间，则更新
    while (node !== null) {
      alternate = node.alternate;
      if (node.childExpirationTime &lt; expirationTime) {
        node.childExpirationTime = expirationTime;
        if (
          alternate !== null &amp;&amp;
          alternate.childExpirationTime &lt; expirationTime
        ) {
          alternate.childExpirationTime = expirationTime;
        }
      } else if (
        alternate !== null &amp;&amp;
        alternate.childExpirationTime &lt; expirationTime
      ) {
        alternate.childExpirationTime = expirationTime;
      }
      if (node.return === null &amp;&amp; node.tag === HostRoot) {
        root = node.stateNode;
        break;
      }
      node = node.return;
    }
  }
  ......
  return root;
}
</code></pre>

<p><code>requestWork</code></p>

<pre><code class="language-react">function requestWork(root: FiberRoot, expirationTime: ExpirationTime) {
  // 将root加入调度队列中，不会存在两个相同的 root 前后出现在队列中
  addRootToSchedule(root, expirationTime)
  if (isRendering) {
    return
  }

  if (isBatchingUpdates) {
    if (isUnbatchingUpdates) {
      nextFlushedRoot = root
      nextFlushedExpirationTime = Sync
      performWorkOnRoot(root, Sync, true)
    }
    return
  }

  // 根据expirationTime调用performSyncWork还是scheduleCallbackWithExpirationTime

  if (expirationTime === Sync) {
    performSyncWork()
  } else {
    // 异步调度，并且当前已经有异步任务，如果当前传入的任务优先级高，取消之前的调度，异步调度当前任务
    // 无异步任务，生成一个到期时间，调度
    scheduleCallbackWithExpirationTime(root, expirationTime)
  }
}
</code></pre>

<h2 id="9-performwork">9.performWork</h2>

<p><code>performAsyncWork</code> 为异步调用，一开始的<code>shouldYieldToRenderer</code>代表是否当前调度中有没有时间执行异步任务，若<code>shouldYieldToRenderer</code>返回<code>false</code>，则代表有，那么重新计算当前的<code>expirationTime</code>，更新所有的已过期的<code>root</code>任务的<code>nextExpirationTimeToWorkOn</code></p>

<pre><code class="language-react">let didYield: boolean = false;
function shouldYieldToRenderer() {
  if (didYield) {
    return true;
  }
  if (shouldYield()) {
    didYield = true;
    return true;
  }
  return false;
}

function performAsyncWork() {
  try {
    if (!shouldYieldToRenderer()) {
      // 如果当前还有调度的链表
      if (firstScheduledRoot !== null) {
        // 重新计算当前的一个expirationTime
        recomputeCurrentRendererTime();
        let root: FiberRoot = firstScheduledRoot;
        do {
          // 设置所有的已过期的root任务的nextExpirationTimeToWorkOn为当前计算出的expirationTime
          didExpireAtExpirationTime(root, currentRendererTime);
          root = (root.nextScheduledRoot: any);
        } while (root !== firstScheduledRoot);
      }
    }
    performWork(NoWork, true);
  } finally {
    didYield = false;
  }
}
</code></pre>

<p><code>performSyncWork</code></p>

<p>同步调度任务，方法很简单，直接调用<code>performWork</code></p>

<pre><code class="language-react">function performSyncWork() {
  performWork(Sync, false);
}
</code></pre>

<p><code>performWork</code></p>

<p>此方法为真正的调度方法，首先会调用<code>findHighestPriorityRoot</code>，找到当前队列优先级最高的<code>root</code>任务，命名为<code>nextFlushedRoot</code>，已经其对应的<code>expirationTime</code>，命名为<code>nextFlushedExpirationTime</code></p>

<pre><code class="language-react">function performWork(minExpirationTime: ExpirationTime, isYieldy: boolean) {
  findHighestPriorityRoot();

  if (isYieldy) {
    recomputeCurrentRendererTime();
    currentSchedulerTime = currentRendererTime;
		
    if (enableUserTimingAPI) {
      const didExpire = nextFlushedExpirationTime &gt; currentRendererTime;
      const timeout = expirationTimeToMs(nextFlushedExpirationTime);
      stopRequestCallbackTimer(didExpire, timeout);
    }

    while (
      nextFlushedRoot !== null &amp;&amp;
      nextFlushedExpirationTime !== NoWork &amp;&amp;
      minExpirationTime &lt;= nextFlushedExpirationTime &amp;&amp;
      !(didYield &amp;&amp; currentRendererTime &gt; nextFlushedExpirationTime)
    ) {
      performWorkOnRoot(
        nextFlushedRoot,
        nextFlushedExpirationTime,
        currentRendererTime &gt; nextFlushedExpirationTime,
      );
      findHighestPriorityRoot();
      recomputeCurrentRendererTime();
      currentSchedulerTime = currentRendererTime;
    }
  } else {
    while (
      nextFlushedRoot !== null &amp;&amp;
      nextFlushedExpirationTime !== NoWork &amp;&amp;
      minExpirationTime &lt;= nextFlushedExpirationTime
    ) {
      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);
      findHighestPriorityRoot();
    }
  }
  if (isYieldy) {
    callbackExpirationTime = NoWork;
    callbackID = null;
  }
  if (nextFlushedExpirationTime !== NoWork) {
    scheduleCallbackWithExpirationTime(
      ((nextFlushedRoot: any): FiberRoot),
      nextFlushedExpirationTime,
    );
  }
  finishRendering();
}

</code></pre>

<p>可以看到，不管同步异步，都有</p>

<pre><code class="language-react">while(
 nextFlushedRoot !== null &amp;&amp;
 nextFlushedExpirationTime !== NoWork &amp;&amp;
 minExpirationTime &lt;= nextFlushedExpirationTime
)
</code></pre>

<p>这是一个循环调度<code>root</code>任务的过程，判断条件为调度队列不为空，并且当前传入的任务优先级小于优先级最高的任务。异步调用时还有个额外的条件<code>!(didYield &amp;&amp; currentRendererTime &gt; nextFlushedExpirationTime)</code>，翻译过来就是当前传入的异步任务没过期，并且当前的渲染时间也没超过优先级最高的任务。然后这个循环就会在每次循环中调用<code>performWorkOnRoot</code></p>

<h2 id="10-performworkonroot">10.performWorkOnRoot</h2>

<p>这里是整个调度过程的提交、render过程。不同的是，在异步任务中有个判断</p>

<pre><code class="language-react">if (!shouldYieldToRenderer()) {
  completeRoot(root, finishedWork, expirationTime);
} else {
  root.finishedWork = finishedWork;
}
</code></pre>

<p>意思就是说如果当前没有时间处理异步任务，直接<code>completeRoot</code></p>

<pre><code class="language-react">function performWorkOnRoot(
  root: FiberRoot,
  expirationTime: ExpirationTime,
  isYieldy: boolean,
) {
  invariant(
    !isRendering,
    'performWorkOnRoot was called recursively. This error is likely caused ' +
      'by a bug in React. Please file an issue.',
  );

  isRendering = true;

  if (!isYieldy) {

    let finishedWork = root.finishedWork;
    if (finishedWork !== null) {
      completeRoot(root, finishedWork, expirationTime);
    } else {
      root.finishedWork = null;
      const timeoutHandle = root.timeoutHandle;
      if (timeoutHandle !== noTimeout) {
        root.timeoutHandle = noTimeout;
        cancelTimeout(timeoutHandle);
      }
      renderRoot(root, isYieldy);
      finishedWork = root.finishedWork;
      if (finishedWork !== null) {
        completeRoot(root, finishedWork, expirationTime);
      }
    }
  } else {
    let finishedWork = root.finishedWork;
    if (finishedWork !== null) {
      completeRoot(root, finishedWork, expirationTime);
    } else {
      root.finishedWork = null;
      const timeoutHandle = root.timeoutHandle;
      if (timeoutHandle !== noTimeout) {
        root.timeoutHandle = noTimeout;
        cancelTimeout(timeoutHandle);
      }
      renderRoot(root, isYieldy);
      finishedWork = root.finishedWork;
      if (finishedWork !== null) {
        if (!shouldYieldToRenderer()) {
          completeRoot(root, finishedWork, expirationTime);
        } else {
          root.finishedWork = finishedWork;
        }
      }
    }
  }
  isRendering = false;
}
</code></pre>

<h2 id="11-renderroot">11.renderRoot</h2>

<p>这个判断的意思就是如果当前没有其他的任务，那么就进行一些初始化的工作</p>

<pre><code class="language-react">if (
    expirationTime !== nextRenderExpirationTime ||
    root !== nextRoot ||
    nextUnitOfWork === null
  ) {
    resetStack();
    nextRoot = root;
    nextRenderExpirationTime = expirationTime;
    nextUnitOfWork = createWorkInProgress(
      nextRoot.current,
      null,
      nextRenderExpirationTime,
    );
		root.pendingCommitExpirationTime = NoWork;
		......
}
</code></pre>

<p>然后调用<code>workLoop</code>，对于异步任务，仍要判断是否有剩余时间处理此任务</p>

<pre><code class="language-react">  do {
    try {
      workLoop(isYieldy);
    } catch (thrownValue) {
      
    }
    break;
  } while (true);
</code></pre>

<pre><code class="language-react">function workLoop(isYieldy) {
  if (!isYieldy) {
    while (nextUnitOfWork !== null) {
      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    }
  } else {
    while (nextUnitOfWork !== null &amp;&amp; !shouldYieldToRenderer()) {
      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    }
  }
}
</code></pre>

<p>如果在这过程中会有报错，则停止调度，会在上面的<code>catch中</code>处理，并且设置<code>finishedWork</code>为<code>null</code>，从而结束这一次的<code>render</code></p>

<p><code>performUnitOfWork</code></p>

<pre><code class="language-react">function performUnitOfWork(workInProgress: Fiber): Fiber | null {
  const current = workInProgress.alternate;

  startWorkTimer(workInProgress);
  let next;
  ......
  if (enableProfilerTimer) {
    if (workInProgress.mode &amp; ProfileMode) {
      startProfilerTimer(workInProgress);
    }

    next = beginWork(current, workInProgress, nextRenderExpirationTime);
    workInProgress.memoizedProps = workInProgress.pendingProps;

    if (workInProgress.mode &amp; ProfileMode) {
      stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);
    }
  } else {
    next = beginWork(current, workInProgress, nextRenderExpirationTime);
    workInProgress.memoizedProps = workInProgress.pendingProps;
  }
  if (next === null) {
    next = completeUnitOfWork(workInProgress);
  }
	
  ......
  ReactCurrentOwner.current = null;

  return next;
}
</code></pre>

<p>首先执行<code>next = beginWork(current, workInProgress, nextRenderExpirationTime)</code>对节点进行操作，其内部会针对不同类型的节点进行创建，返回的结果即会赋值给<code>next</code>，<code>return next</code>。 如果<code>next === null</code>，说明子节点已经处理完，调用<code>next = completeUnitOfWork(workInProgress)</code>。</p>

<p><code>completeUnitOfWork</code>会从下往上遍历，处理<code>effact tag</code>，如果到<code>root</code>节点返回的是<code>null</code>，代表整棵树的遍历已经结束了，如果找到了其他兄弟节点，就返回这个节点，重新走一遍<code>workLoop</code></p>

<h2 id="12-updateclasscomponent">12.updateClassComponent</h2>

<p>在<code>beginWork</code>中，会针对不同的节点类型来调用不同的方法处理，这里以<code>ClassComponent</code>为例</p>

<pre><code class="language-react">function updateClassComponent(
  current: Fiber | null,
  workInProgress: Fiber,
  Component: any,
  nextProps,
  renderExpirationTime: ExpirationTime,
) {
	......
  // 对context进行处理
  let hasContext;
  // 如果当前组件是context provider
  // 设置hasContext标记
  if (isLegacyContextProvider(Component)) {
    hasContext = true;
    pushLegacyContextProvider(workInProgress);
  } else {
    hasContext = false;
  }
  prepareToReadContext(workInProgress, renderExpirationTime);

  const instance = workInProgress.stateNode;
  let shouldUpdate;
  // 如果实例为空
  if (instance === null) {
    if (current !== null) {
      current.alternate = null;
      workInProgress.alternate = null;
      workInProgress.effectTag |= Placement;
    }
    constructClassInstance(
      workInProgress,
      Component,
      nextProps,
      renderExpirationTime,
    );
    // 挂载这个实例
    mountClassInstance(
      workInProgress,
      Component,
      nextProps,
      renderExpirationTime,
    );
    shouldUpdate = true;
  } else if (current === null) {
    // 第一次渲染时，current为null
    // 重新挂载实例
    shouldUpdate = resumeMountClassInstance(
      workInProgress,
      Component,
      nextProps,
      renderExpirationTime,
    );
  } else {
    // 更新类组件的时候
    // 调用updateClassInstance
    shouldUpdate = updateClassInstance(
      current,
      workInProgress,
      Component,
      nextProps,
      renderExpirationTime,
    );
  }
  ......
  // 调用finishClassComponent
  // 如果需要更新，调用reconcileChildren，返回更新后的workInProgress
  const nextUnitOfWork = finishClassComponent(
    current,
    workInProgress,
    Component,
    shouldUpdate,
    hasContext,
    renderExpirationTime,
  );
  return nextUnitOfWork;
}
</code></pre>

<p><code>constructClassInstance</code></p>

<pre><code class="language-react">function constructClassInstance(
  workInProgress: Fiber,
  ctor: any,
  props: any,
  renderExpirationTime: ExpirationTime,
): any {
  .......
  adoptClassInstance(workInProgress, instance);
}
</code></pre>

<p><code>adoptClassInstance</code></p>

<pre><code class="language-react">function adoptClassInstance(workInProgress: Fiber, instance: any): void {
  instance.updater = classComponentUpdater;
  workInProgress.stateNode = instance;
  setInstance(instance, workInProgress);
	......
}
  
const classComponentUpdater = {
  isMounted,
  enqueueSetState(inst, payload, callback) {
  },
  enqueueReplaceState(inst, payload, callback) {
  },
  enqueueForceUpdate(inst, callback) {
};
</code></pre>

<p><code>classComponentUpdater</code>里面几个方法，即对应着<code>setState</code>、<code>replaceState</code>、<code>forceUpdate</code></p>

<p><code>mountClassInstance</code></p>

<pre><code class="language-react">function mountClassInstance(
  workInProgress: Fiber,
  ctor: any,
  newProps: any,
  renderExpirationTime: ExpirationTime,
): void {
  if (__DEV__) {
    checkClassInstance(workInProgress, ctor, newProps);
  }

  const instance = workInProgress.stateNode;
  // 初始化 props、state 等实例属性
  instance.props = newProps;
  instance.state = workInProgress.memoizedState;
  instance.refs = emptyRefsObject;

  const contextType = ctor.contextType;
  if (typeof contextType === 'object' &amp;&amp; contextType !== null) {
    instance.context = readContext(contextType);
  } else {
    const unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
    instance.context = getMaskedContext(workInProgress, unmaskedContext);
  }
	.......
	// 如果有updateQueue就更新
  let updateQueue = workInProgress.updateQueue;
  if (updateQueue !== null) {
    processUpdateQueue(
      workInProgress,
      updateQueue,
      newProps,
      instance,
      renderExpirationTime,
    );
    instance.state = workInProgress.memoizedState;
  }
	
	// 如果定义了getDerivedStateFromProps周期函数，则调用
  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  if (typeof getDerivedStateFromProps === 'function') {
    applyDerivedStateFromProps(
      workInProgress,
      ctor,
      getDerivedStateFromProps,
      newProps,
    );
    instance.state = workInProgress.memoizedState;
  }

  if (
    typeof ctor.getDerivedStateFromProps !== 'function' &amp;&amp;
    typeof instance.getSnapshotBeforeUpdate !== 'function' &amp;&amp;
    (typeof instance.UNSAFE_componentWillMount === 'function' ||
      typeof instance.componentWillMount === 'function')
  ) {
    callComponentWillMount(workInProgress, instance);
    updateQueue = workInProgress.updateQueue;
    if (updateQueue !== null) {
      processUpdateQueue(
        workInProgress,
        updateQueue,
        newProps,
        instance,
        renderExpirationTime,
      );
      instance.state = workInProgress.memoizedState;
    }
  }

  // 判断是否有componentDidMount，
	// componentDidMount要在真正渲染进DOM之后才调用，也就是commit之后
  if (typeof instance.componentDidMount === 'function') {
    workInProgress.effectTag |= Update;
  }
}
</code></pre>

<h2 id="13-commitroot">13.commitRoot</h2>

<p>调用完<code>renderRoot</code>之后，<code>fiber</code>中对应的每个节点都执行了<code>render</code>之前所有的生命周期函数，并创建了对应的DOM元素，放在<code>workInProgress.stateNode</code>中。然后调用<code>commitRoot</code>，被提交的任务应该是：子树中优先级最高的任务或者外部指定的优先级（flushSync或者retry），然后调用<code>componentWillMount</code>，更新DOM元素的属性后，挂载组件，调用<code>componentDidMount</code></p>

    </div>

    

  
    <div class="post-tags">
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://xtid.github.io">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://xtid.github.io/2020/flutter%E5%90%84%E7%A7%8D%E8%B8%A9%E5%9D%91%E5%BF%83%E5%BE%97/" class="prev" rel="prev" title="Flutter各种踩坑心得"><i class="iconfont icon-left"></i>&nbsp;Flutter各种踩坑心得</a>
         
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2019 - 2021</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  



     </div>
  </body>
</html>
