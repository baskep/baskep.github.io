<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  
  
  
  
  <link rel="prev" href="https://xtid.github.io/2020/flutter%E5%90%84%E7%A7%8D%E8%B8%A9%E5%9D%91%E5%BF%83%E5%BE%97/" />
  
  <link rel="canonical" href="https://xtid.github.io/2021/react%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" sizes="32x32" href="/favicon.ico">
  <link rel="icon" sizes="16x16" href="/favicon.ico">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           Reactè°ƒåº¦è¿‡ç¨‹ | ğŸ‘¨ğŸ»â€ğŸ’»
       
  </title>
  <meta name="title" content="Reactè°ƒåº¦è¿‡ç¨‹ | ğŸ‘¨ğŸ»â€ğŸ’»">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/xtid.github.io"
    },
    "articleSection" : "posts",
    "name" : "Reactè°ƒåº¦è¿‡ç¨‹",
    "headline" : "Reactè°ƒåº¦è¿‡ç¨‹",
    "description" : "1.forwardRef ç”¨æ¥è§£å†³é«˜é˜¶ç»„ä»¶ä¼ é€’refçš„é—®é¢˜ã€‚å®ƒçš„ç”¨æ³•å°±åƒæ˜¯ä½¿ç”¨reduxçš„æ—¶å€™ï¼Œåœ¨å¤–é¢åŒ…è£¹ä¸€å±‚ï¼Œé€šè¿‡...propsçš„æ–¹å¼æŠŠå¤–éƒ¨çš„propsä¼ å…¥åˆ°å®",
    "inLanguage" : "zh-CN",
    "author" : "",
    "creator" : "",
    "publisher": "",
    "accountablePerson" : "",
    "copyrightHolder" : "",
    "copyrightYear" : "2021",
    "datePublished": "2021-01-05 23:02:17 \x2b0800 CST",
    "dateModified" : "2021-01-05 23:02:17 \x2b0800 CST",
    "url" : "https:\/\/xtid.github.io\/2021\/react%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B\/",
    "wordCount" : "7748",
    "keywords" : [  "ğŸ‘¨ğŸ»â€ğŸ’»"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://xtid.github.io">ğŸ‘¨ğŸ»â€ğŸ’»</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://xtid.github.io">ğŸ‘¨ğŸ»â€ğŸ’»</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Reactè°ƒåº¦è¿‡ç¨‹</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://xtid.github.io" rel="author"></a> with â™¥ 
                <span class="post-time">
                on <time datetime=2021-01-05 itemprop="datePublished">January 5, 2021</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://xtid.github.io/categories/%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/"> æºç ç†è§£ </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        

        
        
     
          
          
          

          
          
          

          

<h2 id="1-forwardref">1.forwardRef</h2>

<p>ç”¨æ¥è§£å†³é«˜é˜¶ç»„ä»¶ä¼ é€’<code>ref</code>çš„é—®é¢˜ã€‚å®ƒçš„ç”¨æ³•å°±åƒæ˜¯ä½¿ç”¨<code>redux</code>çš„æ—¶å€™ï¼Œåœ¨å¤–é¢åŒ…è£¹ä¸€å±‚ï¼Œé€šè¿‡<code>...props</code>çš„æ–¹å¼æŠŠå¤–éƒ¨çš„<code>props</code>ä¼ å…¥åˆ°å®é™…ç»„ä»¶</p>

<pre><code class="language-react">const TargetComponent = React.forwardRef((props, ref) =&gt; (
  &lt;TargetComponent ref={ref} /&gt;
))
</code></pre>

<h2 id="2-reactelement">2.ReactElement</h2>

<p><code>ReactElement</code>é€šè¿‡<code>createElement</code>åˆ›å»ºï¼Œè°ƒç”¨è¯¥æ–¹æ³•éœ€è¦ä¼ å…¥ä¸‰ä¸ªå‚æ•°ï¼š</p>

<ul>
<li>type</li>
<li>config</li>
<li>children</li>
</ul>

<p><code>type</code>æŒ‡ä»£è¿™ä¸ª<code>ReactElement</code>çš„ç±»å‹</p>

<ul>
<li>å­—ç¬¦ä¸²æ¯”å¦‚<code>div</code>ï¼Œ<code>p</code>ä»£è¡¨åŸç”ŸDOMï¼Œç§°ä¸º<code>HostComponent</code></li>
<li>Classç±»å‹æ˜¯æˆ‘ä»¬ç»§æ‰¿è‡ª<code>Component</code>æˆ–è€…<code>PureComponent</code>çš„ç»„ä»¶ï¼Œç§°ä¸º<code>ClassComponent</code></li>
<li>æ–¹æ³•å°±æ˜¯<code>functional Component</code></li>
<li>åŸç”Ÿæä¾›çš„<code>Fragment</code>ã€<code>AsyncMode</code>ç­‰æ˜¯Symbolï¼Œä¼šè¢«ç‰¹æ®Šå¤„ç†</li>
<li>TODO: æ˜¯å¦æœ‰å…¶ä»–çš„</li>
</ul>

<p>ä»æºç å¯ä»¥çœ‹å‡ºè™½ç„¶åˆ›å»ºçš„æ—¶å€™éƒ½æ˜¯é€šè¿‡<code>config</code>ä¼ å…¥çš„ï¼Œä½†æ˜¯<code>key</code>å’Œ<code>ref</code>ä¸ä¼šè·Ÿå…¶ä»–<code>config</code>ä¸­çš„å˜é‡ä¸€èµ·è¢«å¤„ç†ï¼Œè€Œæ˜¯å•ç‹¬ä½œä¸ºå˜é‡å‡ºç°åœ¨<code>ReactElement</code>ä¸Šã€‚</p>

<p>ä»æºç å¯ä»¥çœ‹å‡ºè™½ç„¶åˆ›å»ºçš„æ—¶å€™éƒ½æ˜¯é€šè¿‡<code>config</code>ä¼ å…¥çš„ï¼Œä½†æ˜¯<code>key</code>å’Œ<code>ref</code>ä¸ä¼šè·Ÿå…¶ä»–<code>config</code>ä¸­çš„å˜é‡ä¸€èµ·è¢«å¤„ç†ï¼Œè€Œæ˜¯å•ç‹¬ä½œä¸ºå˜é‡å‡ºç°åœ¨<code>ReactElement</code>ä¸Šã€‚åœ¨æœ€ååˆ›å»º<code>ReactElement</code>æˆ‘ä»¬çœ‹åˆ°äº†è¿™ä¹ˆä¸€ä¸ªå˜é‡<code>$$typeof</code>ï¼Œåœ¨è¿™é‡Œä»–æ˜¯ä¸€ä¸ªå¸¸é‡ï¼š<code>REACT_ELEMENT_TYPE</code></p>

<h2 id="3-react-children">3.React Children</h2>

<p><code>React</code>ä¸Šé¢æœ‰æœ‰ä¸€ä¸ª<code>Children</code>å¯¹è±¡ï¼Œä¸Šé¢æœ‰ç€<code>Children</code>å®šä¹‰</p>

<pre><code class="language-react">const React = {
  Children: {
    map,
    forEach,
    count,
    toArray,
    only,
  },
	......
}
</code></pre>

<p>æ‰¾åˆ°å®šä¹‰</p>

<pre><code class="language-react">function mapChildren(children, func, context) {
  if (children == null) {
    return children
  }
  const result = []
  mapIntoWithKeyPrefixInternal(children, result, null, func, context)
  return result
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  let escapedPrefix = ''
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/'
  }
  const traverseContext = getPooledTraverseContext(
    array,
    escapedPrefix,
    func,
    context,
  )
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext)
  releaseTraverseContext(traverseContext)
}
</code></pre>

<p>å¯ä»¥çœ‹åˆ°åé¢è°ƒç”¨äº†<code>getPooledTraverseContext</code>ï¼Œè¿™æ˜¯ä»å†…å®¹æ± ä¸­æ‰¾åˆ°å½“å‰çš„<code>contex</code>tå¯¹è±¡ï¼Œæ“ä½œå®Œäº†ä¹‹å<code>releaseTraverseContext</code>ä¼šæŠŠå½“å‰çš„<code>context</code>å¯¹è±¡æ¸…ç©ºç„¶åæ”¾å›åˆ°<code>pool</code>ä¸­ã€‚ç„¶åè°ƒç”¨<code>traverseAllChildren</code>ï¼Œè¿™ä¸ªæ–¹æ³•çš„ä½œç”¨å°±æ˜¯é€’å½’è°ƒç”¨<code>mapChildren</code>å°†æ‰€æœ‰<code>Children</code>é“ºå¹³ï¼Œç›´åˆ°å½“å‰å…ƒç´ æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„<code>ReactElement</code></p>

<pre><code class="language-react">function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  const { result, keyPrefix, func, context } = bookKeeping

  let mappedChild = func.call(context, child, bookKeeping.count++)
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c =&gt; c)
  } else if (mappedChild != null) {
    if (isValidElement(mappedChild)) {
      mappedChild = cloneAndReplaceKey(
        mappedChild,
        keyPrefix +
          (mappedChild.key &amp;&amp; (!child || child.key !== mappedChild.key)
            ? escapeUserProvidedKey(mappedChild.key) + '/'
            : '') +
          childKey,
      )
    }
    result.push(mappedChild)
  }
}
</code></pre>

<p>ä½¿ç”¨æ–¹æ³•</p>

<pre><code class="language-react">React.Children.map(this.props.children, function (child) {
    return &lt;li&gt;{child}&lt;/li&gt;;
})
</code></pre>

<h2 id="4-reactä¸­çš„æ•°æ®ç»“æ„">4.Reactä¸­çš„æ•°æ®ç»“æ„</h2>

<p><code>Update</code> &amp;<code>UpdateQueue</code></p>

<pre><code class="language-react">export type Update&lt;State&gt; = {
  // æ›´æ–°çš„è¿‡æœŸæ—¶é—´
  expirationTime: ExpirationTime,

  // export const UpdateState = 0;
  // export const ReplaceState = 1;
  // export const ForceUpdate = 2;
  // export const CaptureUpdate = 3;
  // æŒ‡å®šæ›´æ–°çš„ç±»å‹ï¼Œå€¼ä¸ºä»¥ä¸Šå‡ ç§
  tag: 0 | 1 | 2 | 3,
  // æ›´æ–°å†…å®¹ï¼Œæ¯”å¦‚`setState`æ¥æ”¶çš„ç¬¬ä¸€ä¸ªå‚æ•°
  payload: any, // å½“å‰DOMå…ƒç´ ï¼Ÿ
  // å¯¹åº”çš„å›è°ƒï¼Œ`setState`ï¼Œ`render`éƒ½æœ‰
  callback: (() =&gt; mixed) | null,

  // æŒ‡å‘ä¸‹ä¸€ä¸ªæ›´æ–°
  next: Update&lt;State&gt; | null,
  // æŒ‡å‘ä¸‹ä¸€ä¸ª`side effect`
  nextEffect: Update&lt;State&gt; | null,
};

export type UpdateQueue&lt;State&gt; = {
  // æ¯æ¬¡æ“ä½œå®Œæ›´æ–°ä¹‹åçš„`state`
  baseState: State,

  // é˜Ÿåˆ—ä¸­çš„ç¬¬ä¸€ä¸ª`Update`
  firstUpdate: Update&lt;State&gt; | null,
  // é˜Ÿåˆ—ä¸­çš„æœ€åä¸€ä¸ª`Update`
  lastUpdate: Update&lt;State&gt; | null,

  // ç¬¬ä¸€ä¸ªæ•è·ç±»å‹çš„`Update`
  firstCapturedUpdate: Update&lt;State&gt; | null,
  // æœ€åä¸€ä¸ªæ•è·ç±»å‹çš„`Update`
  lastCapturedUpdate: Update&lt;State&gt; | null,

  // ç¬¬ä¸€ä¸ª`side effect`
  firstEffect: Update&lt;State&gt; | null,
  // æœ€åä¸€ä¸ª`side effect`
  lastEffect: Update&lt;State&gt; | null,

  // ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªæ•è·äº§ç”Ÿçš„`side effect`
  firstCapturedEffect: Update&lt;State&gt; | null,
  lastCapturedEffect: Update&lt;State&gt; | null,
};
</code></pre>

<h2 id="5-åˆæ¬¡reactdom-reanderè¿‡ç¨‹">5.åˆæ¬¡ReactDOM.reanderè¿‡ç¨‹</h2>

<p>é¦–å…ˆè°ƒç”¨<code>legacyRenderSubtreeIntoContainer</code></p>

<pre><code class="language-react">ReactDOM = {
  render(
    element: React$Element&lt;any&gt;,
    container: DOMContainer,
    callback: ?Function,
  ) {
    return legacyRenderSubtreeIntoContainer(
      null,
      element,
      container,
      false,
      callback,
    )
  },
}
</code></pre>

<pre><code class="language-react">function legacyRenderSubtreeIntoContainer(
  parentComponent: ?React$Component&lt;any, any&gt;,
  children: ReactNodeList,
  container: DOMContainer,
  forceHydrate: boolean,
  callback: ?Function,
) {
  let root: Root = (container._reactRootContainer: any)
  if (!root) {
    // ç”Ÿæˆrootï¼Œå½“å‰ä¼ å…¥çš„æ ¹containerçš„_reactRootContaineræŒ‡å‘ç”Ÿæˆçš„root
    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
      container,
      forceHydrate,
    )
    if (typeof callback === 'function') {
      const originalCallback = callback
      callback = function() {
        const instance = DOMRenderer.getPublicRootInstance(root._internalRoot)
        originalCallback.call(instance)
      }
    }
    // é¦–æ¬¡renderä¸æ¯”unbatchedUpdates
    DOMRenderer.unbatchedUpdates(() =&gt; {
      if (parentComponent != null) {
        // ä¸€èˆ¬ä¸ä¼šå‡ºç°
      } else {
        root.render(children, callback)
      }
    })
  } else {
    // æœ‰rootçš„æƒ…å†µ
  }
  return DOMRenderer.getPublicRootInstance(root._internalRoot)
}
</code></pre>

<p><code>legacyCreateRootFromDOMContainer</code>æ–¹æ³•ç”Ÿæˆ<code>root</code>ï¼Œè¿”å›çš„ç»“æœä¸Šçš„<code>_internalRoot</code>æŒ‡å‘è¿™ä¸ª<code>root</code>ã€‚åŒæ—¶ä¼šè°ƒç”¨<code>DOMRenderer.createContainer</code>åˆ›å»º<code>FiberRoot</code>ï¼Œç„¶åç”Ÿæˆçš„<code>root</code>çš„<code>current</code>å±æ€§æŒ‡å‘è¿™ä¸ª<code>FiberRoot</code></p>

<pre><code class="language-react">function legacyCreateRootFromDOMContainer(
  container: DOMContainer,
  forceHydrate: boolean,
): Root {
  const shouldHydrate =
    forceHydrate || shouldHydrateDueToLegacyHeuristic(container)
  // First clear any existing content.
  if (!shouldHydrate) {
    let warned = false
    let rootSibling
    while ((rootSibling = container.lastChild)) {
      container.removeChild(rootSibling)
    }
  }
  // Legacy roots are not async by default.
  const isConcurrent = false
  return new ReactRoot(container, isConcurrent, shouldHydrate)
}

function ReactRoot(
  container: Container,
  isConcurrent: boolean,
  hydrate: boolean,
) {
  const root = DOMRenderer.createContainer(container, isConcurrent, hydrate)
  this._internalRoot = root
}

ReactRoot.prototype.render = function(
  children: ReactNodeList,
  callback: ?() =&gt; mixed,
): Work {
  const root = this._internalRoot
  const work = new ReactWork()
  callback = callback === undefined ? null : callback
  if (__DEV__) {
    warnOnInvalidCallback(callback, 'render')
  }
  if (callback !== null) {
    work.then(callback)
  }
  DOMRenderer.updateContainer(children, root, null, work._onCommit)
  return work
}
</code></pre>

<p>å¯ä»¥çœ‹åˆ°è¿˜æœ‰ä¸ª<code>updateContainer</code>æ–¹æ³•</p>

<pre><code class="language-react">export function updateContainer(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component&lt;any, any&gt;,
  callback: ?Function,
): ExpirationTime {
  const current = container.current
  const currentTime = requestCurrentTime()
  const expirationTime = computeExpirationForFiber(currentTime, current)
  return updateContainerAtExpirationTime(
    element,
    container,
    parentComponent,
    expirationTime,
    callback,
  )
}

export function updateContainerAtExpirationTime(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component&lt;any, any&gt;,
  expirationTime: ExpirationTime,
  callback: ?Function,
) {
  // TODO: If this is a nested container, this won't be the root.
  const current = container.current
  const context = getContextForSubtree(parentComponent)
  if (container.context === null) {
    container.context = context
  } else {
    container.pendingContext = context
  }

  return scheduleRootUpdate(current, element, expirationTime, callback)
}
</code></pre>

<p>å¯ä»¥çœ‹åˆ°å…ˆç”Ÿæˆä¸€ä¸ªæ—¶é—´<code>const expirationTime</code>ï¼Œä¹Ÿå°±æ˜¯è¿™æ¬¡æ›´æ–°çš„è¶…æ—¶æ—¶é—´ï¼Œç„¶åè°ƒç”¨<code>updateContainerAtExpirationTime</code>ï¼Œç„¶åè°ƒç”¨<code>scheduleRootUpdate</code>è¿›è¡Œè°ƒåº¦</p>

<pre><code class="language-react">function scheduleRootUpdate(
  current: Fiber,
  element: ReactNodeList,
  expirationTime: ExpirationTime,
  callback: ?Function,
) {
  const update = createUpdate(expirationTime)

  update.payload = { element }

  callback = callback === undefined ? null : callback
  if (callback !== null) {
    warningWithoutStack(
      typeof callback === 'function',
      'render(...): Expected the last optional `callback` argument to be a ' +
        'function. Instead received: %s.',
      callback,
    )
    update.callback = callback
  }
  enqueueUpdate(current, update)

  scheduleWork(current, expirationTime)
  return expirationTime
}
</code></pre>

<p><code>scheduleRootUpdate</code>ä¼šè°ƒç”¨<code>createUpdate</code>åˆ›å»º<code>Update</code>å¯¹è±¡ï¼Œå…¶<code>playload</code>ä¸º<code>container</code>ä¸Šé¢çš„<code>ReactNodeList</code>ï¼Œç„¶åè°ƒç”¨<code>enqueueUpdate</code>ç”Ÿæˆä¸€ä¸ªåŒå‘åˆ—è¡¨é˜Ÿåˆ—ï¼Œç„¶åè°ƒç”¨<code>scheduleWork</code>å¼€å§‹è°ƒç”¨ã€‚ä¸Šé¢çš„è¿‡ç¨‹éƒ½æ˜¯ä¾èµ–çš„<code>FiberRoot</code></p>

<h2 id="6-expirationtime">6.expirationTime</h2>

<pre><code class="language-react">import MAX_SIGNED_31_BIT_INT from './maxSigned31BitInt';

export type ExpirationTime = number;

export const NoWork = 0;
export const Never = 1;
export const Sync = MAX_SIGNED_31_BIT_INT;

const UNIT_SIZE = 10;
const MAGIC_NUMBER_OFFSET = MAX_SIGNED_31_BIT_INT - 1;

// 1 unit of expiration time represents 10ms.
export function msToExpirationTime(ms: number): ExpirationTime {
  // Always add an offset so that we don't clash with the magic number for NoWork.
  return MAGIC_NUMBER_OFFSET - ((ms / UNIT_SIZE) | 0);
}

export function expirationTimeToMs(expirationTime: ExpirationTime): number {
  return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;
}

function ceiling(num: number, precision: number): number {
  return (((num / precision) | 0) + 1) * precision;
}

function computeExpirationBucket(
  currentTime,
  expirationInMs,
  bucketSizeMs,
): ExpirationTime {
  return (
    MAGIC_NUMBER_OFFSET -
    ceiling(
      MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE,
      bucketSizeMs / UNIT_SIZE,
    )
  );
}

export const LOW_PRIORITY_EXPIRATION = 5000;
export const LOW_PRIORITY_BATCH_SIZE = 250;

export function computeAsyncExpiration(
  currentTime: ExpirationTime,
): ExpirationTime {
  return computeExpirationBucket(
    currentTime,
    LOW_PRIORITY_EXPIRATION,
    LOW_PRIORITY_BATCH_SIZE,
  );
}

export const HIGH_PRIORITY_EXPIRATION = __DEV__ ? 500 : 150;
export const HIGH_PRIORITY_BATCH_SIZE = 100;

export function computeInteractiveExpiration(currentTime: ExpirationTime) {
  return computeExpirationBucket(
    currentTime,
    HIGH_PRIORITY_EXPIRATION,
    HIGH_PRIORITY_BATCH_SIZE,
  );
}

</code></pre>

<p>æœ€åçš„è®¡ç®—å…¬å¼ä¸º<code>((((currentTime - 2 + 5000 / 10) / 25) | 0) + 1) * 25</code>ï¼ˆå…¬å¼å­˜ç–‘ï¼‰ï¼Œä¹Ÿå°±æ˜¯è¯´æœ€åçš„ç»“æœæ˜¯ä»¥<code>25ms</code>ä¸ºå•ä½å‘ä¸Šå¢åŠ çš„ï¼Œåœ¨<code>25ms</code>å†…ï¼Œ<code>react</code>è¿™æ ·åšä¸ºçš„æ˜¯è®©ä¸¤æ¬¡æ—¶é—´éå¸¸æƒ³å°½çš„æ›´æ–°å¾—åˆ°åŒæ ·çš„<code>expirationTime</code>ï¼Œç„¶åä»–ä»¬çš„ä¼˜å…ˆçº§å°±ä¼šåˆ¤å®šä¸€æ ·ï¼Œå°±ä¼šå†ä¸€æ¬¡æ›´æ–°ä¸­å®Œæˆï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ª<code>batchedUpdates</code></p>

<p>è®¡ç®—å½“å‰<code>currentTime</code></p>

<pre><code class="language-react">function requestCurrentTime() {
  if (isRendering) {
    return currentSchedulerTime
  }
  findHighestPriorityRoot()
  if (
    nextFlushedExpirationTime === NoWork ||
    nextFlushedExpirationTime === Never
  ) {
    recomputeCurrentRendererTime()
    currentSchedulerTime = currentRendererTime
    return currentSchedulerTime
  }
  return currentSchedulerTime
}
</code></pre>

<p><code>react</code>ä¸ºäº†é¿å…æ¯æ¬¡è®¡ç®—<code>expirationTime</code>éƒ½è¦<code>Date now</code>ï¼Œæ‰€ä»¥ç”¨<code>currentRendererTime</code>æ¥ä¿å­˜äº†è¿™ä¸ªå€¼ï¼Œä¸Šé¢çš„<code>currentSchedulerTime</code>ä¹Ÿæ˜¯è®°å½•è¿™ä¸ªå€¼çš„</p>

<p>é¦–å…ˆ</p>

<pre><code class="language-react">if (isRendering) {
  return currentSchedulerTime
}
</code></pre>

<p>è¿™ä¸ª<code>isRendering</code>åªæœ‰åœ¨<code>performWorkOnRoot</code>çš„æ—¶å€™æ‰ä¼šè¢«è®¾ç½®ä¸º<code>true</code>ï¼Œè€Œå…¶æœ¬èº«æ˜¯ä¸€ä¸ªåŒæ­¥çš„æ–¹æ³•ï¼Œä¸å­˜åœ¨ä»–æ‰§è¡Œåˆ°ä¸€åŠæ²¡æœ‰è®¾ç½®<code>isRendering</code>ä¸º<code>false</code>çš„æ—¶å€™å°±è·³å‡ºï¼Œé‚£ä¹ˆä»€ä¹ˆæƒ…å†µä¸‹ä¼šåœ¨è¿™é‡Œå‡ºç°æ–°çš„<code>requestCurrentTime</code>å‘¢ï¼Ÿ</p>

<ul>
<li>åœ¨ç”Ÿå‘½å‘¨æœŸæ–¹æ³•ä¸­è°ƒç”¨äº†<code>setState</code></li>
<li>éœ€è¦æŒ‚èµ·ä»»åŠ¡çš„æ—¶å€™</li>
</ul>

<p>ä¹Ÿå°±æ˜¯è¯´ React è¦æ±‚<strong>åœ¨ä¸€æ¬¡<code>rendering</code>è¿‡ç¨‹ä¸­ï¼Œæ–°äº§ç”Ÿçš„<code>update</code>ç”¨äºè®¡ç®—è¿‡æœŸæ—¶é—´çš„<code>current</code>å¿…é¡»è·Ÿç›®å‰çš„<code>renderTime</code>ä¿æŒä¸€è‡´ï¼ŒåŒç†åœ¨è¿™ä¸ªå‘¨æœŸä¸­æ‰€æœ‰äº§ç”Ÿçš„æ–°çš„æ›´æ–°çš„è¿‡æœŸæ—¶é—´éƒ½ä¼šä¿æŒä¸€è‡´ï¼</strong></p>

<pre><code class="language-react">  findHighestPriorityRoot()
  if (
    nextFlushedExpirationTime === NoWork ||
    nextFlushedExpirationTime === Never
  ) {
    recomputeCurrentRendererTime()
    currentSchedulerTime = currentRendererTime
    return currentSchedulerTime
  }
</code></pre>

<p><code>findHighestPriorityRoot</code>æ‰¾åˆ°ä¼˜å…ˆçº§æœ€é«˜çš„èŠ‚ç‚¹ï¼ŒåŒæ—¶è®¾ç½®<code>nextFlushedExpirationTime</code>ï¼Œç„¶åifåˆ¤æ–­å½“å‰é˜Ÿåˆ—ä¸­æ²¡æœ‰æ›´æ–°çš„ä»»åŠ¡ï¼Œå°±ä¼šé‡æ–°è®¡ç®—å½“å‰æ—¶é—´ï¼Œå¦åˆ™ï¼Œè¿˜æ˜¯è¿”å›æœ€åˆçš„<code>currentSchedulerTime</code></p>

<h2 id="7-å„ç§expirationtime">7.å„ç§expirationTime</h2>

<ul>
<li><code>root.expirationTime</code></li>
<li><code>root.nextExpirationTimeToWorkOn</code></li>
<li><code>root.childExpirationTime</code></li>
<li><code>root.earliestPendingTime &amp; root.lastestPendingTime</code></li>
<li><code>root.earliestSuspendedTime &amp; root.lastestSuspendedTime</code></li>
<li><code>root.lastestPingedTime</code></li>
<li><code>nextFlushedExpirationTime</code></li>
<li><code>nextLatestAbsoluteTimeoutMs</code></li>
<li><code>currentRendererTime</code></li>
<li><code>currentSchedulerTime</code></li>
</ul>

<p><code>React</code>æ›´æ–°æ˜¯ä»<code>FilberRoot</code>å¼€å§‹çš„ï¼Œæ‰€ä»¥æ¯æ¬¡æ›´æ–°æ—¶éƒ½ä¼šéå†å‘ä¸ŠæŸ¥æ‰¾<code>FiberRoot</code>ï¼Œè€Œè¿™ä¸ª<code>childExpirationTime</code>ä¼šè®¾ç½®åˆ°æ¯ä¸ªçˆ¶èŠ‚ç‚¹ï¼Œä»£è¡¨å…¶å­èŠ‚ç‚¹<code>expirationTime</code></p>

<p><code>pendingTime</code>ï¼Œåœ¨<code>FiberRoot</code>ä¸Šæœ‰ä¸¤ä¸ªå€¼<code>earliestPendingTime</code>å’Œ<code>lastestPedingTime</code>ï¼Œä»–ä»¬æ˜¯ä¸€å¯¹å€¼ï¼Œ<strong>ç”¨æ¥è®°å½•æ‰€æœ‰å­æ ‘ä¸­éœ€è¦è¿›è¡Œæ¸²æŸ“çš„æ›´æ–°çš„<code>expirationTime</code>çš„åŒºé—´</strong></p>

<p><code>suspendedTime</code>ï¼ŒåŒæ ·çš„åœ¨<code>ReactFiber</code>ä¸Šæœ‰ä¸¤ä¸ªå€¼<code>earliestSuspendedTime</code>å’Œ<code>lastestSuspendedTime</code>ï¼Œ<strong>è¿™ä¸¤ä¸ªå€¼æ˜¯ç”¨æ¥è®°å½•è¢«æŒ‚èµ·çš„ä»»åŠ¡çš„è¿‡æœŸæ—¶é—´çš„</strong></p>

<p>é¦–å…ˆæˆ‘ä»¬å®šä¹‰ä¸€ä¸‹ä»€ä¹ˆæƒ…å†µä¸‹ä»»åŠ¡æ˜¯è¢«æŒ‚èµ·çš„ï¼š</p>

<ul>
<li>å‡ºç°å¯æ•è·çš„é”™è¯¯å¹¶ä¸”è¿˜æœ‰ä¼˜å…ˆçº§æ›´ä½çš„ä»»åŠ¡çš„æƒ…å†µä¸‹</li>
<li>å½“æ•è·åˆ°<code>thenable</code>ï¼Œå¹¶ä¸”éœ€è¦è®¾ç½®<code>onTimeout</code>çš„æ—¶å€™</li>
</ul>

<p><code>root.expirationTime</code>æ˜¯ç”¨æ¥æ ‡å¿—å½“å‰æ¸²æŸ“çš„è¿‡æœŸæ—¶é—´çš„ï¼Œè¯·æ³¨æ„ä»–åªç®¡æœ¬æ¸²æŸ“å‘¨æœŸï¼Œä»–å¹¶ä¸ç®¡ä½ ç°åœ¨çš„æ¸²æŸ“ç›®æ ‡æ˜¯å“ªä¸ªï¼Œæ¸²æŸ“ç›®æ ‡æ˜¯ç”±<code>root.nextExpirationTimeToWorkOn</code>æ¥å†³å®šçš„ã€‚</p>

<p>é‚£ä¹ˆä»–ä»¬æœ‰ä»€ä¹ˆåŒºåˆ«å‘¢ï¼Ÿä¸»è¦åŒºåˆ«åœ¨äºå‘æŒ¥ä½œç”¨çš„é˜¶æ®µ</p>

<p><code>expirationTime</code>ä½œç”¨äºè°ƒåº¦é˜¶æ®µï¼Œä¸»è¦æŒ‡è´£æ˜¯ï¼š</p>

<ul>
<li>å†³å®šæ˜¯å¼‚æ­¥æ‰§è¡Œæ¸²æŸ“è¿˜æ˜¯åŒæ­¥æ‰§è¡Œæ¸²æŸ“</li>
<li>ä½œä¸º<code>react-scheduler</code>çš„<code>timeout</code>æ ‡å‡†ï¼Œå†³å®šæ˜¯å¦è¦ä¼˜å…ˆæ¸²æŸ“</li>
</ul>

<p><code>nextExpirationTimeToWorkOn</code>ä¸»è¦ä½œç”¨äºæ¸²æŸ“é˜¶æ®µï¼š</p>

<ul>
<li>å†³å®šé‚£äº›æ›´æ–°è¦åœ¨å½“å‰å‘¨æœŸä¸­è¢«æ‰§è¡Œ</li>
<li>é€šè¿‡è·Ÿæ¯ä¸ªèŠ‚ç‚¹çš„<code>expirationTime</code>æ¯”è¾ƒå†³å®šè¯¥èŠ‚ç‚¹æ˜¯å¦å¯ä»¥ç›´æ¥<code>bailout</code>ï¼ˆè·³è¿‡ï¼‰</li>
</ul>

<p>ä»–ä»¬éƒ½æ˜¯é€šè¿‡<code>pendingTime</code>ã€<code>suspenededTime</code>å’Œ<code>pingedTime</code>ä¸­åˆ é€‰å‡ºæ¥çš„ï¼Œå”¯ä¸€çš„ä¸åŒæ˜¯ï¼Œ<code>nextExpirationTimeToWorkOn</code>åœ¨æ²¡æœ‰<code>pending</code>æˆ–è€…<code>pinged</code>çš„ä»»åŠ¡çš„æ—¶å€™ä¼šé€‰æ‹©æœ€æ™šçš„<code>suspendedTime</code>ï¼Œè€Œ<code>expirationTime</code>ä¼šé€‰æ‹©æœ€æ—©çš„</p>

<p><code>expirationTime</code>çš„å˜åŒ–ï¼š</p>

<ul>
<li>åœ¨<code>scheduleWork</code>çš„æ—¶å€™é€šè¿‡<code>markPendingExpirationTime</code>è®¾ç½®</li>
<li>åœ¨<code>beginWork</code>çš„æ—¶å€™è¢«è®¾ç½®ä¸º<code>NoWork</code></li>
<li>åœ¨<code>onUncaughtError</code>çš„æ—¶å€™è®¾ç½®ä¸º<code>NoWork</code></li>
<li><code>onSuspend</code>çš„æ—¶å€™åˆä¼šè®¾ç½®å›å½“æ¬¡æ›´æ–°çš„<code>expirationTime</code></li>
</ul>

<h2 id="8-schedulework">8.scheduleWork</h2>

<p>ä¸Šé¢è¯´çš„åœ¨åˆ›å»ºå®Œæ›´æ–°é˜Ÿåˆ—åï¼Œå°±ä¼šè°ƒç”¨<code>scheduleWork</code>è°ƒåº¦äº†</p>

<pre><code class="language-react">function scheduleWork(fiber: Fiber, expirationTime: ExpirationTime) {
  const root = scheduleWorkToRoot(fiber, expirationTime);
  if (root === null) {
    if (__DEV__) {
      switch (fiber.tag) {
        case ClassComponent:
          warnAboutUpdateOnUnmounted(fiber, true);
          break;
        case FunctionComponent:
        case ForwardRef:
        case MemoComponent:
        case SimpleMemoComponent:
          warnAboutUpdateOnUnmounted(fiber, false);
          break;
      }
    }
    return;
  }
	
  // æ­¤æ¡ä»¶çš„æ„æ€æ˜¯å½“å‰å¤„ç†ç©ºé—²é˜¶æ®µï¼Œæ²¡æœ‰renderæˆ–è€…commitï¼Œå¹¶ä¸”ä¸‹ä¸€æ¬¡ä»»åŠ¡ä¸ä¸ºç©ºï¼Œè¿˜æœ‰å½“å‰è¿‡æœŸæ—¶é—´(ä¼˜å…ˆçº§)é«˜äºä¸‹æ¬¡çš„è¿‡æœŸæ—¶é—´
  // åˆ™æ¸…ç©ºé˜Ÿåˆ—
  // ä¾‹å¦‚ä¸Šä¸€ä¸ªä»»åŠ¡æ˜¯å¼‚æ­¥ä»»åŠ¡ï¼ˆä¼˜å…ˆçº§å¾ˆä½ï¼Œè¶…æ—¶æ—¶é—´æ˜¯ 502msï¼‰ï¼Œå¹¶ä¸”åœ¨ä¸Šä¸€ä¸ªæ—¶é—´ç‰‡ï¼ˆåˆå§‹æ˜¯ 33msï¼‰ä»»åŠ¡æ²¡æœ‰æ‰§è¡Œå®Œï¼Œè€Œä¸”ç­‰å¾…ä¸‹ä¸€æ¬¡requestIdleCallbackçš„æ—¶å€™æ–°çš„ä»»åŠ¡è¿›æ¥äº†ï¼Œå¹¶ä¸”è¶…æ—¶æ—¶é—´å¾ˆçŸ­ï¼ˆ52ms æˆ–è€… 22ms ç”šè‡³æ˜¯ Syncï¼‰ï¼Œé‚£ä¹ˆä¼˜å…ˆçº§å°±å˜æˆäº†å…ˆæ‰§è¡Œå½“å‰ä»»åŠ¡ï¼Œä¹Ÿå°±æ„å‘³ç€ä¸Šä¸€ä¸ªä»»åŠ¡è¢«æ‰“æ–­äº†ï¼ˆinterruptedï¼‰
  if (
    !isWorking &amp;&amp;
    nextRenderExpirationTime !== NoWork &amp;&amp;
    expirationTime &gt; nextRenderExpirationTime
  ) {
    interruptedBy = fiber;
    resetStack();
  }
  // è®°å½•æ‰€æœ‰å­èŠ‚ç‚¹çš„ä»»åŠ¡æ—¶é—´åŒºé—´
  markPendingPriorityLevel(root, expirationTime);
  // è¦ä¹ˆå¤„äºæ²¡æœ‰ work çš„çŠ¶æ€ï¼Œè¦ä¹ˆåªèƒ½åœ¨ render é˜¶æ®µï¼Œè¦ä¹ˆæœ‰ä¸¤ä¸ªä¸åŒçš„root
  if (
    !isWorking ||
    isCommitting ||
    nextRoot !== root
  ) {
    const rootExpirationTime = root.expirationTime;
    requestWork(root, rootExpirationTime);
  }
  if (nestedUpdateCount &gt; NESTED_UPDATE_LIMIT) {
    // Reset this back to zero so subsequent updates don't throw.
    nestedUpdateCount = 0;
    invariant(
      false,
      'Maximum update depth exceeded. This can happen when a ' +
        'component repeatedly calls setState inside ' +
        'componentWillUpdate or componentDidUpdate. React limits ' +
        'the number of nested updates to prevent infinite loops.',
    );
  }
}
</code></pre>

<p>é¦–å…ˆæ˜¯è°ƒç”¨<code>scheduleWorkToRoot</code>ï¼Œè¿™ä¸ªæ–¹æ³•çš„ä¸»è¦æ˜¯æ›´æ–°å½“å‰ä»»åŠ¡å¯¹åº”<code>Filber</code>çš„åˆ°æœŸæ—¶é—´</p>

<pre><code class="language-react">function scheduleWorkToRoot(fiber: Fiber, expirationTime): FiberRoot | null {
  recordScheduleUpdate();

  if (__DEV__) {
    if (fiber.tag === ClassComponent) {
      const instance = fiber.stateNode;
      warnAboutInvalidUpdates(instance);
    }
  }

  // å¦‚æœfilberä¸Šçš„è¿‡æœŸæ—¶é—´å°äºå½“å‰çš„è¿‡æœŸæ—¶é—´ï¼Œæ›´æ–°
  if (fiber.expirationTime &lt; expirationTime) {
    fiber.expirationTime = expirationTime;
  }
  let alternate = fiber.alternate;
  if (alternate !== null &amp;&amp; alternate.expirationTime &lt; expirationTime) {
    alternate.expirationTime = expirationTime;
  }
  // fiber.return è¿”å›å½“å‰fiberçš„çˆ¶èŠ‚ç‚¹
  let node = fiber.return;
  let root = null;
  if (node === null &amp;&amp; fiber.tag === HostRoot) {
    // å¦‚æœfilber.returnçš„å€¼ä¸ºnullï¼Œè®¾ç½®rootçš„å€¼ä¸ºæ ¹èŠ‚ç‚¹(fiber.stateNode)
    root = fiber.stateNode;
  } else {
    // å¾ªç¯å‘ä¸Šéå†ï¼Œæ›´æ–°æ¯ä¸ªå­èŠ‚ç‚¹çš„è¿‡æœŸæ—¶é—´
    // å¦‚æœå­èŠ‚ç‚¹çš„è¿‡æœŸæ—¶é—´å°äºå½“å‰è¿‡æœŸæ—¶é—´ï¼Œåˆ™æ›´æ–°
    while (node !== null) {
      alternate = node.alternate;
      if (node.childExpirationTime &lt; expirationTime) {
        node.childExpirationTime = expirationTime;
        if (
          alternate !== null &amp;&amp;
          alternate.childExpirationTime &lt; expirationTime
        ) {
          alternate.childExpirationTime = expirationTime;
        }
      } else if (
        alternate !== null &amp;&amp;
        alternate.childExpirationTime &lt; expirationTime
      ) {
        alternate.childExpirationTime = expirationTime;
      }
      if (node.return === null &amp;&amp; node.tag === HostRoot) {
        root = node.stateNode;
        break;
      }
      node = node.return;
    }
  }
  ......
  return root;
}
</code></pre>

<p><code>requestWork</code></p>

<pre><code class="language-react">function requestWork(root: FiberRoot, expirationTime: ExpirationTime) {
  // å°†rootåŠ å…¥è°ƒåº¦é˜Ÿåˆ—ä¸­ï¼Œä¸ä¼šå­˜åœ¨ä¸¤ä¸ªç›¸åŒçš„ root å‰åå‡ºç°åœ¨é˜Ÿåˆ—ä¸­
  addRootToSchedule(root, expirationTime)
  if (isRendering) {
    return
  }

  if (isBatchingUpdates) {
    if (isUnbatchingUpdates) {
      nextFlushedRoot = root
      nextFlushedExpirationTime = Sync
      performWorkOnRoot(root, Sync, true)
    }
    return
  }

  // æ ¹æ®expirationTimeè°ƒç”¨performSyncWorkè¿˜æ˜¯scheduleCallbackWithExpirationTime

  if (expirationTime === Sync) {
    performSyncWork()
  } else {
    // å¼‚æ­¥è°ƒåº¦ï¼Œå¹¶ä¸”å½“å‰å·²ç»æœ‰å¼‚æ­¥ä»»åŠ¡ï¼Œå¦‚æœå½“å‰ä¼ å…¥çš„ä»»åŠ¡ä¼˜å…ˆçº§é«˜ï¼Œå–æ¶ˆä¹‹å‰çš„è°ƒåº¦ï¼Œå¼‚æ­¥è°ƒåº¦å½“å‰ä»»åŠ¡
    // æ— å¼‚æ­¥ä»»åŠ¡ï¼Œç”Ÿæˆä¸€ä¸ªåˆ°æœŸæ—¶é—´ï¼Œè°ƒåº¦
    scheduleCallbackWithExpirationTime(root, expirationTime)
  }
}
</code></pre>

<h2 id="9-performwork">9.performWork</h2>

<p><code>performAsyncWork</code> ä¸ºå¼‚æ­¥è°ƒç”¨ï¼Œä¸€å¼€å§‹çš„<code>shouldYieldToRenderer</code>ä»£è¡¨æ˜¯å¦å½“å‰è°ƒåº¦ä¸­æœ‰æ²¡æœ‰æ—¶é—´æ‰§è¡Œå¼‚æ­¥ä»»åŠ¡ï¼Œè‹¥<code>shouldYieldToRenderer</code>è¿”å›<code>false</code>ï¼Œåˆ™ä»£è¡¨æœ‰ï¼Œé‚£ä¹ˆé‡æ–°è®¡ç®—å½“å‰çš„<code>expirationTime</code>ï¼Œæ›´æ–°æ‰€æœ‰çš„å·²è¿‡æœŸçš„<code>root</code>ä»»åŠ¡çš„<code>nextExpirationTimeToWorkOn</code></p>

<pre><code class="language-react">let didYield: boolean = false;
function shouldYieldToRenderer() {
  if (didYield) {
    return true;
  }
  if (shouldYield()) {
    didYield = true;
    return true;
  }
  return false;
}

function performAsyncWork() {
  try {
    if (!shouldYieldToRenderer()) {
      // å¦‚æœå½“å‰è¿˜æœ‰è°ƒåº¦çš„é“¾è¡¨
      if (firstScheduledRoot !== null) {
        // é‡æ–°è®¡ç®—å½“å‰çš„ä¸€ä¸ªexpirationTime
        recomputeCurrentRendererTime();
        let root: FiberRoot = firstScheduledRoot;
        do {
          // è®¾ç½®æ‰€æœ‰çš„å·²è¿‡æœŸçš„rootä»»åŠ¡çš„nextExpirationTimeToWorkOnä¸ºå½“å‰è®¡ç®—å‡ºçš„expirationTime
          didExpireAtExpirationTime(root, currentRendererTime);
          root = (root.nextScheduledRoot: any);
        } while (root !== firstScheduledRoot);
      }
    }
    performWork(NoWork, true);
  } finally {
    didYield = false;
  }
}
</code></pre>

<p><code>performSyncWork</code></p>

<p>åŒæ­¥è°ƒåº¦ä»»åŠ¡ï¼Œæ–¹æ³•å¾ˆç®€å•ï¼Œç›´æ¥è°ƒç”¨<code>performWork</code></p>

<pre><code class="language-react">function performSyncWork() {
  performWork(Sync, false);
}
</code></pre>

<p><code>performWork</code></p>

<p>æ­¤æ–¹æ³•ä¸ºçœŸæ­£çš„è°ƒåº¦æ–¹æ³•ï¼Œé¦–å…ˆä¼šè°ƒç”¨<code>findHighestPriorityRoot</code>ï¼Œæ‰¾åˆ°å½“å‰é˜Ÿåˆ—ä¼˜å…ˆçº§æœ€é«˜çš„<code>root</code>ä»»åŠ¡ï¼Œå‘½åä¸º<code>nextFlushedRoot</code>ï¼Œå·²ç»å…¶å¯¹åº”çš„<code>expirationTime</code>ï¼Œå‘½åä¸º<code>nextFlushedExpirationTime</code></p>

<pre><code class="language-react">function performWork(minExpirationTime: ExpirationTime, isYieldy: boolean) {
  findHighestPriorityRoot();

  if (isYieldy) {
    recomputeCurrentRendererTime();
    currentSchedulerTime = currentRendererTime;
		
    if (enableUserTimingAPI) {
      const didExpire = nextFlushedExpirationTime &gt; currentRendererTime;
      const timeout = expirationTimeToMs(nextFlushedExpirationTime);
      stopRequestCallbackTimer(didExpire, timeout);
    }

    while (
      nextFlushedRoot !== null &amp;&amp;
      nextFlushedExpirationTime !== NoWork &amp;&amp;
      minExpirationTime &lt;= nextFlushedExpirationTime &amp;&amp;
      !(didYield &amp;&amp; currentRendererTime &gt; nextFlushedExpirationTime)
    ) {
      performWorkOnRoot(
        nextFlushedRoot,
        nextFlushedExpirationTime,
        currentRendererTime &gt; nextFlushedExpirationTime,
      );
      findHighestPriorityRoot();
      recomputeCurrentRendererTime();
      currentSchedulerTime = currentRendererTime;
    }
  } else {
    while (
      nextFlushedRoot !== null &amp;&amp;
      nextFlushedExpirationTime !== NoWork &amp;&amp;
      minExpirationTime &lt;= nextFlushedExpirationTime
    ) {
      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);
      findHighestPriorityRoot();
    }
  }
  if (isYieldy) {
    callbackExpirationTime = NoWork;
    callbackID = null;
  }
  if (nextFlushedExpirationTime !== NoWork) {
    scheduleCallbackWithExpirationTime(
      ((nextFlushedRoot: any): FiberRoot),
      nextFlushedExpirationTime,
    );
  }
  finishRendering();
}

</code></pre>

<p>å¯ä»¥çœ‹åˆ°ï¼Œä¸ç®¡åŒæ­¥å¼‚æ­¥ï¼Œéƒ½æœ‰</p>

<pre><code class="language-react">while(
 nextFlushedRoot !== null &amp;&amp;
 nextFlushedExpirationTime !== NoWork &amp;&amp;
 minExpirationTime &lt;= nextFlushedExpirationTime
)
</code></pre>

<p>è¿™æ˜¯ä¸€ä¸ªå¾ªç¯è°ƒåº¦<code>root</code>ä»»åŠ¡çš„è¿‡ç¨‹ï¼Œåˆ¤æ–­æ¡ä»¶ä¸ºè°ƒåº¦é˜Ÿåˆ—ä¸ä¸ºç©ºï¼Œå¹¶ä¸”å½“å‰ä¼ å…¥çš„ä»»åŠ¡ä¼˜å…ˆçº§å°äºä¼˜å…ˆçº§æœ€é«˜çš„ä»»åŠ¡ã€‚å¼‚æ­¥è°ƒç”¨æ—¶è¿˜æœ‰ä¸ªé¢å¤–çš„æ¡ä»¶<code>!(didYield &amp;&amp; currentRendererTime &gt; nextFlushedExpirationTime)</code>ï¼Œç¿»è¯‘è¿‡æ¥å°±æ˜¯å½“å‰ä¼ å…¥çš„å¼‚æ­¥ä»»åŠ¡æ²¡è¿‡æœŸï¼Œå¹¶ä¸”å½“å‰çš„æ¸²æŸ“æ—¶é—´ä¹Ÿæ²¡è¶…è¿‡ä¼˜å…ˆçº§æœ€é«˜çš„ä»»åŠ¡ã€‚ç„¶åè¿™ä¸ªå¾ªç¯å°±ä¼šåœ¨æ¯æ¬¡å¾ªç¯ä¸­è°ƒç”¨<code>performWorkOnRoot</code></p>

<h2 id="10-performworkonroot">10.performWorkOnRoot</h2>

<p>è¿™é‡Œæ˜¯æ•´ä¸ªè°ƒåº¦è¿‡ç¨‹çš„æäº¤ã€renderè¿‡ç¨‹ã€‚ä¸åŒçš„æ˜¯ï¼Œåœ¨å¼‚æ­¥ä»»åŠ¡ä¸­æœ‰ä¸ªåˆ¤æ–­</p>

<pre><code class="language-react">if (!shouldYieldToRenderer()) {
  completeRoot(root, finishedWork, expirationTime);
} else {
  root.finishedWork = finishedWork;
}
</code></pre>

<p>æ„æ€å°±æ˜¯è¯´å¦‚æœå½“å‰æ²¡æœ‰æ—¶é—´å¤„ç†å¼‚æ­¥ä»»åŠ¡ï¼Œç›´æ¥<code>completeRoot</code></p>

<pre><code class="language-react">function performWorkOnRoot(
  root: FiberRoot,
  expirationTime: ExpirationTime,
  isYieldy: boolean,
) {
  invariant(
    !isRendering,
    'performWorkOnRoot was called recursively. This error is likely caused ' +
      'by a bug in React. Please file an issue.',
  );

  isRendering = true;

  if (!isYieldy) {

    let finishedWork = root.finishedWork;
    if (finishedWork !== null) {
      completeRoot(root, finishedWork, expirationTime);
    } else {
      root.finishedWork = null;
      const timeoutHandle = root.timeoutHandle;
      if (timeoutHandle !== noTimeout) {
        root.timeoutHandle = noTimeout;
        cancelTimeout(timeoutHandle);
      }
      renderRoot(root, isYieldy);
      finishedWork = root.finishedWork;
      if (finishedWork !== null) {
        completeRoot(root, finishedWork, expirationTime);
      }
    }
  } else {
    let finishedWork = root.finishedWork;
    if (finishedWork !== null) {
      completeRoot(root, finishedWork, expirationTime);
    } else {
      root.finishedWork = null;
      const timeoutHandle = root.timeoutHandle;
      if (timeoutHandle !== noTimeout) {
        root.timeoutHandle = noTimeout;
        cancelTimeout(timeoutHandle);
      }
      renderRoot(root, isYieldy);
      finishedWork = root.finishedWork;
      if (finishedWork !== null) {
        if (!shouldYieldToRenderer()) {
          completeRoot(root, finishedWork, expirationTime);
        } else {
          root.finishedWork = finishedWork;
        }
      }
    }
  }
  isRendering = false;
}
</code></pre>

<h2 id="11-renderroot">11.renderRoot</h2>

<p>è¿™ä¸ªåˆ¤æ–­çš„æ„æ€å°±æ˜¯å¦‚æœå½“å‰æ²¡æœ‰å…¶ä»–çš„ä»»åŠ¡ï¼Œé‚£ä¹ˆå°±è¿›è¡Œä¸€äº›åˆå§‹åŒ–çš„å·¥ä½œ</p>

<pre><code class="language-react">if (
    expirationTime !== nextRenderExpirationTime ||
    root !== nextRoot ||
    nextUnitOfWork === null
  ) {
    resetStack();
    nextRoot = root;
    nextRenderExpirationTime = expirationTime;
    nextUnitOfWork = createWorkInProgress(
      nextRoot.current,
      null,
      nextRenderExpirationTime,
    );
		root.pendingCommitExpirationTime = NoWork;
		......
}
</code></pre>

<p>ç„¶åè°ƒç”¨<code>workLoop</code>ï¼Œå¯¹äºå¼‚æ­¥ä»»åŠ¡ï¼Œä»è¦åˆ¤æ–­æ˜¯å¦æœ‰å‰©ä½™æ—¶é—´å¤„ç†æ­¤ä»»åŠ¡</p>

<pre><code class="language-react">  do {
    try {
      workLoop(isYieldy);
    } catch (thrownValue) {
      
    }
    break;
  } while (true);
</code></pre>

<pre><code class="language-react">function workLoop(isYieldy) {
  if (!isYieldy) {
    while (nextUnitOfWork !== null) {
      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    }
  } else {
    while (nextUnitOfWork !== null &amp;&amp; !shouldYieldToRenderer()) {
      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    }
  }
}
</code></pre>

<p>å¦‚æœåœ¨è¿™è¿‡ç¨‹ä¸­ä¼šæœ‰æŠ¥é”™ï¼Œåˆ™åœæ­¢è°ƒåº¦ï¼Œä¼šåœ¨ä¸Šé¢çš„<code>catchä¸­</code>å¤„ç†ï¼Œå¹¶ä¸”è®¾ç½®<code>finishedWork</code>ä¸º<code>null</code>ï¼Œä»è€Œç»“æŸè¿™ä¸€æ¬¡çš„<code>render</code></p>

<p><code>performUnitOfWork</code></p>

<pre><code class="language-react">function performUnitOfWork(workInProgress: Fiber): Fiber | null {
  const current = workInProgress.alternate;

  startWorkTimer(workInProgress);
  let next;
  ......
  if (enableProfilerTimer) {
    if (workInProgress.mode &amp; ProfileMode) {
      startProfilerTimer(workInProgress);
    }

    next = beginWork(current, workInProgress, nextRenderExpirationTime);
    workInProgress.memoizedProps = workInProgress.pendingProps;

    if (workInProgress.mode &amp; ProfileMode) {
      stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);
    }
  } else {
    next = beginWork(current, workInProgress, nextRenderExpirationTime);
    workInProgress.memoizedProps = workInProgress.pendingProps;
  }
  if (next === null) {
    next = completeUnitOfWork(workInProgress);
  }
	
  ......
  ReactCurrentOwner.current = null;

  return next;
}
</code></pre>

<p>é¦–å…ˆæ‰§è¡Œ<code>next = beginWork(current, workInProgress, nextRenderExpirationTime)</code>å¯¹èŠ‚ç‚¹è¿›è¡Œæ“ä½œï¼Œå…¶å†…éƒ¨ä¼šé’ˆå¯¹ä¸åŒç±»å‹çš„èŠ‚ç‚¹è¿›è¡Œåˆ›å»ºï¼Œè¿”å›çš„ç»“æœå³ä¼šèµ‹å€¼ç»™<code>next</code>ï¼Œ<code>return next</code>ã€‚ å¦‚æœ<code>next === null</code>ï¼Œè¯´æ˜å­èŠ‚ç‚¹å·²ç»å¤„ç†å®Œï¼Œè°ƒç”¨<code>next = completeUnitOfWork(workInProgress)</code>ã€‚</p>

<p><code>completeUnitOfWork</code>ä¼šä»ä¸‹å¾€ä¸Šéå†ï¼Œå¤„ç†<code>effact tag</code>ï¼Œå¦‚æœåˆ°<code>root</code>èŠ‚ç‚¹è¿”å›çš„æ˜¯<code>null</code>ï¼Œä»£è¡¨æ•´æ£µæ ‘çš„éå†å·²ç»ç»“æŸäº†ï¼Œå¦‚æœæ‰¾åˆ°äº†å…¶ä»–å…„å¼ŸèŠ‚ç‚¹ï¼Œå°±è¿”å›è¿™ä¸ªèŠ‚ç‚¹ï¼Œé‡æ–°èµ°ä¸€é<code>workLoop</code></p>

<h2 id="12-updateclasscomponent">12.updateClassComponent</h2>

<p>åœ¨<code>beginWork</code>ä¸­ï¼Œä¼šé’ˆå¯¹ä¸åŒçš„èŠ‚ç‚¹ç±»å‹æ¥è°ƒç”¨ä¸åŒçš„æ–¹æ³•å¤„ç†ï¼Œè¿™é‡Œä»¥<code>ClassComponent</code>ä¸ºä¾‹</p>

<pre><code class="language-react">function updateClassComponent(
  current: Fiber | null,
  workInProgress: Fiber,
  Component: any,
  nextProps,
  renderExpirationTime: ExpirationTime,
) {
	......
  // å¯¹contextè¿›è¡Œå¤„ç†
  let hasContext;
  // å¦‚æœå½“å‰ç»„ä»¶æ˜¯context provider
  // è®¾ç½®hasContextæ ‡è®°
  if (isLegacyContextProvider(Component)) {
    hasContext = true;
    pushLegacyContextProvider(workInProgress);
  } else {
    hasContext = false;
  }
  prepareToReadContext(workInProgress, renderExpirationTime);

  const instance = workInProgress.stateNode;
  let shouldUpdate;
  // å¦‚æœå®ä¾‹ä¸ºç©º
  if (instance === null) {
    if (current !== null) {
      current.alternate = null;
      workInProgress.alternate = null;
      workInProgress.effectTag |= Placement;
    }
    constructClassInstance(
      workInProgress,
      Component,
      nextProps,
      renderExpirationTime,
    );
    // æŒ‚è½½è¿™ä¸ªå®ä¾‹
    mountClassInstance(
      workInProgress,
      Component,
      nextProps,
      renderExpirationTime,
    );
    shouldUpdate = true;
  } else if (current === null) {
    // ç¬¬ä¸€æ¬¡æ¸²æŸ“æ—¶ï¼Œcurrentä¸ºnull
    // é‡æ–°æŒ‚è½½å®ä¾‹
    shouldUpdate = resumeMountClassInstance(
      workInProgress,
      Component,
      nextProps,
      renderExpirationTime,
    );
  } else {
    // æ›´æ–°ç±»ç»„ä»¶çš„æ—¶å€™
    // è°ƒç”¨updateClassInstance
    shouldUpdate = updateClassInstance(
      current,
      workInProgress,
      Component,
      nextProps,
      renderExpirationTime,
    );
  }
  ......
  // è°ƒç”¨finishClassComponent
  // å¦‚æœéœ€è¦æ›´æ–°ï¼Œè°ƒç”¨reconcileChildrenï¼Œè¿”å›æ›´æ–°åçš„workInProgress
  const nextUnitOfWork = finishClassComponent(
    current,
    workInProgress,
    Component,
    shouldUpdate,
    hasContext,
    renderExpirationTime,
  );
  return nextUnitOfWork;
}
</code></pre>

<p><code>constructClassInstance</code></p>

<pre><code class="language-react">function constructClassInstance(
  workInProgress: Fiber,
  ctor: any,
  props: any,
  renderExpirationTime: ExpirationTime,
): any {
  .......
  adoptClassInstance(workInProgress, instance);
}
</code></pre>

<p><code>adoptClassInstance</code></p>

<pre><code class="language-react">function adoptClassInstance(workInProgress: Fiber, instance: any): void {
  instance.updater = classComponentUpdater;
  workInProgress.stateNode = instance;
  setInstance(instance, workInProgress);
	......
}
  
const classComponentUpdater = {
  isMounted,
  enqueueSetState(inst, payload, callback) {
  },
  enqueueReplaceState(inst, payload, callback) {
  },
  enqueueForceUpdate(inst, callback) {
};
</code></pre>

<p><code>classComponentUpdater</code>é‡Œé¢å‡ ä¸ªæ–¹æ³•ï¼Œå³å¯¹åº”ç€<code>setState</code>ã€<code>replaceState</code>ã€<code>forceUpdate</code></p>

<p><code>mountClassInstance</code></p>

<pre><code class="language-react">function mountClassInstance(
  workInProgress: Fiber,
  ctor: any,
  newProps: any,
  renderExpirationTime: ExpirationTime,
): void {
  if (__DEV__) {
    checkClassInstance(workInProgress, ctor, newProps);
  }

  const instance = workInProgress.stateNode;
  // åˆå§‹åŒ– propsã€state ç­‰å®ä¾‹å±æ€§
  instance.props = newProps;
  instance.state = workInProgress.memoizedState;
  instance.refs = emptyRefsObject;

  const contextType = ctor.contextType;
  if (typeof contextType === 'object' &amp;&amp; contextType !== null) {
    instance.context = readContext(contextType);
  } else {
    const unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
    instance.context = getMaskedContext(workInProgress, unmaskedContext);
  }
	.......
	// å¦‚æœæœ‰updateQueueå°±æ›´æ–°
  let updateQueue = workInProgress.updateQueue;
  if (updateQueue !== null) {
    processUpdateQueue(
      workInProgress,
      updateQueue,
      newProps,
      instance,
      renderExpirationTime,
    );
    instance.state = workInProgress.memoizedState;
  }
	
	// å¦‚æœå®šä¹‰äº†getDerivedStateFromPropså‘¨æœŸå‡½æ•°ï¼Œåˆ™è°ƒç”¨
  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  if (typeof getDerivedStateFromProps === 'function') {
    applyDerivedStateFromProps(
      workInProgress,
      ctor,
      getDerivedStateFromProps,
      newProps,
    );
    instance.state = workInProgress.memoizedState;
  }

  if (
    typeof ctor.getDerivedStateFromProps !== 'function' &amp;&amp;
    typeof instance.getSnapshotBeforeUpdate !== 'function' &amp;&amp;
    (typeof instance.UNSAFE_componentWillMount === 'function' ||
      typeof instance.componentWillMount === 'function')
  ) {
    callComponentWillMount(workInProgress, instance);
    updateQueue = workInProgress.updateQueue;
    if (updateQueue !== null) {
      processUpdateQueue(
        workInProgress,
        updateQueue,
        newProps,
        instance,
        renderExpirationTime,
      );
      instance.state = workInProgress.memoizedState;
    }
  }

  // åˆ¤æ–­æ˜¯å¦æœ‰componentDidMountï¼Œ
	// componentDidMountè¦åœ¨çœŸæ­£æ¸²æŸ“è¿›DOMä¹‹åæ‰è°ƒç”¨ï¼Œä¹Ÿå°±æ˜¯commitä¹‹å
  if (typeof instance.componentDidMount === 'function') {
    workInProgress.effectTag |= Update;
  }
}
</code></pre>

<h2 id="13-commitroot">13.commitRoot</h2>

<p>è°ƒç”¨å®Œ<code>renderRoot</code>ä¹‹åï¼Œ<code>fiber</code>ä¸­å¯¹åº”çš„æ¯ä¸ªèŠ‚ç‚¹éƒ½æ‰§è¡Œäº†<code>render</code>ä¹‹å‰æ‰€æœ‰çš„ç”Ÿå‘½å‘¨æœŸå‡½æ•°ï¼Œå¹¶åˆ›å»ºäº†å¯¹åº”çš„DOMå…ƒç´ ï¼Œæ”¾åœ¨<code>workInProgress.stateNode</code>ä¸­ã€‚ç„¶åè°ƒç”¨<code>commitRoot</code>ï¼Œè¢«æäº¤çš„ä»»åŠ¡åº”è¯¥æ˜¯ï¼šå­æ ‘ä¸­ä¼˜å…ˆçº§æœ€é«˜çš„ä»»åŠ¡æˆ–è€…å¤–éƒ¨æŒ‡å®šçš„ä¼˜å…ˆçº§ï¼ˆflushSyncæˆ–è€…retryï¼‰ï¼Œç„¶åè°ƒç”¨<code>componentWillMount</code>ï¼Œæ›´æ–°DOMå…ƒç´ çš„å±æ€§åï¼ŒæŒ‚è½½ç»„ä»¶ï¼Œè°ƒç”¨<code>componentDidMount</code></p>

    </div>

    

  
    <div class="post-tags">
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> Â· 
                <span><a href="https://xtid.github.io">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://xtid.github.io/2020/flutter%E5%90%84%E7%A7%8D%E8%B8%A9%E5%9D%91%E5%BF%83%E5%BE%97/" class="prev" rel="prev" title="Flutterå„ç§è¸©å‘å¿ƒå¾—"><i class="iconfont icon-left"></i>&nbsp;Flutterå„ç§è¸©å‘å¿ƒå¾—</a>
         
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2019 - 2021</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  



     </div>
  </body>
</html>
